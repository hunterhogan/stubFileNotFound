import re
from _typeshed import Incomplete
from typing import ClassVar

__all__ = ['parse', 'Version', 'LegacyVersion', 'InvalidVersion', 'VERSION_PATTERN']

class InfinityType:
    def __hash__(self) -> int: ...
    def __lt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __neg__(self: object) -> NegativeInfinityType: ...

class NegativeInfinityType:
    def __hash__(self) -> int: ...
    def __lt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __neg__(self: object) -> InfinityType: ...

class _Version(tuple):
    _fields: ClassVar[tuple] = ...
    _field_defaults: ClassVar[dict] = ...
    __match_args__: ClassVar[tuple] = ...
    epoch: Incomplete
    release: Incomplete
    dev: Incomplete
    pre: Incomplete
    post: Incomplete
    local: Incomplete
    def __init__(self, _cls, epoch, release, dev, pre, post, local) -> None:
        """Create new instance of _Version(epoch, release, dev, pre, post, local)"""
    @classmethod
    def _make(cls, iterable):
        """Make a new _Version object from a sequence or iterable"""
    def __replace__(self, **kwds):
        """Return a new _Version object replacing specified fields with new values"""
    def _replace(self, **kwds):
        """Return a new _Version object replacing specified fields with new values"""
    def _asdict(self):
        """Return a new dict which maps field names to their values."""
    def __getnewargs__(self):
        """Return self as a plain tuple.  Used by copy and pickle."""
def parse(version: str) -> LegacyVersion | Version:
    """
    Parse the given version string and return either a :class:`Version` object
    or a :class:`LegacyVersion` object depending on if the given version is
    a valid PEP 440 version or a legacy version.
    """

class InvalidVersion(ValueError): ...

class _BaseVersion:
    def __hash__(self) -> int: ...
    def __lt__(self, other: _BaseVersion) -> bool: ...
    def __le__(self, other: _BaseVersion) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: _BaseVersion) -> bool: ...
    def __gt__(self, other: _BaseVersion) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class LegacyVersion(_BaseVersion):
    def __init__(self, version: str) -> None: ...
    @property
    def public(self): ...
    @property
    def base_version(self): ...
    @property
    def epoch(self): ...
    @property
    def release(self): ...
    @property
    def pre(self): ...
    @property
    def post(self): ...
    @property
    def dev(self): ...
    @property
    def local(self): ...
    @property
    def is_prerelease(self): ...
    @property
    def is_postrelease(self): ...
    @property
    def is_devrelease(self): ...
VERSION_PATTERN: str

class Version(_BaseVersion):
    _regex: ClassVar[re.Pattern] = ...
    def __init__(self, version: str) -> None: ...
    @property
    def epoch(self): ...
    @property
    def release(self): ...
    @property
    def pre(self): ...
    @property
    def post(self): ...
    @property
    def dev(self): ...
    @property
    def local(self): ...
    @property
    def public(self): ...
    @property
    def base_version(self): ...
    @property
    def is_prerelease(self): ...
    @property
    def is_postrelease(self): ...
    @property
    def is_devrelease(self): ...
    @property
    def major(self): ...
    @property
    def minor(self): ...
    @property
    def micro(self): ...
