import re
from _typeshed import Incomplete
from collections.abc import Sequence
from pandas import Series as Series
from pandas._typing import NpDtype as NpDtype, Scalar as Scalar
from pandas.core.strings.base import BaseStringArrayMethods as BaseStringArrayMethods
from typing import Literal

from collections.abc import Callable

class ObjectStringArrayMixin(BaseStringArrayMethods):
    """
    String Methods operating on object-dtype ndarrays.
    """
    _str_na_value: Incomplete
    def __len__(self) -> int: ...
    def _str_map(self, f, na_value: Incomplete | None = None, dtype: NpDtype | None = None, convert: bool = True):
        """
        Map a callable over valid elements of the array.

        Parameters
        ----------
        f : Callable
            A function to call on each non-NA element.
        na_value : Scalar, optional
            The value to set for NA values. Might also be used for the
            fill value if the callable `f` raises an exception.
            This defaults to ``self._str_na_value`` which is ``np.nan``
            for object-dtype and Categorical and ``pd.NA`` for StringArray.
        dtype : Dtype, optional
            The dtype of the result array.
        convert : bool, default True
            Whether to call `maybe_convert_objects` on the resulting ndarray
        """
    def _str_count(self, pat, flags: int = 0): ...
    def _str_pad(self, width: int, side: Literal['left', 'right', 'both'] = 'left', fillchar: str = ' '): ...
    def _str_contains(self, pat, case: bool = True, flags: int = 0, na=..., regex: bool = True): ...
    def _str_startswith(self, pat, na: Incomplete | None = None): ...
    def _str_endswith(self, pat, na: Incomplete | None = None): ...
    def _str_replace(self, pat: str | re.Pattern, repl: str | Callable, n: int = -1, case: bool = True, flags: int = 0, regex: bool = True): ...
    def _str_repeat(self, repeats: int | Sequence[int]): ...
    def _str_match(self, pat: str, case: bool = True, flags: int = 0, na: Scalar | None = None): ...
    def _str_fullmatch(self, pat: str | re.Pattern, case: bool = True, flags: int = 0, na: Scalar | None = None): ...
    def _str_encode(self, encoding, errors: str = 'strict'): ...
    def _str_find(self, sub, start: int = 0, end: Incomplete | None = None): ...
    def _str_rfind(self, sub, start: int = 0, end: Incomplete | None = None): ...
    def _str_find_(self, sub, start, end, side): ...
    def _str_findall(self, pat, flags: int = 0): ...
    def _str_get(self, i): ...
    def _str_index(self, sub, start: int = 0, end: Incomplete | None = None): ...
    def _str_rindex(self, sub, start: int = 0, end: Incomplete | None = None): ...
    def _str_join(self, sep: str): ...
    def _str_partition(self, sep: str, expand): ...
    def _str_rpartition(self, sep: str, expand): ...
    def _str_len(self): ...
    def _str_slice(self, start: Incomplete | None = None, stop: Incomplete | None = None, step: Incomplete | None = None): ...
    def _str_slice_replace(self, start: Incomplete | None = None, stop: Incomplete | None = None, repl: Incomplete | None = None): ...
    def _str_split(self, pat: str | re.Pattern | None = None, n: int = -1, expand: bool = False, regex: bool | None = None): ...
    def _str_rsplit(self, pat: Incomplete | None = None, n: int = -1): ...
    def _str_translate(self, table): ...
    def _str_wrap(self, width: int, **kwargs): ...
    def _str_get_dummies(self, sep: str = '|'): ...
    def _str_upper(self): ...
    def _str_isalnum(self): ...
    def _str_isalpha(self): ...
    def _str_isdecimal(self): ...
    def _str_isdigit(self): ...
    def _str_islower(self): ...
    def _str_isnumeric(self): ...
    def _str_isspace(self): ...
    def _str_istitle(self): ...
    def _str_isupper(self): ...
    def _str_capitalize(self): ...
    def _str_casefold(self): ...
    def _str_title(self): ...
    def _str_swapcase(self): ...
    def _str_lower(self): ...
    def _str_normalize(self, form): ...
    def _str_strip(self, to_strip: Incomplete | None = None): ...
    def _str_lstrip(self, to_strip: Incomplete | None = None): ...
    def _str_rstrip(self, to_strip: Incomplete | None = None): ...
    def _str_removeprefix(self, prefix: str) -> Series: ...
    def _str_removesuffix(self, suffix: str) -> Series: ...
    def _str_extract(self, pat: str, flags: int = 0, expand: bool = True): ...
