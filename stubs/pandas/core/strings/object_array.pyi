import _abc
import pandas._libs.lib as lib
import pandas._libs.missing as libmissing
import pandas._libs.ops as libops
import pandas.core.strings.base
import re
from pandas.core.dtypes.missing import isna as isna
from pandas.core.strings.base import BaseStringArrayMethods as BaseStringArrayMethods
from typing import Callable, ClassVar, Literal

TYPE_CHECKING: bool

class ObjectStringArrayMixin(pandas.core.strings.base.BaseStringArrayMethods):
    _str_na_value: ClassVar[float] = ...
    __abstractmethods__: ClassVar[frozenset] = ...
    _abc_impl: ClassVar[_abc._abc_data] = ...
    def __len__(self) -> int: ...
    def _str_map(self, f, na_value, dtype: NpDtype | None, convert: bool = ...):
        """
        Map a callable over valid elements of the array.

        Parameters
        ----------
        f : Callable
            A function to call on each non-NA element.
        na_value : Scalar, optional
            The value to set for NA values. Might also be used for the
            fill value if the callable `f` raises an exception.
            This defaults to ``self._str_na_value`` which is ``np.nan``
            for object-dtype and Categorical and ``pd.NA`` for StringArray.
        dtype : Dtype, optional
            The dtype of the result array.
        convert : bool, default True
            Whether to call `maybe_convert_objects` on the resulting ndarray
        """
    def _str_count(self, pat, flags: int = ...): ...
    def _str_pad(self, width: int, side: Literal['left', 'right', 'both'] = ..., fillchar: str = ...): ...
    def _str_contains(self, pat, case: bool = ..., flags: int = ..., na: float = ..., regex: bool = ...): ...
    def _str_startswith(self, pat, na): ...
    def _str_endswith(self, pat, na): ...
    def _str_replace(self, pat: str | re.Pattern, repl: str | Callable, n: int = ..., case: bool = ..., flags: int = ..., regex: bool = ...): ...
    def _str_repeat(self, repeats: int | Sequence[int]): ...
    def _str_match(self, pat: str, case: bool = ..., flags: int = ..., na: Scalar | None): ...
    def _str_fullmatch(self, pat: str | re.Pattern, case: bool = ..., flags: int = ..., na: Scalar | None): ...
    def _str_encode(self, encoding, errors: str = ...): ...
    def _str_find(self, sub, start: int = ..., end): ...
    def _str_rfind(self, sub, start: int = ..., end): ...
    def _str_find_(self, sub, start, end, side): ...
    def _str_findall(self, pat, flags: int = ...): ...
    def _str_get(self, i): ...
    def _str_index(self, sub, start: int = ..., end): ...
    def _str_rindex(self, sub, start: int = ..., end): ...
    def _str_join(self, sep: str): ...
    def _str_partition(self, sep: str, expand): ...
    def _str_rpartition(self, sep: str, expand): ...
    def _str_len(self): ...
    def _str_slice(self, start, stop, step): ...
    def _str_slice_replace(self, start, stop, repl): ...
    def _str_split(self, pat: str | re.Pattern | None, n: int = ..., expand: bool = ..., regex: bool | None): ...
    def _str_rsplit(self, pat, n: int = ...): ...
    def _str_translate(self, table): ...
    def _str_wrap(self, width: int, **kwargs): ...
    def _str_get_dummies(self, sep: str = ...): ...
    def _str_upper(self): ...
    def _str_isalnum(self): ...
    def _str_isalpha(self): ...
    def _str_isdecimal(self): ...
    def _str_isdigit(self): ...
    def _str_islower(self): ...
    def _str_isnumeric(self): ...
    def _str_isspace(self): ...
    def _str_istitle(self): ...
    def _str_isupper(self): ...
    def _str_capitalize(self): ...
    def _str_casefold(self): ...
    def _str_title(self): ...
    def _str_swapcase(self): ...
    def _str_lower(self): ...
    def _str_normalize(self, form): ...
    def _str_strip(self, to_strip): ...
    def _str_lstrip(self, to_strip): ...
    def _str_rstrip(self, to_strip): ...
    def _str_removeprefix(self, prefix: str) -> Series: ...
    def _str_removesuffix(self, suffix: str) -> Series: ...
    def _str_extract(self, pat: str, flags: int = ..., expand: bool = ...): ...
