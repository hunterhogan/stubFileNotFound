import abc
import re
from _typeshed import Incomplete
from collections.abc import Sequence
from pandas import Series as Series
from pandas._typing import Scalar as Scalar
from typing import Callable, Literal

class BaseStringArrayMethods(abc.ABC, metaclass=abc.ABCMeta):
    """
    Base class for extension arrays implementing string methods.

    This is where our ExtensionArrays can override the implementation of
    Series.str.<method>. We don't expect this to work with
    3rd-party extension arrays.

    * User calls Series.str.<method>
    * pandas extracts the extension array from the Series
    * pandas calls ``extension_array._str_<method>(*args, **kwargs)``
    * pandas wraps the result, to return to the user.

    See :ref:`Series.str` for the docstring of each method.
    """
    def _str_getitem(self, key): ...
    @abc.abstractmethod
    def _str_count(self, pat, flags: int = 0): ...
    @abc.abstractmethod
    def _str_pad(self, width: int, side: Literal['left', 'right', 'both'] = 'left', fillchar: str = ' '): ...
    @abc.abstractmethod
    def _str_contains(self, pat, case: bool = True, flags: int = 0, na: Incomplete | None = None, regex: bool = True): ...
    @abc.abstractmethod
    def _str_startswith(self, pat, na: Incomplete | None = None): ...
    @abc.abstractmethod
    def _str_endswith(self, pat, na: Incomplete | None = None): ...
    @abc.abstractmethod
    def _str_replace(self, pat: str | re.Pattern, repl: str | Callable, n: int = -1, case: bool = True, flags: int = 0, regex: bool = True): ...
    @abc.abstractmethod
    def _str_repeat(self, repeats: int | Sequence[int]): ...
    @abc.abstractmethod
    def _str_match(self, pat: str, case: bool = True, flags: int = 0, na: Scalar = ...): ...
    @abc.abstractmethod
    def _str_fullmatch(self, pat: str | re.Pattern, case: bool = True, flags: int = 0, na: Scalar = ...): ...
    @abc.abstractmethod
    def _str_encode(self, encoding, errors: str = 'strict'): ...
    @abc.abstractmethod
    def _str_find(self, sub, start: int = 0, end: Incomplete | None = None): ...
    @abc.abstractmethod
    def _str_rfind(self, sub, start: int = 0, end: Incomplete | None = None): ...
    @abc.abstractmethod
    def _str_findall(self, pat, flags: int = 0): ...
    @abc.abstractmethod
    def _str_get(self, i): ...
    @abc.abstractmethod
    def _str_index(self, sub, start: int = 0, end: Incomplete | None = None): ...
    @abc.abstractmethod
    def _str_rindex(self, sub, start: int = 0, end: Incomplete | None = None): ...
    @abc.abstractmethod
    def _str_join(self, sep: str): ...
    @abc.abstractmethod
    def _str_partition(self, sep: str, expand): ...
    @abc.abstractmethod
    def _str_rpartition(self, sep: str, expand): ...
    @abc.abstractmethod
    def _str_len(self): ...
    @abc.abstractmethod
    def _str_slice(self, start: Incomplete | None = None, stop: Incomplete | None = None, step: Incomplete | None = None): ...
    @abc.abstractmethod
    def _str_slice_replace(self, start: Incomplete | None = None, stop: Incomplete | None = None, repl: Incomplete | None = None): ...
    @abc.abstractmethod
    def _str_translate(self, table): ...
    @abc.abstractmethod
    def _str_wrap(self, width: int, **kwargs): ...
    @abc.abstractmethod
    def _str_get_dummies(self, sep: str = '|'): ...
    @abc.abstractmethod
    def _str_isalnum(self): ...
    @abc.abstractmethod
    def _str_isalpha(self): ...
    @abc.abstractmethod
    def _str_isdecimal(self): ...
    @abc.abstractmethod
    def _str_isdigit(self): ...
    @abc.abstractmethod
    def _str_islower(self): ...
    @abc.abstractmethod
    def _str_isnumeric(self): ...
    @abc.abstractmethod
    def _str_isspace(self): ...
    @abc.abstractmethod
    def _str_istitle(self): ...
    @abc.abstractmethod
    def _str_isupper(self): ...
    @abc.abstractmethod
    def _str_capitalize(self): ...
    @abc.abstractmethod
    def _str_casefold(self): ...
    @abc.abstractmethod
    def _str_title(self): ...
    @abc.abstractmethod
    def _str_swapcase(self): ...
    @abc.abstractmethod
    def _str_lower(self): ...
    @abc.abstractmethod
    def _str_upper(self): ...
    @abc.abstractmethod
    def _str_normalize(self, form): ...
    @abc.abstractmethod
    def _str_strip(self, to_strip: Incomplete | None = None): ...
    @abc.abstractmethod
    def _str_lstrip(self, to_strip: Incomplete | None = None): ...
    @abc.abstractmethod
    def _str_rstrip(self, to_strip: Incomplete | None = None): ...
    @abc.abstractmethod
    def _str_removeprefix(self, prefix: str) -> Series: ...
    @abc.abstractmethod
    def _str_removesuffix(self, suffix: str) -> Series: ...
    @abc.abstractmethod
    def _str_split(self, pat: Incomplete | None = None, n: int = -1, expand: bool = False, regex: bool | None = None): ...
    @abc.abstractmethod
    def _str_rsplit(self, pat: Incomplete | None = None, n: int = -1): ...
    @abc.abstractmethod
    def _str_extract(self, pat: str, flags: int = 0, expand: bool = True): ...
