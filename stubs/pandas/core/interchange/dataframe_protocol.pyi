import _abc
import abc
import enum
from typing import ClassVar

TYPE_CHECKING: bool

class DlpackDeviceType(enum.IntEnum):
    _new_member_: ClassVar[builtin_function_or_method] = ...
    _use_args_: ClassVar[bool] = ...
    _member_names_: ClassVar[list] = ...
    _member_map_: ClassVar[dict] = ...
    _value2member_map_: ClassVar[dict] = ...
    _hashable_values_: ClassVar[list] = ...
    _unhashable_values_: ClassVar[list] = ...
    _unhashable_values_map_: ClassVar[dict] = ...
    _member_type_: ClassVar[type[int]] = ...
    _value_repr_: ClassVar[wrapper_descriptor] = ...
    CPU: ClassVar[DlpackDeviceType] = ...
    CUDA: ClassVar[DlpackDeviceType] = ...
    CPU_PINNED: ClassVar[DlpackDeviceType] = ...
    OPENCL: ClassVar[DlpackDeviceType] = ...
    VULKAN: ClassVar[DlpackDeviceType] = ...
    METAL: ClassVar[DlpackDeviceType] = ...
    VPI: ClassVar[DlpackDeviceType] = ...
    ROCM: ClassVar[DlpackDeviceType] = ...
    __format__: ClassVar[method_descriptor] = ...
    @staticmethod
    def _generate_next_value_(name, start, count, last_values):
        """
        Generate the next value when not given.

        name: the name of the member
        start: the initial start value or None
        count: the number of existing members
        last_values: the list of values assigned
        """
    @classmethod
    def __init__(cls, value) -> None: ...

class DtypeKind(enum.IntEnum):
    _new_member_: ClassVar[builtin_function_or_method] = ...
    _use_args_: ClassVar[bool] = ...
    _member_names_: ClassVar[list] = ...
    _member_map_: ClassVar[dict] = ...
    _value2member_map_: ClassVar[dict] = ...
    _hashable_values_: ClassVar[list] = ...
    _unhashable_values_: ClassVar[list] = ...
    _unhashable_values_map_: ClassVar[dict] = ...
    _member_type_: ClassVar[type[int]] = ...
    _value_repr_: ClassVar[wrapper_descriptor] = ...
    INT: ClassVar[DtypeKind] = ...
    UINT: ClassVar[DtypeKind] = ...
    FLOAT: ClassVar[DtypeKind] = ...
    BOOL: ClassVar[DtypeKind] = ...
    STRING: ClassVar[DtypeKind] = ...
    DATETIME: ClassVar[DtypeKind] = ...
    CATEGORICAL: ClassVar[DtypeKind] = ...
    __format__: ClassVar[method_descriptor] = ...
    @staticmethod
    def _generate_next_value_(name, start, count, last_values):
        """
        Generate the next value when not given.

        name: the name of the member
        start: the initial start value or None
        count: the number of existing members
        last_values: the list of values assigned
        """
    @classmethod
    def __init__(cls, value) -> None: ...

class ColumnNullType(enum.IntEnum):
    _new_member_: ClassVar[builtin_function_or_method] = ...
    _use_args_: ClassVar[bool] = ...
    _member_names_: ClassVar[list] = ...
    _member_map_: ClassVar[dict] = ...
    _value2member_map_: ClassVar[dict] = ...
    _hashable_values_: ClassVar[list] = ...
    _unhashable_values_: ClassVar[list] = ...
    _unhashable_values_map_: ClassVar[dict] = ...
    _member_type_: ClassVar[type[int]] = ...
    _value_repr_: ClassVar[wrapper_descriptor] = ...
    NON_NULLABLE: ClassVar[ColumnNullType] = ...
    USE_NAN: ClassVar[ColumnNullType] = ...
    USE_SENTINEL: ClassVar[ColumnNullType] = ...
    USE_BITMASK: ClassVar[ColumnNullType] = ...
    USE_BYTEMASK: ClassVar[ColumnNullType] = ...
    __format__: ClassVar[method_descriptor] = ...
    @staticmethod
    def _generate_next_value_(name, start, count, last_values):
        """
        Generate the next value when not given.

        name: the name of the member
        start: the initial start value or None
        count: the number of existing members
        last_values: the list of values assigned
        """
    @classmethod
    def __init__(cls, value) -> None: ...

class ColumnBuffers(dict):
    __orig_bases__: ClassVar[tuple] = ...
    __required_keys__: ClassVar[frozenset] = ...
    __optional_keys__: ClassVar[frozenset] = ...
    __readonly_keys__: ClassVar[frozenset] = ...
    __mutable_keys__: ClassVar[frozenset] = ...
    __total__: ClassVar[bool] = ...

class CategoricalDescription(dict):
    __orig_bases__: ClassVar[tuple] = ...
    __required_keys__: ClassVar[frozenset] = ...
    __optional_keys__: ClassVar[frozenset] = ...
    __readonly_keys__: ClassVar[frozenset] = ...
    __mutable_keys__: ClassVar[frozenset] = ...
    __total__: ClassVar[bool] = ...

class Buffer(abc.ABC):
    __abstractmethods__: ClassVar[frozenset] = ...
    _abc_impl: ClassVar[_abc._abc_data] = ...
    def __dlpack__(self):
        """
        Produce DLPack capsule (see array API standard).

        Raises:

            - TypeError : if the buffer contains unsupported dtypes.
            - NotImplementedError : if DLPack support is not implemented

        Useful to have to connect to array libraries. Support optional because
        it's not completely trivial to implement for a Python-only library.
        """
    def __dlpack_device__(self) -> tuple[DlpackDeviceType, int | None]:
        """
        Device type and device ID for where the data in the buffer resides.
        Uses device type codes matching DLPack.
        Note: must be implemented even if ``__dlpack__`` is not.
        """
    @property
    def bufsize(self): ...
    @property
    def ptr(self): ...

class Column(abc.ABC):
    __abstractmethods__: ClassVar[frozenset] = ...
    _abc_impl: ClassVar[_abc._abc_data] = ...
    def size(self) -> int:
        """
        Size of the column, in elements.

        Corresponds to DataFrame.num_rows() if column is a single chunk;
        equal to size of this current chunk otherwise.
        """
    def num_chunks(self) -> int:
        """
        Return the number of chunks the column consists of.
        """
    def get_chunks(self, n_chunks: int | None) -> Iterable[Column]:
        """
        Return an iterator yielding the chunks.

        See `DataFrame.get_chunks` for details on ``n_chunks``.
        """
    def get_buffers(self) -> ColumnBuffers:
        '''
        Return a dictionary containing the underlying buffers.

        The returned dictionary has the following contents:

            - "data": a two-element tuple whose first element is a buffer
                      containing the data and whose second element is the data
                      buffer\'s associated dtype.
            - "validity": a two-element tuple whose first element is a buffer
                          containing mask values indicating missing data and
                          whose second element is the mask value buffer\'s
                          associated dtype. None if the null representation is
                          not a bit or byte mask.
            - "offsets": a two-element tuple whose first element is a buffer
                         containing the offset values for variable-size binary
                         data (e.g., variable-length strings) and whose second
                         element is the offsets buffer\'s associated dtype. None
                         if the data buffer does not have an associated offsets
                         buffer.
        '''
    @property
    def offset(self): ...
    @property
    def dtype(self): ...
    @property
    def describe_categorical(self): ...
    @property
    def describe_null(self): ...
    @property
    def null_count(self): ...
    @property
    def metadata(self): ...

class DataFrame(abc.ABC):
    version: ClassVar[int] = ...
    __abstractmethods__: ClassVar[frozenset] = ...
    _abc_impl: ClassVar[_abc._abc_data] = ...
    def __dataframe__(self, nan_as_null: bool = ..., allow_copy: bool = ...):
        """Construct a new interchange object, potentially changing the parameters."""
    def num_columns(self) -> int:
        """
        Return the number of columns in the DataFrame.
        """
    def num_rows(self) -> int | None:
        """
        Return the number of rows in the DataFrame, if available.
        """
    def num_chunks(self) -> int:
        """
        Return the number of chunks the DataFrame consists of.
        """
    def column_names(self) -> Iterable[str]:
        """
        Return an iterator yielding the column names.
        """
    def get_column(self, i: int) -> Column:
        """
        Return the column at the indicated position.
        """
    def get_column_by_name(self, name: str) -> Column:
        """
        Return the column whose name is the indicated name.
        """
    def get_columns(self) -> Iterable[Column]:
        """
        Return an iterator yielding the columns.
        """
    def select_columns(self, indices: Sequence[int]) -> DataFrame:
        """
        Create a new DataFrame by selecting a subset of columns by index.
        """
    def select_columns_by_name(self, names: Sequence[str]) -> DataFrame:
        """
        Create a new DataFrame by selecting a subset of columns by name.
        """
    def get_chunks(self, n_chunks: int | None) -> Iterable[DataFrame]:
        """
        Return an iterator yielding the chunks.

        By default (None), yields the chunks that the data is stored as by the
        producer. If given, ``n_chunks`` must be a multiple of
        ``self.num_chunks()``, meaning the producer must subdivide each chunk
        before yielding it.
        """
    @property
    def metadata(self): ...
