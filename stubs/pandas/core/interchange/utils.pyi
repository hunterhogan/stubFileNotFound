import pandas._libs.lib as lib
import pd as pd
from pandas.core.dtypes.dtypes import ArrowDtype as ArrowDtype, CategoricalDtype as CategoricalDtype, DatetimeTZDtype as DatetimeTZDtype
from typing import ClassVar

PYARROW_CTYPES: dict

class ArrowCTypes:
    NULL: ClassVar[str] = ...
    BOOL: ClassVar[str] = ...
    INT8: ClassVar[str] = ...
    UINT8: ClassVar[str] = ...
    INT16: ClassVar[str] = ...
    UINT16: ClassVar[str] = ...
    INT32: ClassVar[str] = ...
    UINT32: ClassVar[str] = ...
    INT64: ClassVar[str] = ...
    UINT64: ClassVar[str] = ...
    FLOAT16: ClassVar[str] = ...
    FLOAT32: ClassVar[str] = ...
    FLOAT64: ClassVar[str] = ...
    STRING: ClassVar[str] = ...
    LARGE_STRING: ClassVar[str] = ...
    DATE32: ClassVar[str] = ...
    DATE64: ClassVar[str] = ...
    TIMESTAMP: ClassVar[str] = ...
    TIME: ClassVar[str] = ...

class Endianness:
    LITTLE: ClassVar[str] = ...
    BIG: ClassVar[str] = ...
    NATIVE: ClassVar[str] = ...
    NA: ClassVar[str] = ...
def dtype_to_arrow_c_fmt(dtype: DtypeObj) -> str:
    """
    Represent pandas `dtype` as a format string in Apache Arrow C notation.

    Parameters
    ----------
    dtype : np.dtype
        Datatype of pandas DataFrame to represent.

    Returns
    -------
    str
        Format string in Apache Arrow C notation of the given `dtype`.
    """
def maybe_rechunk(series: pd.Series, *, allow_copy: bool) -> pd.Series | None:
    """
    Rechunk a multi-chunk pyarrow array into a single-chunk array, if necessary.

    - Returns `None` if the input series is not backed by a multi-chunk pyarrow array
      (and so doesn't need rechunking)
    - Returns a single-chunk-backed-Series if the input is backed by a multi-chunk
      pyarrow array and `allow_copy` is `True`.
    - Raises a `RuntimeError` if `allow_copy` is `False` and input is a
      based by a multi-chunk pyarrow array.
    """
