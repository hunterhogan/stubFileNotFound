import ast
import functools
import pandas.core.common as com
import pandas.core.computation.ops
import pandas.io.formats.printing as printing
import typing
from pandas.core.computation.ops import BinOp as BinOp, Constant as Constant, FuncNode as FuncNode, Op as Op, Term as Term, UnaryOp as UnaryOp, is_term as is_term
from pandas.core.computation.parsing import clean_backtick_quoted_toks as clean_backtick_quoted_toks, tokenize_string as tokenize_string
from pandas.core.computation.scope import Scope as Scope
from pandas.errors import UndefinedVariableError as UndefinedVariableError
from typing import Callable, Callable as _Callable, ClassVar as _ClassVar

iskeyword: builtin_function_or_method
ARITH_OPS_SYMS: tuple
BOOL_OPS_SYMS: tuple
CMP_OPS_SYMS: tuple
LOCAL_TAG: str
MATHOPS: tuple
REDUCTIONS: tuple
UNARY_OPS_SYMS: tuple
def _rewrite_assign(tok: tuple[int, str]) -> tuple[int, str]:
    """
    Rewrite the assignment operator for PyTables expressions that use ``=``
    as a substitute for ``==``.

    Parameters
    ----------
    tok : tuple of int, str
        ints correspond to the all caps constants in the tokenize module

    Returns
    -------
    tuple of int, str
        Either the input or token or the replacement values
    """
def _replace_booleans(tok: tuple[int, str]) -> tuple[int, str]:
    """
    Replace ``&`` with ``and`` and ``|`` with ``or`` so that bitwise
    precedence is changed to boolean precedence.

    Parameters
    ----------
    tok : tuple of int, str
        ints correspond to the all caps constants in the tokenize module

    Returns
    -------
    tuple of int, str
        Either the input or token or the replacement values
    """
def _replace_locals(tok: tuple[int, str]) -> tuple[int, str]:
    """
    Replace local variables with a syntactically valid name.

    Parameters
    ----------
    tok : tuple of int, str
        ints correspond to the all caps constants in the tokenize module

    Returns
    -------
    tuple of int, str
        Either the input or token or the replacement values

    Notes
    -----
    This is somewhat of a hack in that we rewrite a string such as ``'@a'`` as
    ``'__pd_eval_local_a'`` by telling the tokenizer that ``__pd_eval_local_``
    is a ``tokenize.OP`` and to replace the ``'@'`` symbol with it.
    """
def _compose2(f, g):
    """
    Compose 2 callables.
    """
def _compose(*funcs):
    """
    Compose 2 or more callables.
    """
def _preparse(source: str, f: _Callable = ...) -> str:
    """
    Compose a collection of tokenization functions.

    Parameters
    ----------
    source : str
        A Python source code string
    f : callable
        This takes a tuple of (toknum, tokval) as its argument and returns a
        tuple with the same structure but possibly different elements. Defaults
        to the composition of ``_rewrite_assign``, ``_replace_booleans``, and
        ``_replace_locals``.

    Returns
    -------
    str
        Valid Python source code

    Notes
    -----
    The `f` parameter can be any callable that takes *and* returns input of the
    form ``(toknum, tokval)``, where ``toknum`` is one of the constants from
    the ``tokenize`` module and ``tokval`` is a string.
    """
def _is_type(t):
    """
    Factory for a type checking function of type ``t`` or tuple of types.
    """
def _is_list(x): ...
def _is_str(x): ...

_all_nodes: frozenset
def _filter_nodes(superclass, all_nodes: frozenset = ...):
    """
    Filter out AST nodes that are subclasses of ``superclass``.
    """

_all_node_names: frozenset
_mod_nodes: frozenset
_stmt_nodes: frozenset
_expr_nodes: frozenset
_expr_context_nodes: frozenset
_boolop_nodes: frozenset
_operator_nodes: frozenset
_unary_op_nodes: frozenset
_cmp_op_nodes: frozenset
_comprehension_nodes: frozenset
_handler_nodes: frozenset
_arguments_nodes: frozenset
_keyword_nodes: frozenset
_alias_nodes: frozenset
_hacked_nodes: frozenset
_unsupported_expr_nodes: frozenset
_unsupported_nodes: frozenset
_base_supported_nodes: frozenset
intersection: frozenset
_msg: str
def _node_not_implemented(node_name: str) -> Callable[..., None]:
    """
    Return a function that raises a NotImplementedError with a passed node name.
    """

_T: typing.TypeVar
def disallow(nodes: set[str]) -> Callable[[type[_T]], type[_T]]:
    """
    Decorator to disallow certain nodes from parsing. Raises a
    NotImplementedError instead.

    Returns
    -------
    callable
    """
def _op_maker(op_class, op_symbol):
    """
    Return a function to create an op class with its symbol already passed.

    Returns
    -------
    callable
    """

_op_classes: dict
def add_ops(op_classes):
    """
    Decorator to add default implementation of ops.
    """

class BaseExprVisitor(ast.NodeVisitor):
    const_type: _ClassVar[type[pandas.core.computation.ops.Constant]] = ...
    term_type: _ClassVar[type[pandas.core.computation.ops.Term]] = ...
    binary_ops: _ClassVar[tuple] = ...
    binary_op_nodes: _ClassVar[tuple] = ...
    binary_op_nodes_map: _ClassVar[dict] = ...
    unary_ops: _ClassVar[tuple] = ...
    unary_op_nodes: _ClassVar[tuple] = ...
    unary_op_nodes_map: _ClassVar[dict] = ...
    rewrite_map: _ClassVar[dict] = ...
    unsupported_nodes: _ClassVar[tuple] = ...
    def __init__(self, env, engine, parser, preparser: _Callable = ...) -> None: ...
    def visit(self, node, **kwargs): ...
    def visit_Module(self, node, **kwargs): ...
    def visit_Expr(self, node, **kwargs): ...
    def _rewrite_membership_op(self, node, left, right): ...
    def _maybe_transform_eq_ne(self, node, left, right): ...
    def _maybe_downcast_constants(self, left, right): ...
    def _maybe_eval(self, binop, eval_in_python): ...
    def _maybe_evaluate_binop(self, op, op_class, lhs, rhs, eval_in_python: tuple = ..., maybe_eval_in_python: tuple = ...): ...
    def visit_BinOp(self, node, **kwargs): ...
    def visit_UnaryOp(self, node, **kwargs): ...
    def visit_Name(self, node, **kwargs) -> Term: ...
    def visit_NameConstant(self, node, **kwargs) -> Term: ...
    def visit_Num(self, node, **kwargs) -> Term: ...
    def visit_Constant(self, node, **kwargs) -> Term: ...
    def visit_Str(self, node, **kwargs) -> Term: ...
    def visit_List(self, node, **kwargs) -> Term: ...
    def visit_Tuple(self, node, **kwargs) -> Term: ...
    def visit_Index(self, node, **kwargs):
        """df.index[4]"""
    def visit_Subscript(self, node, **kwargs) -> Term: ...
    def visit_Slice(self, node, **kwargs) -> slice:
        """df.index[slice(4,6)]"""
    def visit_Assign(self, node, **kwargs):
        """
        support a single assignment node, like

        c = a + b

        set the assigner at the top level, must be a Name node which
        might or might not exist in the resolvers

        """
    def visit_Attribute(self, node, **kwargs): ...
    def visit_Call(self, node, side, **kwargs): ...
    def translate_In(self, op): ...
    def visit_Compare(self, node, **kwargs): ...
    def _try_visit_binop(self, bop): ...
    def visit_BoolOp(self, node, **kwargs): ...
    def visit_Gt(self, node, *args, **kwargs):
        """
        Return a partial function with an Op subclass with an operator already passed.

        Returns
        -------
        callable
        """
    def visit_Lt(self, node, *args, **kwargs):
        """
        Return a partial function with an Op subclass with an operator already passed.

        Returns
        -------
        callable
        """
    def visit_GtE(self, node, *args, **kwargs):
        """
        Return a partial function with an Op subclass with an operator already passed.

        Returns
        -------
        callable
        """
    def visit_LtE(self, node, *args, **kwargs):
        """
        Return a partial function with an Op subclass with an operator already passed.

        Returns
        -------
        callable
        """
    def visit_Eq(self, node, *args, **kwargs):
        """
        Return a partial function with an Op subclass with an operator already passed.

        Returns
        -------
        callable
        """
    def visit_NotEq(self, node, *args, **kwargs):
        """
        Return a partial function with an Op subclass with an operator already passed.

        Returns
        -------
        callable
        """
    def visit_In(self, node, *args, **kwargs):
        """
        Return a partial function with an Op subclass with an operator already passed.

        Returns
        -------
        callable
        """
    def visit_NotIn(self, node, *args, **kwargs):
        """
        Return a partial function with an Op subclass with an operator already passed.

        Returns
        -------
        callable
        """
    def visit_BitAnd(self, node, *args, **kwargs):
        """
        Return a partial function with an Op subclass with an operator already passed.

        Returns
        -------
        callable
        """
    def visit_BitOr(self, node, *args, **kwargs):
        """
        Return a partial function with an Op subclass with an operator already passed.

        Returns
        -------
        callable
        """
    def visit_And(self, node, *args, **kwargs):
        """
        Return a partial function with an Op subclass with an operator already passed.

        Returns
        -------
        callable
        """
    def visit_Or(self, node, *args, **kwargs):
        """
        Return a partial function with an Op subclass with an operator already passed.

        Returns
        -------
        callable
        """
    def visit_Add(self, node, *args, **kwargs):
        """
        Return a partial function with an Op subclass with an operator already passed.

        Returns
        -------
        callable
        """
    def visit_Sub(self, node, *args, **kwargs):
        """
        Return a partial function with an Op subclass with an operator already passed.

        Returns
        -------
        callable
        """
    def visit_Mult(self, node, *args, **kwargs):
        """
        Return a partial function with an Op subclass with an operator already passed.

        Returns
        -------
        callable
        """
    def visit_Div(self, node, *args, **kwargs):
        """
        Return a partial function with an Op subclass with an operator already passed.

        Returns
        -------
        callable
        """
    def visit_Pow(self, node, *args, **kwargs):
        """
        Return a partial function with an Op subclass with an operator already passed.

        Returns
        -------
        callable
        """
    def visit_FloorDiv(self, node, *args, **kwargs):
        """
        Return a partial function with an Op subclass with an operator already passed.

        Returns
        -------
        callable
        """
    def visit_Mod(self, node, *args, **kwargs):
        """
        Return a partial function with an Op subclass with an operator already passed.

        Returns
        -------
        callable
        """
    def visit_UAdd(self, node, *args, **kwargs):
        """
        Return a partial function with an Op subclass with an operator already passed.

        Returns
        -------
        callable
        """
    def visit_USub(self, node, *args, **kwargs):
        """
        Return a partial function with an Op subclass with an operator already passed.

        Returns
        -------
        callable
        """
    def visit_Invert(self, node, *args, **kwargs):
        """
        Return a partial function with an Op subclass with an operator already passed.

        Returns
        -------
        callable
        """
    def visit_Not(self, node, *args, **kwargs):
        """
        Return a partial function with an Op subclass with an operator already passed.

        Returns
        -------
        callable
        """
    def visit_expr_context(self, *args, **kwargs): ...
    def visit_AsyncFunctionDef(self, *args, **kwargs): ...
    def visit_If(self, *args, **kwargs): ...
    def visit_ClassDef(self, *args, **kwargs): ...
    def visit_Store(self, *args, **kwargs): ...
    def visit_AugLoad(self, *args, **kwargs): ...
    def visit_stmt(self, *args, **kwargs): ...
    def visit_keyword(self, *args, **kwargs): ...
    def visit_For(self, *args, **kwargs): ...
    def visit_Suite(self, *args, **kwargs): ...
    def visit_AugStore(self, *args, **kwargs): ...
    def visit_Yield(self, *args, **kwargs): ...
    def visit_With(self, *args, **kwargs): ...
    def visit_AST(self, *args, **kwargs): ...
    def visit_Continue(self, *args, **kwargs): ...
    def visit_Pass(self, *args, **kwargs): ...
    def visit_TypeAlias(self, *args, **kwargs): ...
    def visit_AsyncWith(self, *args, **kwargs): ...
    def visit_ExceptHandler(self, *args, **kwargs): ...
    def visit_alias(self, *args, **kwargs): ...
    def visit_Break(self, *args, **kwargs): ...
    def visit_Return(self, *args, **kwargs): ...
    def visit_Expression(self, *args, **kwargs): ...
    def visit_FunctionType(self, *args, **kwargs): ...
    def visit_While(self, *args, **kwargs): ...
    def visit_FunctionDef(self, *args, **kwargs): ...
    def visit_Is(self, *args, **kwargs): ...
    def visit_excepthandler(self, *args, **kwargs): ...
    def visit_GeneratorExp(self, *args, **kwargs): ...
    def visit_Load(self, *args, **kwargs): ...
    def visit_ImportFrom(self, *args, **kwargs): ...
    def visit_SetComp(self, *args, **kwargs): ...
    def visit_Assert(self, *args, **kwargs): ...
    def visit_IsNot(self, *args, **kwargs): ...
    def visit_TryStar(self, *args, **kwargs): ...
    def visit_arguments(self, *args, **kwargs): ...
    def visit_Param(self, *args, **kwargs): ...
    def visit_Set(self, *args, **kwargs): ...
    def visit_Global(self, *args, **kwargs): ...
    def visit_IfExp(self, *args, **kwargs): ...
    def visit_Match(self, *args, **kwargs): ...
    def visit_Raise(self, *args, **kwargs): ...
    def visit_Try(self, *args, **kwargs): ...
    def visit_Lambda(self, *args, **kwargs): ...
    def visit_mod(self, *args, **kwargs): ...
    def visit_AnnAssign(self, *args, **kwargs): ...
    def visit_Delete(self, *args, **kwargs): ...
    def visit_Import(self, *args, **kwargs): ...
    def visit_Interactive(self, *args, **kwargs): ...
    def visit_Nonlocal(self, *args, **kwargs): ...
    def visit_AugAssign(self, *args, **kwargs): ...
    def visit_DictComp(self, *args, **kwargs): ...
    def visit_Repr(self, *args, **kwargs): ...
    def visit_AsyncFor(self, *args, **kwargs): ...
    def visit_Del(self, *args, **kwargs): ...
_python_not_supported: frozenset
_numexpr_supported_calls: frozenset

class PandasExprVisitor(BaseExprVisitor):
    unsupported_nodes: _ClassVar[tuple] = ...
    def __init__(self, env, engine, parser, preparser: functools.partial = ...) -> None: ...
    def visit_expr_context(self, *args, **kwargs): ...
    def visit_AsyncFunctionDef(self, *args, **kwargs): ...
    def visit_If(self, *args, **kwargs): ...
    def visit_ClassDef(self, *args, **kwargs): ...
    def visit_Store(self, *args, **kwargs): ...
    def visit_AugLoad(self, *args, **kwargs): ...
    def visit_stmt(self, *args, **kwargs): ...
    def visit_keyword(self, *args, **kwargs): ...
    def visit_For(self, *args, **kwargs): ...
    def visit_Suite(self, *args, **kwargs): ...
    def visit_AugStore(self, *args, **kwargs): ...
    def visit_Yield(self, *args, **kwargs): ...
    def visit_With(self, *args, **kwargs): ...
    def visit_Dict(self, *args, **kwargs): ...
    def visit_AST(self, *args, **kwargs): ...
    def visit_Continue(self, *args, **kwargs): ...
    def visit_Pass(self, *args, **kwargs): ...
    def visit_TypeAlias(self, *args, **kwargs): ...
    def visit_AsyncWith(self, *args, **kwargs): ...
    def visit_ExceptHandler(self, *args, **kwargs): ...
    def visit_alias(self, *args, **kwargs): ...
    def visit_Break(self, *args, **kwargs): ...
    def visit_Return(self, *args, **kwargs): ...
    def visit_Expression(self, *args, **kwargs): ...
    def visit_FunctionType(self, *args, **kwargs): ...
    def visit_While(self, *args, **kwargs): ...
    def visit_FunctionDef(self, *args, **kwargs): ...
    def visit_Is(self, *args, **kwargs): ...
    def visit_excepthandler(self, *args, **kwargs): ...
    def visit_GeneratorExp(self, *args, **kwargs): ...
    def visit_Load(self, *args, **kwargs): ...
    def visit_ImportFrom(self, *args, **kwargs): ...
    def visit_SetComp(self, *args, **kwargs): ...
    def visit_Assert(self, *args, **kwargs): ...
    def visit_IsNot(self, *args, **kwargs): ...
    def visit_TryStar(self, *args, **kwargs): ...
    def visit_arguments(self, *args, **kwargs): ...
    def visit_Param(self, *args, **kwargs): ...
    def visit_Set(self, *args, **kwargs): ...
    def visit_Global(self, *args, **kwargs): ...
    def visit_IfExp(self, *args, **kwargs): ...
    def visit_Match(self, *args, **kwargs): ...
    def visit_Raise(self, *args, **kwargs): ...
    def visit_Try(self, *args, **kwargs): ...
    def visit_Lambda(self, *args, **kwargs): ...
    def visit_mod(self, *args, **kwargs): ...
    def visit_AnnAssign(self, *args, **kwargs): ...
    def visit_Delete(self, *args, **kwargs): ...
    def visit_Import(self, *args, **kwargs): ...
    def visit_Interactive(self, *args, **kwargs): ...
    def visit_Nonlocal(self, *args, **kwargs): ...
    def visit_AugAssign(self, *args, **kwargs): ...
    def visit_DictComp(self, *args, **kwargs): ...
    def visit_Repr(self, *args, **kwargs): ...
    def visit_AsyncFor(self, *args, **kwargs): ...
    def visit_Del(self, *args, **kwargs): ...

class PythonExprVisitor(BaseExprVisitor):
    unsupported_nodes: _ClassVar[tuple] = ...
    def __init__(self, env, engine, parser, preparser: _Callable = ...) -> None: ...
    def visit_expr_context(self, *args, **kwargs): ...
    def visit_AsyncFunctionDef(self, *args, **kwargs): ...
    def visit_If(self, *args, **kwargs): ...
    def visit_ClassDef(self, *args, **kwargs): ...
    def visit_Store(self, *args, **kwargs): ...
    def visit_BoolOp(self, *args, **kwargs): ...
    def visit_AugLoad(self, *args, **kwargs): ...
    def visit_stmt(self, *args, **kwargs): ...
    def visit_keyword(self, *args, **kwargs): ...
    def visit_For(self, *args, **kwargs): ...
    def visit_Suite(self, *args, **kwargs): ...
    def visit_AugStore(self, *args, **kwargs): ...
    def visit_Yield(self, *args, **kwargs): ...
    def visit_With(self, *args, **kwargs): ...
    def visit_Dict(self, *args, **kwargs): ...
    def visit_AST(self, *args, **kwargs): ...
    def visit_Continue(self, *args, **kwargs): ...
    def visit_Pass(self, *args, **kwargs): ...
    def visit_TypeAlias(self, *args, **kwargs): ...
    def visit_AsyncWith(self, *args, **kwargs): ...
    def visit_ExceptHandler(self, *args, **kwargs): ...
    def visit_alias(self, *args, **kwargs): ...
    def visit_Break(self, *args, **kwargs): ...
    def visit_Not(self, *args, **kwargs): ...
    def visit_Return(self, *args, **kwargs): ...
    def visit_Expression(self, *args, **kwargs): ...
    def visit_FunctionType(self, *args, **kwargs): ...
    def visit_While(self, *args, **kwargs): ...
    def visit_FunctionDef(self, *args, **kwargs): ...
    def visit_Is(self, *args, **kwargs): ...
    def visit_In(self, *args, **kwargs): ...
    def visit_excepthandler(self, *args, **kwargs): ...
    def visit_GeneratorExp(self, *args, **kwargs): ...
    def visit_Load(self, *args, **kwargs): ...
    def visit_ImportFrom(self, *args, **kwargs): ...
    def visit_SetComp(self, *args, **kwargs): ...
    def visit_Assert(self, *args, **kwargs): ...
    def visit_IsNot(self, *args, **kwargs): ...
    def visit_TryStar(self, *args, **kwargs): ...
    def visit_arguments(self, *args, **kwargs): ...
    def visit_Param(self, *args, **kwargs): ...
    def visit_Set(self, *args, **kwargs): ...
    def visit_Global(self, *args, **kwargs): ...
    def visit_IfExp(self, *args, **kwargs): ...
    def visit_Match(self, *args, **kwargs): ...
    def visit_Raise(self, *args, **kwargs): ...
    def visit_Try(self, *args, **kwargs): ...
    def visit_Lambda(self, *args, **kwargs): ...
    def visit_mod(self, *args, **kwargs): ...
    def visit_AnnAssign(self, *args, **kwargs): ...
    def visit_Delete(self, *args, **kwargs): ...
    def visit_Import(self, *args, **kwargs): ...
    def visit_Interactive(self, *args, **kwargs): ...
    def visit_Nonlocal(self, *args, **kwargs): ...
    def visit_AugAssign(self, *args, **kwargs): ...
    def visit_DictComp(self, *args, **kwargs): ...
    def visit_Repr(self, *args, **kwargs): ...
    def visit_NotIn(self, *args, **kwargs): ...
    def visit_AsyncFor(self, *args, **kwargs): ...
    def visit_Del(self, *args, **kwargs): ...

class Expr:
    def __init__(self, expr, engine: str = ..., parser: str = ..., env: Scope | None, level: int = ...) -> None: ...
    def __call__(self): ...
    def __len__(self) -> int: ...
    def parse(self):
        """
        Parse an expression.
        """
    @property
    def assigner(self): ...
    @property
    def names(self): ...
PARSERS: dict
