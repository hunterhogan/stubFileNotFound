from collections.abc import Sequence
from typing import overload

import numpy as np
from pandas.core.arrays.base import (
    ExtensionArray,
    ExtensionOpsMixin,
)
from typing_extensions import (
    Self,
    TypeAlias,
)

from pandas._libs import (
    NaT as NaT,
    NaTType as NaTType,
)
from pandas._typing import (
    DatetimeLikeScalar,
    PositionalIndexerTuple,
    ScalarIndexer,
    SequenceIndexer,
    TimeAmbiguous,
    TimeNonexistent,
    TimeUnit,
)
from typing import Any

DTScalarOrNaT: TypeAlias = DatetimeLikeScalar | NaTType

class DatelikeOps:
    def strftime(self, date_format: Any): ...

class TimelikeOps:
    @property
    def unit(self) -> TimeUnit: ...
    def as_unit(self, unit: TimeUnit) -> Self: ...
    def round(
        self, freq: Any, ambiguous: TimeAmbiguous = 'raise', nonexistent: TimeNonexistent = 'raise'
    ): ...
    def floor(
        self, freq: Any, ambiguous: TimeAmbiguous = 'raise', nonexistent: TimeNonexistent = 'raise'
    ): ...
    def ceil(
        self, freq: Any, ambiguous: TimeAmbiguous = 'raise', nonexistent: TimeNonexistent = 'raise'
    ): ...

class DatetimeLikeArrayMixin(ExtensionOpsMixin, ExtensionArray):
    @property
    def ndim(self) -> int: ...
    @property
    def shape(self): ...
    def reshape(self, *args, **kwargs): ...
    def ravel(self, *args, **kwargs): ...  # pyrefly: ignore
    def __iter__(self): ...
    @property
    def asi8(self) -> np.ndarray[Any, Any]: ...
    @property
    def nbytes(self): ...
    def __array__(self, dtype: Any=None) -> np.ndarray[Any, Any]: ...
    @property
    def size(self) -> int: ...
    def __len__(self) -> int: ...
    @overload
    def __getitem__(self, key: ScalarIndexer) -> DTScalarOrNaT: ...
    @overload
    def __getitem__(
        self,
        key: SequenceIndexer | PositionalIndexerTuple,
    ) -> Self: ...
    def __setitem__(  # type: ignore[override] # pyright: ignore[reportIncompatibleMethodOverride]
        self, key: int | Sequence[int] | Sequence[bool] | slice, value: Any
    ) -> None: ...
    def astype(self, dtype: Any, copy: bool = True): ...
    def view(self, dtype: Any=None): ...
    def unique(self): ...
    def copy(self): ...
    def shift(self, periods: int = 1, fill_value: Any=None, axis: int = ...): ...
    def searchsorted(self, value: Any, side: str = 'left', sorter: Any=None): ...
    def repeat(self, repeats: Any, *args, **kwargs): ...  # pyrefly: ignore
    def value_counts(self, dropna: bool = True): ...
    def map(self, mapper: Any): ...
    def isna(self): ...
    def fillna(self, value: Any=None, method: Any=None, limit: Any=None): ...
    @property
    def freq(self): ...
    @freq.setter
    def freq(self, value: Any) -> None: ...
    @property
    def freqstr(self): ...
    @property
    def inferred_freq(self): ...
    @property
    def resolution(self): ...
    __pow__ = ...
    __rpow__ = ...
    __rmul__ = ...
    def __add__(self, other: Any): ...
    def __radd__(self, other: Any): ...
    def __sub__(self, other: Any): ...
    def __rsub__(self, other: Any): ...
    def __iadd__(self, other: Any): ...
    def __isub__(self, other: Any): ...
    def min(self, *, axis=None, skipna: bool = True, **kwargs): ...
    def max(self, *, axis=None, skipna: bool = True, **kwargs): ...
    def mean(self, *, skipna: bool = True): ...
