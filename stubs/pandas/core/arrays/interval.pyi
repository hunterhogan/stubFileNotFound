from typing import overload

import numpy as np
from pandas import (
    Index,
    Series,
)
from pandas.core.arrays.base import ExtensionArray as ExtensionArray
from typing_extensions import (
    Self,
    TypeAlias,
)

from pandas._libs.interval import (
    Interval as Interval,
    IntervalMixin as IntervalMixin,
)
from pandas._typing import (
    Axis,
    Scalar,
    ScalarIndexer,
    SequenceIndexer,
    TakeIndexer,
    np_ndarray_bool,
)
from typing import Any

IntervalOrNA: TypeAlias = Interval | float

class IntervalArray(IntervalMixin, ExtensionArray):
    can_hold_na: bool = ...
    def __new__(
        cls, data: Any, closed: Any=None, dtype: Any=None, copy: bool = False, verify_integrity: bool = True
    ): ...
    @classmethod
    def from_breaks(cls, breaks: Any, closed: str = 'right', copy: bool = False, dtype: Any=None): ...
    @classmethod
    def from_arrays(
        cls, left: Any, right: Any, closed: str = 'right', copy: bool = False, dtype: Any=None
    ): ...
    @classmethod
    def from_tuples(cls, data: Any, closed: str = 'right', copy: bool = False, dtype: Any=None): ...
    def __iter__(self): ...
    def __len__(self) -> int: ...
    @overload
    def __getitem__(self, key: ScalarIndexer) -> IntervalOrNA: ...
    @overload
    def __getitem__(self, key: SequenceIndexer) -> Self: ...
    def __setitem__(self, key: Any, value: Any) -> None: ...
    def __eq__(self, other: Any): ...
    def __ne__(self, other: Any): ...
    def fillna(self, value: Any=None, method: Any=None, limit: Any=None): ...
    @property
    def dtype(self): ...
    def astype(self, dtype: Any, copy: bool = True): ...
    def copy(self): ...
    def isna(self): ...
    @property
    def nbytes(self) -> int: ...
    @property
    def size(self) -> int: ...
    def shift(self, periods: int = 1, fill_value: object = None) -> IntervalArray: ...
    def take(  # type: ignore[override] # pyright: ignore[reportIncompatibleMethodOverride]
        self: Self,
        indices: TakeIndexer,
        *,
        allow_fill: bool = False,
        fill_value=None,
        axis=None,
        **kwargs,
    ) -> Self: ...
    def value_counts(self, dropna: bool = True): ...
    @property
    def left(self) -> Index: ...
    @property
    def right(self) -> Index: ...
    @property
    def closed(self) -> bool: ...
    def set_closed(self, closed: Any): ...
    @property
    def length(self) -> Index: ...
    @property
    def mid(self) -> Index: ...
    @property
    def is_non_overlapping_monotonic(self) -> bool: ...
    def __array__(self, dtype: Any=None) -> np.ndarray: ...
    def __arrow_array__(self, type: Any=None): ...
    def to_tuples(self, na_tuple: bool = True): ...
    def repeat(self, repeats: Any, axis: Axis | None = None): ...
    @overload
    def contains(self, other: Series) -> Series[bool]: ...
    @overload
    def contains(
        self, other: Scalar | ExtensionArray | Index | np.ndarray
    ) -> np_ndarray_bool: ...
    def overlaps(self, other: Interval) -> bool: ...
