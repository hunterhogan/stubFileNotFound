import _abc
import np
import npt
import pandas._libs.lib as lib
import pandas.compat.numpy.function as nv
import pandas.core.arraylike
import pandas.core.arraylike as arraylike
import pandas.core.arrays._mixins
import pandas.core.missing as missing
import pandas.core.nanops as nanops
import pandas.core.ops as ops
import pandas.core.strings.object_array
from pandas._libs.tslibs.np_datetime import is_supported_dtype as is_supported_dtype
from pandas.core.arraylike import OpsMixin as OpsMixin
from pandas.core.arrays._mixins import NDArrayBackedExtensionArray as NDArrayBackedExtensionArray
from pandas.core.construction import ensure_wrapped_if_datetimelike as ensure_wrapped_if_datetimelike
from pandas.core.dtypes.astype import astype_array as astype_array
from pandas.core.dtypes.cast import construct_1d_object_array_from_listlike as construct_1d_object_array_from_listlike
from pandas.core.dtypes.common import pandas_dtype as pandas_dtype
from pandas.core.dtypes.dtypes import NumpyEADtype as NumpyEADtype
from pandas.core.dtypes.missing import isna as isna
from pandas.core.strings.object_array import ObjectStringArrayMixin as ObjectStringArrayMixin
from typing import ClassVar, Literal

TYPE_CHECKING: bool

class NumpyExtensionArray(pandas.core.arraylike.OpsMixin, pandas.core.arrays._mixins.NDArrayBackedExtensionArray, pandas.core.strings.object_array.ObjectStringArrayMixin):
    _typ: ClassVar[str] = ...
    __array_priority__: ClassVar[int] = ...
    _internal_fill_value: ClassVar[float] = ...
    _str_na_value: ClassVar[float] = ...
    __abstractmethods__: ClassVar[frozenset] = ...
    _abc_impl: ClassVar[_abc._abc_data] = ...
    def __init__(self, values: np.ndarray | NumpyExtensionArray, copy: bool = ...) -> None: ...
    @classmethod
    def _from_sequence(cls, scalars, *, dtype: Dtype | None, copy: bool = ...) -> NumpyExtensionArray: ...
    def _from_backing_data(self, arr: np.ndarray) -> NumpyExtensionArray: ...
    def __array__(self, dtype: NpDtype | None, copy: bool | None) -> np.ndarray: ...
    def __array_ufunc__(self, ufunc: np.ufunc, method: str, *inputs, **kwargs): ...
    def astype(self, dtype, copy: bool = ...): ...
    def isna(self) -> np.ndarray: ...
    def _validate_scalar(self, fill_value): ...
    def _values_for_factorize(self) -> tuple[np.ndarray, float | None]: ...
    def _pad_or_backfill(self, *, method: FillnaOptions, limit: int | None, limit_area: Literal['inside', 'outside'] | None, copy: bool = ...) -> Self:
        """
        ffill or bfill along axis=0.
        """
    def interpolate(self, *, method: InterpolateOptions, axis: int, index: Index, limit, limit_direction, limit_area, copy: bool, **kwargs) -> Self:
        """
        See NDFrame.interpolate.__doc__.
        """
    def any(self, *, axis: AxisInt | None, out, keepdims: bool = ..., skipna: bool = ...): ...
    def all(self, *, axis: AxisInt | None, out, keepdims: bool = ..., skipna: bool = ...): ...
    def min(self, *, axis: AxisInt | None, skipna: bool = ..., **kwargs) -> Scalar: ...
    def max(self, *, axis: AxisInt | None, skipna: bool = ..., **kwargs) -> Scalar: ...
    def sum(self, *, axis: AxisInt | None, skipna: bool = ..., min_count: int = ..., **kwargs) -> Scalar: ...
    def prod(self, *, axis: AxisInt | None, skipna: bool = ..., min_count: int = ..., **kwargs) -> Scalar: ...
    def mean(self, *, axis: AxisInt | None, dtype: NpDtype | None, out, keepdims: bool = ..., skipna: bool = ...): ...
    def median(self, *, axis: AxisInt | None, out, overwrite_input: bool = ..., keepdims: bool = ..., skipna: bool = ...): ...
    def std(self, *, axis: AxisInt | None, dtype: NpDtype | None, out, ddof: int = ..., keepdims: bool = ..., skipna: bool = ...): ...
    def var(self, *, axis: AxisInt | None, dtype: NpDtype | None, out, ddof: int = ..., keepdims: bool = ..., skipna: bool = ...): ...
    def sem(self, *, axis: AxisInt | None, dtype: NpDtype | None, out, ddof: int = ..., keepdims: bool = ..., skipna: bool = ...): ...
    def kurt(self, *, axis: AxisInt | None, dtype: NpDtype | None, out, keepdims: bool = ..., skipna: bool = ...): ...
    def skew(self, *, axis: AxisInt | None, dtype: NpDtype | None, out, keepdims: bool = ..., skipna: bool = ...): ...
    def to_numpy(self, dtype: npt.DTypeLike | None, copy: bool = ..., na_value: object = ...) -> np.ndarray: ...
    def __invert__(self) -> NumpyExtensionArray: ...
    def __neg__(self) -> NumpyExtensionArray: ...
    def __pos__(self) -> NumpyExtensionArray: ...
    def __abs__(self) -> NumpyExtensionArray: ...
    def _cmp_method(self, other, op): ...
    def _arith_method(self, other, op): ...
    def _wrap_ndarray_result(self, result: np.ndarray): ...
    @property
    def dtype(self): ...
