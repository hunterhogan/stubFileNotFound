import numpy as np
from _typeshed import Incomplete
from pandas import Index as Index
from pandas._typing import AxisInt as AxisInt, Dtype as Dtype, FillnaOptions as FillnaOptions, InterpolateOptions as InterpolateOptions, NpDtype as NpDtype, Scalar as Scalar, Self as Self, npt as npt
from pandas.core import arraylike as arraylike, missing as missing, nanops as nanops, ops as ops
from pandas.core.arraylike import OpsMixin as OpsMixin
from pandas.core.arrays._mixins import NDArrayBackedExtensionArray as NDArrayBackedExtensionArray
from pandas.core.dtypes.dtypes import NumpyEADtype as NumpyEADtype
from pandas.core.strings.object_array import ObjectStringArrayMixin as ObjectStringArrayMixin
from typing import Literal

class NumpyExtensionArray(OpsMixin, NDArrayBackedExtensionArray, ObjectStringArrayMixin):
    """
    A pandas ExtensionArray for NumPy data.

    This is mostly for internal compatibility, and is not especially
    useful on its own.

    Parameters
    ----------
    values : ndarray
        The NumPy ndarray to wrap. Must be 1-dimensional.
    copy : bool, default False
        Whether to copy `values`.

    Attributes
    ----------
    None

    Methods
    -------
    None

    Examples
    --------
    >>> pd.arrays.NumpyExtensionArray(np.array([0, 1, 2, 3]))
    <NumpyExtensionArray>
    [0, 1, 2, 3]
    Length: 4, dtype: int64
    """
    _typ: str
    __array_priority__: int
    _ndarray: np.ndarray
    _dtype: NumpyEADtype
    _internal_fill_value: Incomplete
    def __init__(self, values: np.ndarray | NumpyExtensionArray, copy: bool = False) -> None: ...
    @classmethod
    def _from_sequence(cls, scalars, *, dtype: Dtype | None = None, copy: bool = False) -> NumpyExtensionArray: ...
    def _from_backing_data(self, arr: np.ndarray) -> NumpyExtensionArray: ...
    @property
    def dtype(self) -> NumpyEADtype: ...
    def __array__(self, dtype: NpDtype | None = None, copy: bool | None = None) -> np.ndarray: ...
    def __array_ufunc__(self, ufunc: np.ufunc, method: str, *inputs, **kwargs): ...
    def astype(self, dtype, copy: bool = True): ...
    def isna(self) -> np.ndarray: ...
    def _validate_scalar(self, fill_value): ...
    def _values_for_factorize(self) -> tuple[np.ndarray, float | None]: ...
    def _pad_or_backfill(self, *, method: FillnaOptions, limit: int | None = None, limit_area: Literal['inside', 'outside'] | None = None, copy: bool = True) -> Self:
        """
        ffill or bfill along axis=0.
        """
    def interpolate(self, *, method: InterpolateOptions, axis: int, index: Index, limit, limit_direction, limit_area, copy: bool, **kwargs) -> Self:
        """
        See NDFrame.interpolate.__doc__.
        """
    def any(self, *, axis: AxisInt | None = None, out: Incomplete | None = None, keepdims: bool = False, skipna: bool = True): ...
    def all(self, *, axis: AxisInt | None = None, out: Incomplete | None = None, keepdims: bool = False, skipna: bool = True): ...
    def min(self, *, axis: AxisInt | None = None, skipna: bool = True, **kwargs) -> Scalar: ...
    def max(self, *, axis: AxisInt | None = None, skipna: bool = True, **kwargs) -> Scalar: ...
    def sum(self, *, axis: AxisInt | None = None, skipna: bool = True, min_count: int = 0, **kwargs) -> Scalar: ...
    def prod(self, *, axis: AxisInt | None = None, skipna: bool = True, min_count: int = 0, **kwargs) -> Scalar: ...
    def mean(self, *, axis: AxisInt | None = None, dtype: NpDtype | None = None, out: Incomplete | None = None, keepdims: bool = False, skipna: bool = True): ...
    def median(self, *, axis: AxisInt | None = None, out: Incomplete | None = None, overwrite_input: bool = False, keepdims: bool = False, skipna: bool = True): ...
    def std(self, *, axis: AxisInt | None = None, dtype: NpDtype | None = None, out: Incomplete | None = None, ddof: int = 1, keepdims: bool = False, skipna: bool = True): ...
    def var(self, *, axis: AxisInt | None = None, dtype: NpDtype | None = None, out: Incomplete | None = None, ddof: int = 1, keepdims: bool = False, skipna: bool = True): ...
    def sem(self, *, axis: AxisInt | None = None, dtype: NpDtype | None = None, out: Incomplete | None = None, ddof: int = 1, keepdims: bool = False, skipna: bool = True): ...
    def kurt(self, *, axis: AxisInt | None = None, dtype: NpDtype | None = None, out: Incomplete | None = None, keepdims: bool = False, skipna: bool = True): ...
    def skew(self, *, axis: AxisInt | None = None, dtype: NpDtype | None = None, out: Incomplete | None = None, keepdims: bool = False, skipna: bool = True): ...
    def to_numpy(self, dtype: npt.DTypeLike | None = None, copy: bool = False, na_value: object = ...) -> np.ndarray: ...
    def __invert__(self) -> NumpyExtensionArray: ...
    def __neg__(self) -> NumpyExtensionArray: ...
    def __pos__(self) -> NumpyExtensionArray: ...
    def __abs__(self) -> NumpyExtensionArray: ...
    def _cmp_method(self, other, op): ...
    _arith_method = _cmp_method
    def _wrap_ndarray_result(self, result: np.ndarray): ...
    _str_na_value: Incomplete
