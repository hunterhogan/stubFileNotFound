import _abc
import np
import npt
import pa
import pandas._libs.lib as lib
import pandas._libs.missing
import pandas._libs.missing as libmissing
import pandas.core.arrays.arrow.array
import pandas.core.arrays.string_
import pandas.core.strings.object_array
import re
from pandas._libs.lib import is_scalar as is_scalar
from pandas.core.arrays._arrow_string_mixins import ArrowStringArrayMixin as ArrowStringArrayMixin
from pandas.core.arrays.arrow.array import ArrowExtensionArray as ArrowExtensionArray
from pandas.core.arrays.boolean import BooleanDtype as BooleanDtype
from pandas.core.arrays.integer import Int64Dtype as Int64Dtype
from pandas.core.arrays.numeric import NumericDtype as NumericDtype
from pandas.core.arrays.string_ import BaseStringArray as BaseStringArray, StringDtype as StringDtype
from pandas.core.dtypes.common import is_bool_dtype as is_bool_dtype, is_integer_dtype as is_integer_dtype, is_object_dtype as is_object_dtype, is_string_dtype as is_string_dtype, pandas_dtype as pandas_dtype
from pandas.core.dtypes.missing import isna as isna
from pandas.core.ops.invalid import invalid_comparison as invalid_comparison
from pandas.core.strings.object_array import ObjectStringArrayMixin as ObjectStringArrayMixin
from pandas.util._exceptions import find_stack_level as find_stack_level
from typing import Callable, ClassVar

TYPE_CHECKING: bool
pa_version_under10p1: bool
pa_version_under13p0: bool
def _chk_pyarrow_available() -> None: ...

class ArrowStringArray(pandas.core.strings.object_array.ObjectStringArrayMixin, pandas.core.arrays.arrow.array.ArrowExtensionArray, pandas.core.arrays.string_.BaseStringArray):
    _storage: ClassVar[str] = ...
    _str_na_value: ClassVar[pandas._libs.missing.NAType] = ...
    __abstractmethods__: ClassVar[frozenset] = ...
    _abc_impl: ClassVar[_abc._abc_data] = ...
    def __init__(self, values) -> None: ...
    @classmethod
    def _box_pa_scalar(cls, value, pa_type: pa.DataType | None) -> pa.Scalar: ...
    @classmethod
    def _box_pa_array(cls, value, pa_type: pa.DataType | None, copy: bool = ...) -> pa.Array | pa.ChunkedArray: ...
    def __len__(self) -> int:
        """
        Length of this array.

        Returns
        -------
        length : int
        """
    @classmethod
    def _from_sequence(cls, scalars, *, dtype: Dtype | None, copy: bool = ...): ...
    @classmethod
    def _from_sequence_of_strings(cls, strings, dtype: Dtype | None, copy: bool = ...): ...
    def insert(self, loc: int, item) -> ArrowStringArray: ...
    @classmethod
    def _result_converter(cls, values, na): ...
    def _maybe_convert_setitem_value(self, value):
        """Maybe convert value to be pyarrow compatible."""
    def isin(self, values: ArrayLike) -> npt.NDArray[np.bool_]: ...
    def astype(self, dtype, copy: bool = ...): ...
    def _str_map(self, f, na_value, dtype: Dtype | None, convert: bool = ...): ...
    def _str_contains(self, pat, case: bool = ..., flags: int = ..., na: float = ..., regex: bool = ...): ...
    def _str_startswith(self, pat: str | tuple[str, ...], na: Scalar | None): ...
    def _str_endswith(self, pat: str | tuple[str, ...], na: Scalar | None): ...
    def _str_replace(self, pat: str | re.Pattern, repl: str | Callable, n: int = ..., case: bool = ..., flags: int = ..., regex: bool = ...): ...
    def _str_repeat(self, repeats: int | Sequence[int]): ...
    def _str_match(self, pat: str, case: bool = ..., flags: int = ..., na: Scalar | None): ...
    def _str_fullmatch(self, pat, case: bool = ..., flags: int = ..., na: Scalar | None): ...
    def _str_slice(self, start: int | None, stop: int | None, step: int | None): ...
    def _str_isalnum(self): ...
    def _str_isalpha(self): ...
    def _str_isdecimal(self): ...
    def _str_isdigit(self): ...
    def _str_islower(self): ...
    def _str_isnumeric(self): ...
    def _str_isspace(self): ...
    def _str_istitle(self): ...
    def _str_isupper(self): ...
    def _str_len(self): ...
    def _str_lower(self): ...
    def _str_upper(self): ...
    def _str_strip(self, to_strip): ...
    def _str_lstrip(self, to_strip): ...
    def _str_rstrip(self, to_strip): ...
    def _str_removeprefix(self, prefix: str): ...
    def _str_removesuffix(self, suffix: str): ...
    def _str_count(self, pat: str, flags: int = ...): ...
    def _str_find(self, sub: str, start: int = ..., end: int | None): ...
    def _str_get_dummies(self, sep: str = ...): ...
    def _convert_int_dtype(self, result): ...
    def _reduce(self, name: str, *, skipna: bool = ..., keepdims: bool = ..., **kwargs): ...
    def _rank(self, *, axis: AxisInt = ..., method: str = ..., na_option: str = ..., ascending: bool = ..., pct: bool = ...):
        """
        See Series.rank.__doc__.
        """
    @property
    def dtype(self): ...
    @property
    def _data(self): ...

class ArrowStringArrayNumpySemantics(ArrowStringArray):
    _storage: ClassVar[str] = ...
    __abstractmethods__: ClassVar[frozenset] = ...
    _abc_impl: ClassVar[_abc._abc_data] = ...
    @classmethod
    def _result_converter(cls, values, na): ...
    def _str_map(self, f, na_value, dtype: Dtype | None, convert: bool = ...): ...
    def _convert_int_dtype(self, result): ...
    def _cmp_method(self, other, op): ...
    def value_counts(self, dropna: bool = ...) -> Series: ...
    def _reduce(self, name: str, *, skipna: bool = ..., keepdims: bool = ..., **kwargs): ...
    def insert(self, loc: int, item) -> ArrowStringArrayNumpySemantics: ...
