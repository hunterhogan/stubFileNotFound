import numpy as np
import pyarrow as pa
import re
from _typeshed import Incomplete
from collections.abc import Sequence
from pandas import Series as Series
from pandas._libs import lib as lib
from pandas._typing import ArrayLike as ArrayLike, AxisInt as AxisInt, Dtype as Dtype, Scalar as Scalar, npt as npt
from pandas.compat import pa_version_under10p1 as pa_version_under10p1, pa_version_under13p0 as pa_version_under13p0
from pandas.core.arrays._arrow_string_mixins import ArrowStringArrayMixin as ArrowStringArrayMixin
from pandas.core.arrays.arrow import ArrowExtensionArray as ArrowExtensionArray
from pandas.core.arrays.arrow._arrow_utils import fallback_performancewarning as fallback_performancewarning
from pandas.core.arrays.boolean import BooleanDtype as BooleanDtype
from pandas.core.arrays.integer import Int64Dtype as Int64Dtype
from pandas.core.arrays.numeric import NumericDtype as NumericDtype
from pandas.core.arrays.string_ import BaseStringArray as BaseStringArray, StringDtype as StringDtype
from pandas.core.dtypes.common import is_bool_dtype as is_bool_dtype, is_integer_dtype as is_integer_dtype, is_object_dtype as is_object_dtype, is_scalar as is_scalar, is_string_dtype as is_string_dtype, pandas_dtype as pandas_dtype
from pandas.core.dtypes.missing import isna as isna
from pandas.core.ops import invalid_comparison as invalid_comparison
from pandas.core.strings.object_array import ObjectStringArrayMixin as ObjectStringArrayMixin
from pandas.util._exceptions import find_stack_level as find_stack_level
from collections.abc import Callable

ArrowStringScalarOrNAT: Incomplete

def _chk_pyarrow_available() -> None: ...

class ArrowStringArray(ObjectStringArrayMixin, ArrowExtensionArray, BaseStringArray):
    '''
    Extension array for string data in a ``pyarrow.ChunkedArray``.

    .. warning::

       ArrowStringArray is considered experimental. The implementation and
       parts of the API may change without warning.

    Parameters
    ----------
    values : pyarrow.Array or pyarrow.ChunkedArray
        The array of data.

    Attributes
    ----------
    None

    Methods
    -------
    None

    See Also
    --------
    :func:`pandas.array`
        The recommended function for creating a ArrowStringArray.
    Series.str
        The string methods are available on Series backed by
        a ArrowStringArray.

    Notes
    -----
    ArrowStringArray returns a BooleanArray for comparison methods.

    Examples
    --------
    >>> pd.array([\'This is\', \'some text\', None, \'data.\'], dtype="string[pyarrow]")
    <ArrowStringArray>
    [\'This is\', \'some text\', <NA>, \'data.\']
    Length: 4, dtype: string
    '''
    _dtype: StringDtype
    _storage: str
    def __init__(self, values) -> None: ...
    @classmethod
    def _box_pa_scalar(cls, value, pa_type: pa.DataType | None = None) -> pa.Scalar: ...
    @classmethod
    def _box_pa_array(cls, value, pa_type: pa.DataType | None = None, copy: bool = False) -> pa.Array | pa.ChunkedArray: ...
    def __len__(self) -> int:
        """
        Length of this array.

        Returns
        -------
        length : int
        """
    @classmethod
    def _from_sequence(cls, scalars, *, dtype: Dtype | None = None, copy: bool = False): ...
    @classmethod
    def _from_sequence_of_strings(cls, strings, dtype: Dtype | None = None, copy: bool = False): ...
    @property
    def dtype(self) -> StringDtype:
        """
        An instance of 'string[pyarrow]'.
        """
    def insert(self, loc: int, item) -> ArrowStringArray: ...
    @classmethod
    def _result_converter(cls, values, na: Incomplete | None = None): ...
    def _maybe_convert_setitem_value(self, value):
        """Maybe convert value to be pyarrow compatible."""
    def isin(self, values: ArrayLike) -> npt.NDArray[np.bool_]: ...
    def astype(self, dtype, copy: bool = True): ...
    @property
    def _data(self): ...
    _str_na_value: Incomplete
    def _str_map(self, f, na_value: Incomplete | None = None, dtype: Dtype | None = None, convert: bool = True): ...
    def _str_contains(self, pat, case: bool = True, flags: int = 0, na=..., regex: bool = True): ...
    def _str_startswith(self, pat: str | tuple[str, ...], na: Scalar | None = None): ...
    def _str_endswith(self, pat: str | tuple[str, ...], na: Scalar | None = None): ...
    def _str_replace(self, pat: str | re.Pattern, repl: str | Callable, n: int = -1, case: bool = True, flags: int = 0, regex: bool = True): ...
    def _str_repeat(self, repeats: int | Sequence[int]): ...
    def _str_match(self, pat: str, case: bool = True, flags: int = 0, na: Scalar | None = None): ...
    def _str_fullmatch(self, pat, case: bool = True, flags: int = 0, na: Scalar | None = None): ...
    def _str_slice(self, start: int | None = None, stop: int | None = None, step: int | None = None): ...
    def _str_isalnum(self): ...
    def _str_isalpha(self): ...
    def _str_isdecimal(self): ...
    def _str_isdigit(self): ...
    def _str_islower(self): ...
    def _str_isnumeric(self): ...
    def _str_isspace(self): ...
    def _str_istitle(self): ...
    def _str_isupper(self): ...
    def _str_len(self): ...
    def _str_lower(self): ...
    def _str_upper(self): ...
    def _str_strip(self, to_strip: Incomplete | None = None): ...
    def _str_lstrip(self, to_strip: Incomplete | None = None): ...
    def _str_rstrip(self, to_strip: Incomplete | None = None): ...
    def _str_removeprefix(self, prefix: str): ...
    def _str_removesuffix(self, suffix: str): ...
    def _str_count(self, pat: str, flags: int = 0): ...
    def _str_find(self, sub: str, start: int = 0, end: int | None = None): ...
    def _str_get_dummies(self, sep: str = '|'): ...
    def _convert_int_dtype(self, result): ...
    def _reduce(self, name: str, *, skipna: bool = True, keepdims: bool = False, **kwargs): ...
    def _rank(self, *, axis: AxisInt = 0, method: str = 'average', na_option: str = 'keep', ascending: bool = True, pct: bool = False):
        """
        See Series.rank.__doc__.
        """

class ArrowStringArrayNumpySemantics(ArrowStringArray):
    _storage: str
    @classmethod
    def _result_converter(cls, values, na: Incomplete | None = None): ...
    def __getattribute__(self, item): ...
    def _str_map(self, f, na_value: Incomplete | None = None, dtype: Dtype | None = None, convert: bool = True): ...
    def _convert_int_dtype(self, result): ...
    def _cmp_method(self, other, op): ...
    def value_counts(self, dropna: bool = True) -> Series: ...
    def _reduce(self, name: str, *, skipna: bool = True, keepdims: bool = False, **kwargs): ...
    def insert(self, loc: int, item) -> ArrowStringArrayNumpySemantics: ...
