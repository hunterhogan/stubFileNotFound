"""
This type stub file was generated by pyright.
"""

"""Module containing a memory memory manager which provides a sliding window on a number of memory mapped files"""
__all__ = ["align_to_mmap", "is_64_bit", "MapWindow", "MapRegion", "MapRegionList", "ALLOCATIONGRANULARITY"]
def align_to_mmap(num, round_up):
    """
    Align the given integer number to the closest page offset, which usually is 4096 bytes.

    :param round_up: if True, the next higher multiple of page size is used, otherwise
        the lower page_size will be used (i.e. if True, 1 becomes 4096, otherwise it becomes 0)
    :return: num rounded to closest page"""
    ...

def is_64_bit(): # -> bool:
    """:return: True if the system is 64 bit. Otherwise it can be assumed to be 32 bit"""
    ...

class MapWindow:
    """Utility type which is used to snap windows towards each other, and to adjust their size"""
    __slots__ = ...
    def __init__(self, offset, size) -> None:
        ...
    
    def __repr__(self): # -> LiteralString:
        ...
    
    @classmethod
    def from_region(cls, region): # -> Self:
        """:return: new window from a region"""
        ...
    
    def ofs_end(self):
        ...
    
    def align(self): # -> None:
        """Assures the previous window area is contained in the new one"""
        ...
    
    def extend_left_to(self, window, max_size): # -> None:
        """Adjust the offset to start where the given window on our left ends if possible,
        but don't make yourself larger than max_size.
        The resize will assure that the new window still contains the old window area"""
        ...
    
    def extend_right_to(self, window, max_size): # -> None:
        """Adjust the size to make our window end where the right window begins, but don't
        get larger than max_size"""
        ...
    


class MapRegion:
    """Defines a mapped region of memory, aligned to pagesizes

    **Note:** deallocates used region automatically on destruction"""
    __slots__ = ...
    def __init__(self, path_or_fd, ofs, size, flags=...) -> None:
        """Initialize a region, allocate the memory map
        :param path_or_fd: path to the file to map, or the opened file descriptor
        :param ofs: **aligned** offset into the file to be mapped
        :param size: if size is larger then the file on disk, the whole file will be
            allocated the the size automatically adjusted
        :param flags: additional flags to be given when opening the file.
        :raise Exception: if no memory can be allocated"""
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def buffer(self): # -> mmap:
        """:return: a buffer containing the memory"""
        ...
    
    def map(self): # -> mmap:
        """:return: a memory map containing the memory"""
        ...
    
    def ofs_begin(self): # -> Any:
        """:return: absolute byte offset to the first byte of the mapping"""
        ...
    
    def size(self): # -> int:
        """:return: total size of the mapped region in bytes"""
        ...
    
    def ofs_end(self):
        """:return: Absolute offset to one byte beyond the mapping into the file"""
        ...
    
    def includes_ofs(self, ofs):
        """:return: True if the given offset can be read in our mapped region"""
        ...
    
    def client_count(self): # -> int:
        """:return: number of clients currently using this region"""
        ...
    
    def increment_client_count(self, ofs=...): # -> bool:
        """Adjust the usage count by the given positive or negative offset.
        If usage count equals 0, we will auto-release our resources
        :return: True if we released resources, False otherwise. In the latter case, we can still be used"""
        ...
    
    def release(self): # -> None:
        """Release all resources this instance might hold. Must only be called if there usage_count() is zero"""
        ...
    


class MapRegionList(list):
    """List of MapRegion instances associating a path with a list of regions."""
    __slots__ = ...
    def __new__(cls, path): # -> Self:
        ...
    
    def __init__(self, path_or_fd) -> None:
        ...
    
    def path_or_fd(self): # -> Any:
        """:return: path or file descriptor we are attached to"""
        ...
    
    def file_size(self): # -> int:
        """:return: size of file we manager"""
        ...
    


