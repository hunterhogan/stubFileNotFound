from _typeshed import Incomplete
from numba.core.extending import overload_method as overload_method, register_jitable as register_jitable
from numba.core.types.containers import Tuple as Tuple, UniTuple as UniTuple
from numba.np.numpy_support import as_dtype as as_dtype, from_dtype as from_dtype, is_nonelike as is_nonelike
from numba.np.random.distributions import random_beta as random_beta, random_binomial as random_binomial, random_chisquare as random_chisquare, random_exponential as random_exponential, random_f as random_f, random_gamma as random_gamma, random_geometric as random_geometric, random_laplace as random_laplace, random_logistic as random_logistic, random_lognormal as random_lognormal, random_logseries as random_logseries, random_negative_binomial as random_negative_binomial, random_noncentral_chisquare as random_noncentral_chisquare, random_noncentral_f as random_noncentral_f, random_normal as random_normal, random_pareto as random_pareto, random_poisson as random_poisson, random_power as random_power, random_rayleigh as random_rayleigh, random_standard_cauchy as random_standard_cauchy, random_standard_exponential as random_standard_exponential, random_standard_exponential_f as random_standard_exponential_f, random_standard_exponential_inv as random_standard_exponential_inv, random_standard_exponential_inv_f as random_standard_exponential_inv_f, random_standard_gamma as random_standard_gamma, random_standard_gamma_f as random_standard_gamma_f, random_standard_normal as random_standard_normal, random_standard_normal_f as random_standard_normal_f, random_standard_t as random_standard_t, random_triangular as random_triangular, random_uniform as random_uniform, random_wald as random_wald, random_weibull as random_weibull, random_zipf as random_zipf
from numba.np.random.generator_core import next_double as next_double, next_float as next_float

def _get_proper_func(func_32, func_64, dtype, dist_name: str = 'the given'):
    """
        Most of the standard NumPy distributions that accept dtype argument
        only support either np.float32 or np.float64 as dtypes.

        This is a helper function that helps Numba select the proper underlying
        implementation according to provided dtype.
    """
def check_size(size) -> None: ...
def check_types(obj, type_list, arg_name) -> None:
    """
    Check if given object is one of the provided types.
    If not raises an TypeError
    """
def NumPyRandomGeneratorType_integers(inst, low, high, size: Incomplete | None = None, dtype=..., endpoint: bool = False): ...
def NumPyRandomGeneratorType_shuffle(inst, x, axis: int = 0): ...
def NumPyRandomGeneratorType_permutation(inst, x, axis: int = 0): ...
def NumPyRandomGeneratorType_random(inst, size: Incomplete | None = None, dtype=...): ...
def NumPyRandomGeneratorType_standard_exponential(inst, size: Incomplete | None = None, dtype=..., method: str = 'zig'): ...
def NumPyRandomGeneratorType_standard_normal(inst, size: Incomplete | None = None, dtype=...): ...
def NumPyRandomGeneratorType_standard_gamma(inst, shape, size: Incomplete | None = None, dtype=...): ...
def NumPyRandomGeneratorType_normal(inst, loc: float = 0.0, scale: float = 1.0, size: Incomplete | None = None): ...
def NumPyRandomGeneratorType_uniform(inst, low: float = 0.0, high: float = 1.0, size: Incomplete | None = None): ...
def NumPyRandomGeneratorType_exponential(inst, scale: float = 1.0, size: Incomplete | None = None): ...
def NumPyRandomGeneratorType_gamma(inst, shape, scale: float = 1.0, size: Incomplete | None = None): ...
def NumPyRandomGeneratorType_beta(inst, a, b, size: Incomplete | None = None): ...
def NumPyRandomGeneratorType_f(inst, dfnum, dfden, size: Incomplete | None = None): ...
def NumPyRandomGeneratorType_chisquare(inst, df, size: Incomplete | None = None): ...
def NumPyRandomGeneratorType_standard_cauchy(inst, size: Incomplete | None = None): ...
def NumPyRandomGeneratorType_pareto(inst, a, size: Incomplete | None = None): ...
def NumPyRandomGeneratorType_weibull(inst, a, size: Incomplete | None = None): ...
def NumPyRandomGeneratorType_power(inst, a, size: Incomplete | None = None): ...
def NumPyRandomGeneratorType_laplace(inst, loc: float = 0.0, scale: float = 1.0, size: Incomplete | None = None): ...
def NumPyRandomGeneratorType_logistic(inst, loc: float = 0.0, scale: float = 1.0, size: Incomplete | None = None): ...
def NumPyRandomGeneratorType_lognormal(inst, mean: float = 0.0, sigma: float = 1.0, size: Incomplete | None = None): ...
def NumPyRandomGeneratorType_rayleigh(inst, scale: float = 1.0, size: Incomplete | None = None): ...
def NumPyRandomGeneratorType_standard_t(inst, df, size: Incomplete | None = None): ...
def NumPyRandomGeneratorType_wald(inst, mean, scale, size: Incomplete | None = None): ...
def NumPyRandomGeneratorType_geometric(inst, p, size: Incomplete | None = None): ...
def NumPyRandomGeneratorType_zipf(inst, a, size: Incomplete | None = None): ...
def NumPyRandomGeneratorType_triangular(inst, left, mode, right, size: Incomplete | None = None): ...
def NumPyRandomGeneratorType_poisson(inst, lam, size: Incomplete | None = None): ...
def NumPyRandomGeneratorType_negative_binomial(inst, n, p, size: Incomplete | None = None): ...
def NumPyRandomGeneratorType_noncentral_chisquare(inst, df, nonc, size: Incomplete | None = None): ...
def NumPyRandomGeneratorType_noncentral_f(inst, dfnum, dfden, nonc, size: Incomplete | None = None): ...
def NumPyRandomGeneratorType_logseries(inst, p, size: Incomplete | None = None): ...
def NumPyRandomGeneratorType_binomial(inst, n, p, size: Incomplete | None = None): ...
