from _typeshed import Incomplete
from numba.core import cgutils as cgutils, types as types, typing as typing, utils as utils
from numba.core.errors import (
	LoweringError as LoweringError, NumbaExperimentalFeatureWarning as NumbaExperimentalFeatureWarning,
	NumbaPerformanceWarning as NumbaPerformanceWarning, NumbaTypeError as NumbaTypeError,
	RequireLiteralValue as RequireLiteralValue, TypingError as TypingError)
from numba.core.extending import intrinsic as intrinsic
from numba.core.imputils import (
	call_getiter as call_getiter, call_iternext as call_iternext, impl_ret_borrowed as impl_ret_borrowed,
	impl_ret_untracked as impl_ret_untracked, iternext_impl as iternext_impl, lower_builtin as lower_builtin,
	lower_cast as lower_cast, lower_constant as lower_constant, lower_getattr as lower_getattr,
	lower_getattr_generic as lower_getattr_generic, numba_typeref_ctor as numba_typeref_ctor)
from numba.core.typeconv import Conversion as Conversion
from numba.core.typing.asnumbatype import as_numba_type as as_numba_type
from numba.core.typing.builtins import IndexValue as IndexValue, IndexValueType as IndexValueType
from numba.core.typing.templates import (
	AbstractTemplate as AbstractTemplate, infer_global as infer_global, signature as signature)
from numba.extending import overload as overload, register_jitable as register_jitable
from numba.misc.special import literal_unroll as literal_unroll
from typing import NamedTuple

def ol_truth(val): ...
def generic_is_not(context, builder, sig, args):
    """
    Implement `x is not y` as `not (x is y)`.
    """
def generic_is(context, builder, sig, args):
    """
    Default implementation for `x is y`
    """
def opaque_is(context, builder, sig, args):
    """
    Implementation for `x is y` for Opaque types.
    """
def bool_is_impl(context, builder, sig, args):
    """
    Implementation for `x is y` for types derived from types.Boolean
    (e.g. BooleanLiteral), and cross-checks between literal and non-literal
    booleans, to satisfy Python's behavior preserving identity for bools.
    """
def const_eq_impl(context, builder, sig, args): ...
def const_ne_impl(context, builder, sig, args): ...
def gen_non_eq(val): ...
def deferred_getattr(context, builder, typ, value, attr):
    """
    Deferred.__getattr__ => redirect to the actual type.
    """
def any_to_deferred(context, builder, fromty, toty, val): ...
def deferred_to_any(context, builder, fromty, toty, val): ...
def getitem_cpointer(context, builder, sig, args): ...
def setitem_cpointer(context, builder, sig, args) -> None: ...
def do_minmax(context, builder, argtys, args, cmpop): ...
def max_iterable(context, builder, sig, args): ...
def max_vararg(context, builder, sig, args): ...
def min_iterable(context, builder, sig, args): ...
def min_vararg(context, builder, sig, args): ...
def _round_intrinsic(tp): ...
def round_impl_unary(context, builder, sig, args): ...
def round_impl_binary(context, builder, sig, args): ...
def int_impl(context, builder, sig, args): ...
def float_literal_impl(context, builder, sig, args): ...
def complex_impl(context, builder, sig, args): ...
def number_constructor(context, builder, sig, args):
    """
    Call a number class, e.g. np.int32(...)
    """
def constant_dummy(context, builder, ty, pyval): ...
def constant_function_pointer(context, builder, ty, pyval): ...
def constant_optional(context, builder, ty, pyval): ...
def type_impl(context, builder, sig, args):
    """
    One-argument type() builtin.
    """
def iter_impl(context, builder, sig, args): ...
def next_impl(context, builder, sig, args): ...
def not_in(context, builder, sig, args): ...
def constsized_len(context, builder, sig, args): ...
def sized_bool(context, builder, sig, args): ...
def lower_empty_tuple(context, builder, sig, args): ...
def lower_tuple(context, builder, sig, args): ...
def bool_sequence(x): ...
def bool_none(x): ...
def get_type_max_value(typ): ...
def get_type_min_value(typ): ...

class MinValInfer(AbstractTemplate):
    def generic(self, args, kws): ...

def lower_get_type_min_value(context, builder, sig, args): ...
def lower_get_type_max_value(context, builder, sig, args): ...
def impl_index_value(context, builder, sig, args): ...
def indval_min(indval1, indval2): ...
def boolval_min(val1, val2): ...
def indval_max(indval1, indval2): ...
def boolval_max(val1, val2): ...

greater_than: Incomplete
less_than: Incomplete

@register_jitable
def min_max_impl(iterable, op): ...
def iterable_min(iterable): ...
def iterable_max(iterable): ...
def redirect_type_ctor(context, builder, sig, args):
    """Redirect constructor implementation to `numba_typeref_ctor(cls, *args)`,
    which should be overloaded by the type's implementation.

    For example:

        d = Dict()

    `d` will be typed as `TypeRef[DictType]()`.  Thus, it will call into this
    implementation.  We need to redirect the lowering to a function
    named ``numba_typeref_ctor``.
    """
def ol_sum(iterable, start: int = 0): ...
def ol_map(func, iterable, *args): ...
def ol_filter(func, iterable): ...
def ol_isinstance(var, typs): ...
def _getattr_raise_attr_exc(obj, name) -> None: ...
def ol__getattr_raise_attr_exc(obj, name): ...
@intrinsic
def resolve_getattr(tyctx, obj, name, default): ...
class _getattr_default_type(NamedTuple): ...

_getattr_default: Incomplete

def ol_getattr_2(obj, name): ...
def ol_getattr_3(obj, name, default): ...
@intrinsic
def resolve_hasattr(tyctx, obj, name): ...
def ol_hasattr(obj, name): ...
def ol_repr_generic(obj): ...
def ol_str_generic(object: str = ''): ...
