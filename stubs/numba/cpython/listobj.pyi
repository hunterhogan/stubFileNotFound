from _typeshed import Incomplete
from numba.core import cgutils as cgutils, config as config, errors as errors, types as types, typing as typing
from numba.core.extending import overload as overload, overload_method as overload_method
from numba.core.imputils import RefType as RefType, impl_ret_borrowed as impl_ret_borrowed, impl_ret_new_ref as impl_ret_new_ref, impl_ret_untracked as impl_ret_untracked, iternext_impl as iternext_impl, lower_builtin as lower_builtin, lower_cast as lower_cast

def get_list_payload(context, builder, list_type, value):
    """
    Given a list value and type, get its payload structure (as a
    reference, so that mutations are seen by all).
    """
def get_itemsize(context, list_type):
    """
    Return the item size for the given list type.
    """

class _ListPayloadMixin:
    @property
    def size(self): ...
    @size.setter
    def size(self, value) -> None: ...
    @property
    def dirty(self): ...
    @property
    def data(self): ...
    def _gep(self, idx): ...
    def getitem(self, idx): ...
    def fix_index(self, idx):
        """
        Fix negative indices by adding the size to them.  Positive
        indices are left untouched.
        """
    def is_out_of_bounds(self, idx):
        """
        Return whether the index is out of bounds.
        """
    def clamp_index(self, idx):
        """
        Clamp the index in [0, size].
        """
    def guard_index(self, idx, msg) -> None:
        """
        Raise an error if the index is out of bounds.
        """
    def fix_slice(self, slice):
        """
        Fix slice start and stop to be valid (inclusive and exclusive, resp)
        indexing bounds.
        """
    def incref_value(self, val) -> None:
        """Incref an element value"""
    def decref_value(self, val) -> None:
        """Decref an element value"""

class ListPayloadAccessor(_ListPayloadMixin):
    """
    A helper object to access the list attributes given the pointer to the
    payload type.
    """
    _context: Incomplete
    _builder: Incomplete
    _ty: Incomplete
    _datamodel: Incomplete
    _payload: Incomplete
    def __init__(self, context, builder, list_type, payload_ptr) -> None: ...

class ListInstance(_ListPayloadMixin):
    _context: Incomplete
    _builder: Incomplete
    _ty: Incomplete
    _list: Incomplete
    _itemsize: Incomplete
    _datamodel: Incomplete
    def __init__(self, context, builder, list_type, list_val) -> None: ...
    @property
    def dtype(self): ...
    @property
    def _payload(self): ...
    @property
    def parent(self): ...
    @parent.setter
    def parent(self, value) -> None: ...
    @property
    def value(self): ...
    @property
    def meminfo(self): ...
    def set_dirty(self, val) -> None: ...
    def clear_value(self, idx) -> None:
        """Remove the value at the location
        """
    def setitem(self, idx, val, incref, decref_old_value: bool = True) -> None: ...
    def inititem(self, idx, val, incref: bool = True) -> None: ...
    def zfill(self, start, stop) -> None:
        """Zero-fill the memory at index *start* to *stop*

        *stop* MUST not be smaller than *start*.
        """
    @classmethod
    def allocate_ex(cls, context, builder, list_type, nitems):
        """
        Allocate a ListInstance with its storage.
        Return a (ok, instance) tuple where *ok* is a LLVM boolean and
        *instance* is a ListInstance object (the object's contents are
        only valid when *ok* is true).
        """
    def define_dtor(self):
        """Define the destructor if not already defined"""
    def get_dtor(self):
        '''"Get the element dtor function pointer as void pointer.

        It\'s safe to be called multiple times.
        '''
    @classmethod
    def allocate(cls, context, builder, list_type, nitems):
        """
        Allocate a ListInstance with its storage.  Same as allocate_ex(),
        but return an initialized *instance*.  If allocation failed,
        control is transferred to the caller using the target's current
        call convention.
        """
    @classmethod
    def from_meminfo(cls, context, builder, list_type, meminfo):
        """
        Allocate a new list instance pointing to an existing payload
        (a meminfo pointer).
        Note the parent field has to be filled by the caller.
        """
    def resize(self, new_size) -> None:
        """
        Ensure the list is properly sized for the new size.
        """
    def move(self, dest_idx, src_idx, count) -> None:
        """
        Move `count` elements from `src_idx` to `dest_idx`.
        """

class ListIterInstance(_ListPayloadMixin):
    _context: Incomplete
    _builder: Incomplete
    _ty: Incomplete
    _iter: Incomplete
    _datamodel: Incomplete
    def __init__(self, context, builder, iter_type, iter_val) -> None: ...
    @classmethod
    def from_list(cls, context, builder, iter_type, list_val): ...
    @property
    def _payload(self): ...
    @property
    def value(self): ...
    @property
    def index(self): ...
    @index.setter
    def index(self, value) -> None: ...

def build_list(context, builder, list_type, items):
    """
    Build a list of the given type, containing the given items.
    """
def list_len(context, builder, sig, args): ...
def getiter_list(context, builder, sig, args): ...
def iternext_listiter(context, builder, sig, args, result) -> None: ...
def getitem_list(context, builder, sig, args): ...
def setitem_list(context, builder, sig, args): ...
def getslice_list(context, builder, sig, args): ...
def delitem_list_index(context, builder, sig, args): ...
def delitem_list(context, builder, sig, args): ...
def in_seq(context, builder, sig, args): ...
def sequence_bool(context, builder, sig, args): ...
def sequence_truth(seq): ...
def list_add(context, builder, sig, args): ...
def list_add_inplace(context, builder, sig, args): ...
def list_mul(context, builder, sig, args): ...
def list_mul_inplace(context, builder, sig, args): ...
def list_is(context, builder, sig, args): ...
def list_eq(context, builder, sig, args): ...
def all_list(*args): ...
def impl_list_ne(a, b): ...
def impl_list_le(a, b): ...
def impl_list_lt(a, b): ...
def impl_list_ge(a, b): ...
def impl_list_gt(a, b): ...
def list_append(context, builder, sig, args): ...
def list_clear(context, builder, sig, args): ...
def list_copy(lst): ...
def list_count(lst, value): ...
def _list_extend_list(context, builder, sig, args): ...
def list_extend(context, builder, sig, args): ...

intp_max: Incomplete

def list_index(lst, value, start: int = 0, stop=...): ...
def list_insert(context, builder, sig, args): ...
def list_remove(lst, value): ...
def list_reverse(lst): ...
def gt(a, b): ...

sort_forwards: Incomplete
sort_backwards: Incomplete
arg_sort_forwards: Incomplete
arg_sort_backwards: Incomplete

def _sort_check_reverse(reverse): ...
def _sort_check_key(key) -> None: ...
def ol_list_sort(lst, key: Incomplete | None = None, reverse: bool = False): ...
def ol_sorted(iterable, key: Incomplete | None = None, reverse: bool = False): ...
def list_to_list(context, builder, fromty, toty, val): ...

_banned_error: Incomplete

def literal_list_banned_append(lst, obj) -> None: ...
def literal_list_banned_extend(lst, iterable) -> None: ...
def literal_list_banned_insert(lst, index, obj) -> None: ...
def literal_list_banned_remove(lst, value) -> None: ...
def literal_list_banned_pop(lst, index: int = -1) -> None: ...
def literal_list_banned_clear(lst) -> None: ...
def literal_list_banned_sort(lst, key: Incomplete | None = None, reverse: bool = False) -> None: ...
def literal_list_banned_reverse(lst) -> None: ...

_index_end: Incomplete

def literal_list_index(lst, x, start: int = 0, end=...) -> None: ...
def literal_list_delitem(lst, index) -> None: ...
def literal_list_setitem(lst, index, value) -> None: ...
def literal_list_getitem(lst, *args) -> None: ...
def literal_list_len(lst): ...
def literal_list_contains(lst, item): ...
def literallist_to_literallist(context, builder, fromty, toty, val): ...
