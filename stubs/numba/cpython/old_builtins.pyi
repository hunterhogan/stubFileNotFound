from _typeshed import Incomplete
from numba.core import cgutils as cgutils, types as types, typing as typing, utils as utils
from numba.core.errors import LoweringError as LoweringError, NumbaExperimentalFeatureWarning as NumbaExperimentalFeatureWarning, NumbaPerformanceWarning as NumbaPerformanceWarning, NumbaTypeError as NumbaTypeError, RequireLiteralValue as RequireLiteralValue, TypingError as TypingError
from numba.core.imputils import call_getiter as call_getiter, call_iternext as call_iternext, impl_ret_borrowed as impl_ret_borrowed, impl_ret_untracked as impl_ret_untracked, iternext_impl as iternext_impl, lower_builtin as lower_builtin, lower_cast as lower_cast, lower_constant as lower_constant, lower_getattr as lower_getattr, lower_getattr_generic as lower_getattr_generic, numba_typeref_ctor as numba_typeref_ctor
from numba.core.typing.builtins import IndexValue as IndexValue, IndexValueType as IndexValueType
from numba.core.typing.templates import AbstractTemplate as AbstractTemplate, infer_global as infer_global, signature as signature
from numba.extending import overload as overload, register_jitable as register_jitable
from typing import NamedTuple

def ol_truth(val): ...
def generic_is_not(context, builder, sig, args):
    """
    Implement `x is not y` as `not (x is y)`.
    """
def generic_is(context, builder, sig, args):
    """
    Default implementation for `x is y`
    """
def opaque_is(context, builder, sig, args):
    """
    Implementation for `x is y` for Opaque types.
    """
def bool_is_impl(context, builder, sig, args):
    """
    Implementation for `x is y` for types derived from types.Boolean
    (e.g. BooleanLiteral), and cross-checks between literal and non-literal
    booleans, to satisfy Python's behavior preserving identity for bools.
    """
def const_eq_impl(context, builder, sig, args): ...
def const_ne_impl(context, builder, sig, args): ...
def gen_non_eq(val): ...
def deferred_getattr(context, builder, typ, value, attr):
    """
    Deferred.__getattr__ => redirect to the actual type.
    """
def any_to_deferred(context, builder, fromty, toty, val): ...
def deferred_to_any(context, builder, fromty, toty, val): ...
def getitem_cpointer(context, builder, sig, args): ...
def setitem_cpointer(context, builder, sig, args) -> None: ...
def do_minmax(context, builder, argtys, args, cmpop): ...
def max_iterable(context, builder, sig, args): ...
def max_vararg(context, builder, sig, args): ...
def min_iterable(context, builder, sig, args): ...
def min_vararg(context, builder, sig, args): ...
def _round_intrinsic(tp): ...
def round_impl_unary(context, builder, sig, args): ...
def round_impl_binary(context, builder, sig, args): ...
def int_impl(context, builder, sig, args): ...
def float_literal_impl(context, builder, sig, args): ...
def complex_impl(context, builder, sig, args): ...
def number_constructor(context, builder, sig, args):
    """
    Call a number class, e.g. np.int32(...)
    """
def constant_dummy(context, builder, ty, pyval): ...
def constant_function_pointer(context, builder, ty, pyval): ...
def constant_optional(context, builder, ty, pyval): ...
def type_impl(context, builder, sig, args):
    """
    One-argument type() builtin.
    """
def iter_impl(context, builder, sig, args): ...
def next_impl(context, builder, sig, args): ...
def not_in(context, builder, sig, args): ...
def constsized_len(context, builder, sig, args): ...
def sized_bool(context, builder, sig, args): ...
def lower_empty_tuple(context, builder, sig, args): ...
def lower_tuple(context, builder, sig, args): ...
def bool_sequence(x): ...
def bool_none(x): ...
def get_type_max_value(typ): ...
def get_type_min_value(typ): ...

class MinValInfer(AbstractTemplate):
    def generic(self, args, kws): ...

def lower_get_type_min_value(context, builder, sig, args): ...
def lower_get_type_max_value(context, builder, sig, args): ...
def impl_index_value(context, builder, sig, args): ...
def indval_min(indval1, indval2): ...
def boolval_min(val1, val2): ...
def indval_max(indval1, indval2): ...
def boolval_max(val1, val2): ...

greater_than: Incomplete
less_than: Incomplete

def min_max_impl(iterable, op): ...
def iterable_min(iterable): ...
def iterable_max(iterable): ...
def redirect_type_ctor(context, builder, sig, args):
    """Redirect constructor implementation to `numba_typeref_ctor(cls, *args)`,
    which should be overloaded by the type's implementation.

    For example:

        d = Dict()

    `d` will be typed as `TypeRef[DictType]()`.  Thus, it will call into this
    implementation.  We need to redirect the lowering to a function
    named ``numba_typeref_ctor``.
    """
def ol_sum(iterable, start: int = 0): ...
def ol_map(func, iterable, *args): ...
def ol_filter(func, iterable): ...
def ol_isinstance(var, typs): ...
def _getattr_raise_attr_exc(obj, name) -> None: ...
def ol__getattr_raise_attr_exc(obj, name): ...
def resolve_getattr(tyctx, obj, name, default): ...
class _getattr_default_type(NamedTuple): ...

_getattr_default: Incomplete

def ol_getattr_2(obj, name): ...
def ol_getattr_3(obj, name, default): ...
def resolve_hasattr(tyctx, obj, name): ...
def ol_hasattr(obj, name): ...
def ol_repr_generic(obj): ...
def ol_str_generic(object: str = ''): ...
