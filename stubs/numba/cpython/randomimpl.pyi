from _typeshed import Incomplete
from numba.core import cgutils as cgutils, types as types
from numba.core.cgutils import is_empty_tuple as is_empty_tuple, is_nonelike as is_nonelike
from numba.core.errors import NumbaTypeError as NumbaTypeError
from numba.core.extending import intrinsic as intrinsic, overload as overload, register_jitable as register_jitable
from numba.core.imputils import Registry as Registry, impl_ret_new_ref as impl_ret_new_ref, impl_ret_untracked as impl_ret_untracked
from numba.core.typing import signature as signature
from numba.np.random._constants import LONG_MAX as LONG_MAX

registry: Incomplete
lower: Incomplete
int32_t: Incomplete
int64_t: Incomplete

def const_int(x): ...

double: Incomplete
N: int
N_const: Incomplete
rnd_state_t: Incomplete
rnd_state_ptr_t: Incomplete

def get_state_ptr(context, builder, name):
    '''
    Get a pointer to the given thread-local random state
    (depending on *name*: "py" or "np").
    If the state isn\'t initialized, it is lazily initialized with
    system entropy.
    '''
def get_py_state_ptr(context, builder):
    """
    Get a pointer to the thread-local Python random state.
    """
def get_np_state_ptr(context, builder):
    """
    Get a pointer to the thread-local Numpy random state.
    """
def get_internal_state_ptr(context, builder):
    """
    Get a pointer to the thread-local internal random state.
    """
def get_index_ptr(builder, state_ptr): ...
def get_array_ptr(builder, state_ptr): ...
def get_has_gauss_ptr(builder, state_ptr): ...
def get_gauss_ptr(builder, state_ptr): ...
def get_rnd_shuffle(builder):
    """
    Get the internal function to shuffle the MT taste.
    """
def get_next_int32(context, builder, state_ptr):
    """
    Get the next int32 generated by the PRNG at *state_ptr*.
    """
def get_next_double(context, builder, state_ptr):
    """
    Get the next double generated by the PRNG at *state_ptr*.
    """
def get_next_int(context, builder, state_ptr, nbits, is_numpy):
    """
    Get the next integer with width *nbits*.
    """
def _seed_impl(state_type): ...
def random_impl(): ...
def random_impl0(): ...
def random_impl1(size: Incomplete | None = None): ...
def gauss_impl(mu, sigma): ...
def np_gauss_impl0(): ...
def np_gauss_impl1(loc): ...
def np_gauss_impl2(loc, scale): ...
def standard_normal_impl1(size): ...
def np_gauss_impl3(loc, scale, size): ...
def _gauss_pair_impl(_random): ...
def _gauss_impl(state, loc_preprocessor, scale_preprocessor): ...
def _double_preprocessor(value): ...
def getrandbits_impl(k): ...
def _randrange_impl(context, builder, start, stop, step, ty, signed, state): ...
def randrange_impl_1(start): ...
def randrange_impl_2(start, stop): ...
def _randrange_preprocessor(bitwidth, ty): ...
def randrange_impl_3(start, stop, step): ...
def randint_impl_1(a, b): ...
def np_randint_impl_1(low): ...
def np_randint_impl_2(low, high): ...
def np_randint_impl_3(low, high, size): ...
def np_uniform_impl0(): ...
def uniform_impl2(a, b): ...
def np_uniform_impl2(low, high): ...
def uniform_impl(state, a_preprocessor, b_preprocessor): ...
def np_uniform_impl3(low, high, size): ...
def triangular_impl_2(low, high): ...
def triangular_impl(left, mode, right, size: Incomplete | None = None): ...
def gammavariate_impl(alpha, beta): ...
def ol_np_random_gamma1(shape): ...
def ol_np_random_gamma2(shape, scale): ...
def _gammavariate_impl(_random): ...
def gamma_impl(shape, scale, size): ...
def standard_gamma_impl(shape, size): ...
def betavariate_impl(alpha, beta): ...
def ol_np_random_beta(a, b): ...
def _betavariate_impl(gamma): ...
def beta_impl(a, b, size): ...
def expovariate_impl(lambd): ...
def standard_exponential_impl(size): ...
def np_lognormal_impl0(): ...
def np_log_normal_impl1(mean): ...
def np_log_normal_impl2(mean, sigma): ...
def lognormal_impl(mean, sigma, size): ...
def lognormvariate_impl(mu, sigma): ...
def _lognormvariate_impl(_gauss): ...
def paretovariate_impl(alpha): ...
def weibullvariate_impl(alpha, beta): ...
def weibull_impl(a): ...
def weibull_impl2(a, size): ...
def _vonmisesvariate_impl(_random): ...
def vonmises_impl(mu, kappa, size): ...
def chisquare_impl(df): ...
def chisquare_impl2(df, size): ...
def gumbel_impl(loc, scale): ...
def gumbel_impl3(loc, scale, size): ...
def laplace_impl0(): ...
def laplace_impl1(loc): ...
def laplace_impl2(loc, scale): ...
def laplace_impl3(loc, scale, size): ...
def laplace_impl(loc, scale): ...
def logistic_impl0(): ...
def logistic_impl1(loc): ...
def logistic_impl2(loc, scale): ...
def logistic_impl3(loc, scale, size): ...
def logistic_impl(loc, scale): ...
def _logseries_impl(p):
    """Numpy's algorithm for logseries()."""
def negative_binomial_impl(n, p): ...
def poisson_impl0(): ...
def poisson_impl1(lam): ...
def poisson_impl2(lam, size): ...
def rayleigh_impl0(): ...
def rayleigh_impl1(scale): ...
def rayleigh_impl2(scale, size): ...
def cauchy_impl(): ...
def standard_cauchy_impl(size): ...
def standard_t_impl(df): ...
def standard_t_impl2(df, size): ...
def wald_impl(mean, scale): ...
def wald_impl2(mean, scale, size): ...
def do_shuffle_impl(x, rng): ...
def permutation_impl(x): ...
def rand(*size): ...
def randn(*size): ...
def choice(a, size: Incomplete | None = None, replace: bool = True): ...
def multinomial(n, pvals, size: Incomplete | None = None): ...
def dirichlet_arr(alpha, out) -> None: ...
def noncentral_chisquare_single(df, nonc): ...
def validate_noncentral_chisquare_input(df, nonc) -> None: ...
