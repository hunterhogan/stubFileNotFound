from _typeshed import Incomplete
from numba.core import cgutils as cgutils, errors as errors, optional as optional, types as types, typing as typing, utils as utils
from numba.core.extending import intrinsic as intrinsic, overload_method as overload_method
from numba.core.imputils import impl_ret_borrowed as impl_ret_borrowed, impl_ret_untracked as impl_ret_untracked, lower_builtin as lower_builtin, lower_cast as lower_cast, lower_constant as lower_constant, lower_getattr as lower_getattr, lower_getattr_generic as lower_getattr_generic

def _int_arith_flags(rettype):
    """
    Return the modifier flags for integer arithmetic.
    """
def int_add_impl(context, builder, sig, args): ...
def int_sub_impl(context, builder, sig, args): ...
def int_mul_impl(context, builder, sig, args): ...
def int_divmod_signed(context, builder, ty, x, y):
    """
    Reference Objects/intobject.c
    xdivy = x / y;
    xmody = (long)(x - (unsigned long)xdivy * y);
    /* If the signs of x and y differ, and the remainder is non-0,
     * C89 doesn't define whether xdivy is now the floor or the
     * ceiling of the infinitely precise quotient.  We want the floor,
     * and we have it iff the remainder's sign matches y's.
     */
    if (xmody && ((y ^ xmody) < 0) /* i.e. and signs differ */) {
        xmody += y;
        --xdivy;
        assert(xmody && ((y ^ xmody) >= 0));
    }
    *p_xdivy = xdivy;
    *p_xmody = xmody;
    """
def int_divmod(context, builder, ty, x, y):
    """
    Integer divmod(x, y).  The caller must ensure that y != 0.
    """
def _int_divmod_impl(context, builder, sig, args, zerodiv_message): ...
def int_divmod_impl(context, builder, sig, args): ...
def int_floordiv_impl(context, builder, sig, args): ...
def int_truediv_impl(context, builder, sig, args): ...
def int_rem_impl(context, builder, sig, args): ...
def _get_power_zerodiv_return(context, return_type): ...
def int_power_impl(context, builder, sig, args):
    """
    a ^ b, where a is an integer or real, and b an integer
    """
def static_power_impl(context, builder, sig, args):
    """
    a ^ b, where a is an integer or real, and b a constant integer
    """
def int_slt_impl(context, builder, sig, args): ...
def int_sle_impl(context, builder, sig, args): ...
def int_sgt_impl(context, builder, sig, args): ...
def int_sge_impl(context, builder, sig, args): ...
def int_ult_impl(context, builder, sig, args): ...
def int_ule_impl(context, builder, sig, args): ...
def int_ugt_impl(context, builder, sig, args): ...
def int_uge_impl(context, builder, sig, args): ...
def int_eq_impl(context, builder, sig, args): ...
def int_ne_impl(context, builder, sig, args): ...
def int_signed_unsigned_cmp(op): ...
def int_unsigned_signed_cmp(op): ...
def int_abs_impl(context, builder, sig, args): ...
def uint_abs_impl(context, builder, sig, args): ...
def int_shl_impl(context, builder, sig, args): ...
def int_shr_impl(context, builder, sig, args): ...
def int_and_impl(context, builder, sig, args): ...
def int_or_impl(context, builder, sig, args): ...
def int_xor_impl(context, builder, sig, args): ...
def int_negate_impl(context, builder, sig, args): ...
def int_positive_impl(context, builder, sig, args): ...
def int_invert_impl(context, builder, sig, args): ...
def int_sign_impl(context, builder, sig, args):
    """
    np.sign(int)
    """
def bool_negate_impl(context, builder, sig, args): ...
def bool_unary_positive_impl(context, builder, sig, args): ...
def _implement_integer_operators() -> None: ...
def _implement_bitwise_operators() -> None: ...
def real_add_impl(context, builder, sig, args): ...
def real_sub_impl(context, builder, sig, args): ...
def real_mul_impl(context, builder, sig, args): ...
def real_div_impl(context, builder, sig, args): ...
def real_divmod(context, builder, x, y): ...
def real_divmod_func_body(context, builder, vx, wx): ...
def real_divmod_impl(context, builder, sig, args, loc: Incomplete | None = None): ...
def real_mod_impl(context, builder, sig, args, loc: Incomplete | None = None): ...
def real_floordiv_impl(context, builder, sig, args, loc: Incomplete | None = None): ...
def real_power_impl(context, builder, sig, args): ...
def real_lt_impl(context, builder, sig, args): ...
def real_le_impl(context, builder, sig, args): ...
def real_gt_impl(context, builder, sig, args): ...
def real_ge_impl(context, builder, sig, args): ...
def real_eq_impl(context, builder, sig, args): ...
def real_ne_impl(context, builder, sig, args): ...
def real_abs_impl(context, builder, sig, args): ...
def real_negate_impl(context, builder, sig, args): ...
def real_positive_impl(context, builder, sig, args): ...
def real_sign_impl(context, builder, sig, args):
    """
    np.sign(float)
    """
ty = types.Float

def complex_real_impl(context, builder, typ, value): ...
def complex_imag_impl(context, builder, typ, value): ...
def complex_conjugate_impl(context, builder, sig, args): ...
def real_real_impl(context, builder, typ, value): ...
def real_imag_impl(context, builder, typ, value): ...
def real_conjugate_impl(context, builder, sig, args): ...
def complex_power_impl(context, builder, sig, args): ...
def complex_add_impl(context, builder, sig, args): ...
def complex_sub_impl(context, builder, sig, args): ...
def complex_mul_impl(context, builder, sig, args):
    """
    (a+bi)(c+di)=(ac-bd)+i(ad+bc)
    """

NAN: Incomplete

def complex_div_impl(context, builder, sig, args): ...
def complex_negate_impl(context, builder, sig, args): ...
def complex_positive_impl(context, builder, sig, args): ...
def complex_eq_impl(context, builder, sig, args): ...
def complex_ne_impl(context, builder, sig, args): ...
def complex_abs_impl(context, builder, sig, args):
    """
    abs(z) := hypot(z.real, z.imag)
    """
ty = types.Complex

def number_item_impl(context, builder, sig, args):
    """
    The no-op .item() method on booleans and numbers.
    """
def number_not_impl(context, builder, sig, args): ...
def bool_as_bool(context, builder, sig, args): ...
def int_as_bool(context, builder, sig, args): ...
def float_as_bool(context, builder, sig, args): ...
def complex_as_bool(context, builder, sig, args): ...
def literal_int_to_number(context, builder, fromty, toty, val): ...
def integer_to_integer(context, builder, fromty, toty, val): ...
def integer_to_voidptr(context, builder, fromty, toty, val): ...
def float_to_float(context, builder, fromty, toty, val): ...
def integer_to_float(context, builder, fromty, toty, val): ...
def float_to_integer(context, builder, fromty, toty, val): ...
def non_complex_to_complex(context, builder, fromty, toty, val): ...
def complex_to_complex(context, builder, fromty, toty, val): ...
def any_to_boolean(context, builder, fromty, toty, val): ...
def boolean_to_any(context, builder, fromty, toty, val): ...
def literal_int_to_boolean(context, builder, fromty, toty, val): ...
def constant_complex(context, builder, ty, pyval): ...
def constant_integer(context, builder, ty, pyval): ...
def scalar_view(scalar, viewty):
    """ Typing for the np scalar 'view' method. """
