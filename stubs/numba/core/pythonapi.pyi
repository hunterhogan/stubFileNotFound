from _typeshed import Incomplete
from collections.abc import Generator
from numba import _helperlib as _helperlib
from numba.core import cgutils as cgutils, config as config, imputils as imputils, lowering as lowering, serialize as serialize, types as types, utils as utils
from numba.core.utils import PYVERSION as PYVERSION
from typing import NamedTuple

PY_UNICODE_1BYTE_KIND: Incomplete
PY_UNICODE_2BYTE_KIND: Incomplete
PY_UNICODE_4BYTE_KIND: Incomplete
PY_UNICODE_WCHAR_KIND: Incomplete

class _Registry:
    functions: Incomplete
    def __init__(self) -> None: ...
    def register(self, typeclass): ...
    def lookup(self, typeclass, default: Incomplete | None = None): ...

_boxers: Incomplete
_unboxers: Incomplete
_reflectors: Incomplete
box: Incomplete
unbox: Incomplete
reflect: Incomplete

class _BoxContext(NamedTuple('_BoxContext', [('context', Incomplete), ('builder', Incomplete), ('pyapi', Incomplete), ('env_manager', Incomplete)])):
    """
    The facilities required by boxing implementations.
    """
    __slots__: Incomplete
    def box(self, typ, val): ...

class _UnboxContext(NamedTuple('_UnboxContext', [('context', Incomplete), ('builder', Incomplete), ('pyapi', Incomplete)])):
    """
    The facilities required by unboxing implementations.
    """
    __slots__: Incomplete
    def unbox(self, typ, obj): ...

class _ReflectContext(NamedTuple('_ReflectContext', [('context', Incomplete), ('builder', Incomplete), ('pyapi', Incomplete), ('env_manager', Incomplete), ('is_error', Incomplete)])):
    """
    The facilities required by reflection implementations.
    """
    __slots__: Incomplete
    def set_error(self) -> None: ...
    def box(self, typ, val): ...
    def reflect(self, typ, val): ...

class NativeValue:
    """
    Encapsulate the result of converting a Python object to a native value,
    recording whether the conversion was successful and how to cleanup.
    """
    value: Incomplete
    is_error: Incomplete
    cleanup: Incomplete
    def __init__(self, value, is_error: Incomplete | None = None, cleanup: Incomplete | None = None) -> None: ...

class EnvironmentManager:
    pyapi: Incomplete
    env: Incomplete
    env_body: Incomplete
    env_ptr: Incomplete
    def __init__(self, pyapi, env, env_body, env_ptr) -> None: ...
    def add_const(self, const):
        """
        Add a constant to the environment, return its index.
        """
    def read_const(self, index):
        """
        Look up constant number *index* inside the environment body.
        A borrowed reference is returned.

        The returned LLVM value may have NULL value at runtime which indicates
        an error at runtime.
        """

class _IteratorLoop(NamedTuple):
    value: Incomplete
    do_break: Incomplete

class PythonAPI:
    """
    Code generation facilities to call into the CPython C API (and related
    helpers).
    """
    context: Incomplete
    builder: Incomplete
    module: Incomplete
    pyobj: Incomplete
    pyobjptr: Incomplete
    voidptr: Incomplete
    long: Incomplete
    ulong: Incomplete
    longlong: Incomplete
    ulonglong: Incomplete
    double: Incomplete
    py_ssize_t: Incomplete
    cstring: Incomplete
    gil_state: Incomplete
    py_buffer_t: Incomplete
    py_hash_t: Incomplete
    py_unicode_1byte_kind: Incomplete
    py_unicode_2byte_kind: Incomplete
    py_unicode_4byte_kind: Incomplete
    def __init__(self, context, builder) -> None:
        """
        Note: Maybe called multiple times when lowering a function
        """
    def get_env_manager(self, env, env_body, env_ptr): ...
    def emit_environment_sentry(self, envptr, return_pyobject: bool = False, debug_msg: str = '') -> None:
        """Emits LLVM code to ensure the `envptr` is not NULL
        """
    def incref(self, obj) -> None: ...
    def decref(self, obj) -> None: ...
    def get_type(self, obj): ...
    def parse_tuple_and_keywords(self, args, kws, fmt, keywords, *objs): ...
    def parse_tuple(self, args, fmt, *objs): ...
    def unpack_tuple(self, args, name, n_min, n_max, *objs): ...
    def err_occurred(self): ...
    def err_clear(self): ...
    def err_set_string(self, exctype, msg): ...
    def err_format(self, exctype, msg, *format_args): ...
    def raise_object(self, exc: Incomplete | None = None):
        """
        Raise an arbitrary exception (type or value or (type, args)
        or None - if reraising).  A reference to the argument is consumed.
        """
    def err_set_object(self, exctype, excval): ...
    def err_set_none(self, exctype): ...
    def err_write_unraisable(self, obj): ...
    def err_fetch(self, pty, pval, ptb): ...
    def err_restore(self, ty, val, tb): ...
    def err_push(self, keep_new: bool = False) -> Generator[None]:
        """
        Temporarily push the current error indicator while the code
        block is executed.  If *keep_new* is True and the code block
        raises a new error, the new error is kept, otherwise the old
        error indicator is restored at the end of the block.
        """
    def get_c_object(self, name):
        '''
        Get a Python object through its C-accessible *name*
        (e.g. "PyExc_ValueError").  The underlying variable must be
        a `PyObject *`, and the value of that pointer is returned.
        '''
    def raise_missing_global_error(self, name) -> None: ...
    def raise_missing_name_error(self, name) -> None: ...
    def fatal_error(self, msg) -> None: ...
    def dict_getitem_string(self, dic, name):
        """Lookup name inside dict

        Returns a borrowed reference
        """
    def dict_getitem(self, dic, name):
        """Lookup name inside dict

        Returns a borrowed reference
        """
    def dict_new(self, presize: int = 0): ...
    def dict_setitem(self, dictobj, nameobj, valobj): ...
    def dict_setitem_string(self, dictobj, name, valobj): ...
    def dict_pack(self, keyvalues):
        """
        Args
        -----
        keyvalues: iterable of (str, llvm.Value of PyObject*)
        """
    def float_from_double(self, fval): ...
    def number_as_ssize_t(self, numobj): ...
    def number_long(self, numobj): ...
    def long_as_ulonglong(self, numobj): ...
    def long_as_longlong(self, numobj): ...
    def long_as_voidptr(self, numobj):
        """
        Convert the given Python integer to a void*.  This is recommended
        over number_as_ssize_t as it isn't affected by signedness.
        """
    def _long_from_native_int(self, ival, func_name, native_int_type, signed): ...
    def long_from_long(self, ival): ...
    def long_from_ulong(self, ival): ...
    def long_from_ssize_t(self, ival): ...
    def long_from_longlong(self, ival): ...
    def long_from_ulonglong(self, ival): ...
    def long_from_signed_int(self, ival):
        """
        Return a Python integer from any native integer value.
        """
    def long_from_unsigned_int(self, ival):
        """
        Same as long_from_signed_int, but for unsigned values.
        """
    def _get_number_operator(self, name): ...
    def _call_number_operator(self, name, lhs, rhs, inplace: bool = False): ...
    def number_add(self, lhs, rhs, inplace: bool = False): ...
    def number_subtract(self, lhs, rhs, inplace: bool = False): ...
    def number_multiply(self, lhs, rhs, inplace: bool = False): ...
    def number_truedivide(self, lhs, rhs, inplace: bool = False): ...
    def number_floordivide(self, lhs, rhs, inplace: bool = False): ...
    def number_remainder(self, lhs, rhs, inplace: bool = False): ...
    def number_matrix_multiply(self, lhs, rhs, inplace: bool = False): ...
    def number_lshift(self, lhs, rhs, inplace: bool = False): ...
    def number_rshift(self, lhs, rhs, inplace: bool = False): ...
    def number_and(self, lhs, rhs, inplace: bool = False): ...
    def number_or(self, lhs, rhs, inplace: bool = False): ...
    def number_xor(self, lhs, rhs, inplace: bool = False): ...
    def number_power(self, lhs, rhs, inplace: bool = False): ...
    def number_negative(self, obj): ...
    def number_positive(self, obj): ...
    def number_float(self, val): ...
    def number_invert(self, obj): ...
    def float_as_double(self, fobj): ...
    def bool_from_bool(self, bval):
        """
        Get a Python bool from a LLVM boolean.
        """
    def bool_from_long(self, ival): ...
    def complex_from_doubles(self, realval, imagval): ...
    def complex_real_as_double(self, cobj): ...
    def complex_imag_as_double(self, cobj): ...
    def slice_as_ints(self, obj):
        """
        Read the members of a slice of integers.

        Returns a (ok, start, stop, step) tuple where ok is a boolean and
        the following members are pointer-sized ints.
        """
    def sequence_getslice(self, obj, start, stop): ...
    def sequence_tuple(self, obj): ...
    def sequence_concat(self, obj1, obj2): ...
    def list_new(self, szval): ...
    def list_size(self, lst): ...
    def list_append(self, lst, val): ...
    def list_setitem(self, lst, idx, val):
        """
        Warning: Steals reference to ``val``
        """
    def list_getitem(self, lst, idx):
        """
        Returns a borrowed reference.
        """
    def list_setslice(self, lst, start, stop, obj): ...
    def tuple_getitem(self, tup, idx):
        """
        Borrow reference
        """
    def tuple_pack(self, items): ...
    def tuple_size(self, tup): ...
    def tuple_new(self, count): ...
    def tuple_setitem(self, tuple_val, index, item) -> None:
        """
        Steals a reference to `item`.
        """
    def set_new(self, iterable: Incomplete | None = None): ...
    def set_add(self, set, value): ...
    def set_clear(self, set): ...
    def set_size(self, set): ...
    def set_update(self, set, iterable): ...
    def set_next_entry(self, set, posptr, keyptr, hashptr): ...
    def set_iterate(self, set) -> Generator[Incomplete]: ...
    def gil_ensure(self):
        """
        Ensure the GIL is acquired.
        The returned value must be consumed by gil_release().
        """
    def gil_release(self, gil):
        """
        Release the acquired GIL by gil_ensure().
        Must be paired with a gil_ensure().
        """
    def save_thread(self):
        """
        Release the GIL and return the former thread state
        (an opaque non-NULL pointer).
        """
    def restore_thread(self, thread_state) -> None:
        """
        Restore the given thread state by reacquiring the GIL.
        """
    def object_get_private_data(self, obj): ...
    def object_set_private_data(self, obj, ptr): ...
    def object_reset_private_data(self, obj): ...
    def import_module(self, modname): ...
    def call_function_objargs(self, callee, objargs): ...
    def call_method(self, callee, method, objargs=()): ...
    def call(self, callee, args: Incomplete | None = None, kws: Incomplete | None = None): ...
    def object_type(self, obj):
        """Emit a call to ``PyObject_Type(obj)`` to get the type of ``obj``.
        """
    def object_istrue(self, obj): ...
    def object_not(self, obj): ...
    def object_richcompare(self, lhs, rhs, opstr):
        """
        Refer to Python source Include/object.h for macros definition
        of the opid.
        """
    def iter_next(self, iterobj): ...
    def object_getiter(self, obj): ...
    def object_getattr_string(self, obj, attr): ...
    def object_getattr(self, obj, attr): ...
    def object_setattr_string(self, obj, attr, val): ...
    def object_setattr(self, obj, attr, val): ...
    def object_delattr_string(self, obj, attr): ...
    def object_delattr(self, obj, attr): ...
    def object_getitem(self, obj, key):
        """
        Return obj[key]
        """
    def object_setitem(self, obj, key, val):
        """
        obj[key] = val
        """
    def object_delitem(self, obj, key):
        """
        del obj[key]
        """
    def string_as_string(self, strobj): ...
    def string_as_string_and_size(self, strobj):
        """
        Returns a tuple of ``(ok, buffer, length)``.
        The ``ok`` is i1 value that is set if ok.
        The ``buffer`` is a i8* of the output buffer.
        The ``length`` is a i32/i64 (py_ssize_t) of the length of the buffer.
        """
    def string_as_string_size_and_kind(self, strobj):
        """
        Returns a tuple of ``(ok, buffer, length, kind)``.
        The ``ok`` is i1 value that is set if ok.
        The ``buffer`` is a i8* of the output buffer.
        The ``length`` is a i32/i64 (py_ssize_t) of the length of the buffer.
        The ``kind`` is a i32 (int32) of the Unicode kind constant
        The ``hash`` is a long/uint64_t (py_hash_t) of the Unicode constant hash
        """
    def string_from_string_and_size(self, string, size): ...
    def string_from_string(self, string): ...
    def string_from_kind_and_data(self, kind, string, size): ...
    def bytes_as_string(self, obj): ...
    def bytes_as_string_and_size(self, obj, p_buffer, p_length): ...
    def bytes_from_string_and_size(self, string, size): ...
    def object_hash(self, obj): ...
    def object_str(self, obj): ...
    def make_none(self): ...
    def borrow_none(self): ...
    def sys_write_stdout(self, fmt, *args): ...
    def object_dump(self, obj):
        """
        Dump a Python object on C stderr.  For debugging purposes.
        """
    def nrt_adapt_ndarray_to_python(self, aryty, ary, dtypeptr): ...
    def nrt_meminfo_new_from_pyobject(self, data, pyobj):
        """
        Allocate a new MemInfo with data payload borrowed from a python
        object.
        """
    def nrt_meminfo_as_pyobject(self, miptr): ...
    def nrt_meminfo_from_pyobject(self, miobj): ...
    def nrt_adapt_ndarray_from_python(self, ary, ptr): ...
    def nrt_adapt_buffer_from_python(self, buf, ptr): ...
    def _get_function(self, fnty, name): ...
    def alloca_obj(self): ...
    def alloca_buffer(self):
        """
        Return a pointer to a stack-allocated, zero-initialized Py_buffer.
        """
    def if_object_ok(self, obj) -> Generator[None]: ...
    def print_object(self, obj) -> None: ...
    def print_string(self, text) -> None: ...
    def get_null_object(self): ...
    def return_none(self) -> None: ...
    def list_pack(self, items): ...
    def unserialize(self, structptr):
        """
        Unserialize some data.  *structptr* should be a pointer to
        a {i8* data, i32 length, i8* hashbuf, i8* func_ptr, i32 alloc_flag}
        structure.
        """
    def build_dynamic_excinfo_struct(self, struct_gv, exc_args):
        """
        Serialize some data at runtime. Returns a pointer to a python tuple
        (bytes_data, hash) where the first element is the serialized data as
        bytes and the second its hash.
        """
    def serialize_uncached(self, obj):
        """
        Same as serialize_object(), but don't create a global variable,
        simply return a literal for structure:
        {i8* data, i32 length, i8* hashbuf, i8* func_ptr, i32 alloc_flag}
        """
    def serialize_object(self, obj):
        """
        Serialize the given object in the bitcode, and return it
        as a pointer to a
        {i8* data, i32 length, i8* hashbuf, i8* fn_ptr, i32 alloc_flag},
        structure constant (suitable for passing to unserialize()).
        """
    def c_api_error(self): ...
    def to_native_value(self, typ, obj):
        """
        Unbox the Python object as the given Numba type.
        A NativeValue instance is returned.
        """
    def from_native_return(self, typ, val, env_manager): ...
    def from_native_value(self, typ, val, env_manager: Incomplete | None = None):
        """
        Box the native value of the given Numba type.  A Python object
        pointer is returned (NULL if an error occurred).
        This method steals any native (NRT) reference embedded in *val*.
        """
    def reflect_native_value(self, typ, val, env_manager: Incomplete | None = None):
        """
        Reflect the native value onto its Python original, if any.
        An error bit (as an LLVM value) is returned.
        """
    def to_native_generator(self, obj, typ):
        """
        Extract the generator structure pointer from a generator *obj*
        (a _dynfunc.Generator instance).
        """
    def from_native_generator(self, val, typ, env: Incomplete | None = None):
        """
        Make a Numba generator (a _dynfunc.Generator instance) from a
        generator structure pointer *val*.
        *env* is an optional _dynfunc.Environment instance to be wrapped
        in the generator.
        """
    def numba_array_adaptor(self, ary, ptr): ...
    def numba_buffer_adaptor(self, buf, ptr): ...
    def complex_adaptor(self, cobj, cmplx): ...
    def extract_record_data(self, obj, pbuf): ...
    def get_buffer(self, obj, pbuf): ...
    def release_buffer(self, pbuf): ...
    def extract_np_datetime(self, obj): ...
    def extract_np_timedelta(self, obj): ...
    def create_np_datetime(self, val, unit_code): ...
    def create_np_timedelta(self, val, unit_code): ...
    def recreate_record(self, pdata, size, dtype, env_manager): ...
    def string_from_constant_string(self, string): ...
    def call_jit_code(self, func, sig, args):
        """Calls into Numba jitted code and propagate error using the Python
        calling convention.

        Parameters
        ----------
        func : function
            The Python function to be compiled. This function is compiled
            in nopython-mode.
        sig : numba.typing.Signature
            The function signature for *func*.
        args : Sequence[llvmlite.binding.Value]
            LLVM values to use as arguments.

        Returns
        -------
        (is_error, res) :  2-tuple of llvmlite.binding.Value.
            is_error : true iff *func* raised an exception.
            res : Returned value from *func* iff *is_error* is false.

        If *is_error* is true, this method will adapt the nopython exception
        into a Python exception. Caller should return NULL to Python to
        indicate an error.
        """

class ObjModeUtils:
    """Internal utils for calling objmode dispatcher from within NPM code.
    """
    pyapi: Incomplete
    def __init__(self, pyapi) -> None: ...
    def load_dispatcher(self, fnty, argtypes): ...
    @staticmethod
    def _call_objmode_dispatcher(compile_args): ...
