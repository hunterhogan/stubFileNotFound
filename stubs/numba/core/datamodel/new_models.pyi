from _typeshed import Incomplete
from numba.core import cgutils as cgutils, types as types
from numba.core.datamodel.registry import register_default as register_default
from numba.np import numpy_support as numpy_support

class DataModel:
    '''
    DataModel describe how a FE type is represented in the LLVM IR at
    different contexts.

    Contexts are:

    - value: representation inside function body.  Maybe stored in stack.
    The representation here are flexible.

    - data: representation used when storing into containers (e.g. arrays).

    - argument: representation used for function argument.  All composite
    types are unflattened into multiple primitive types.

    - return: representation used for return argument.

    Throughput the compiler pipeline, a LLVM value is usually passed around
    in the "value" representation.  All "as_" prefix function converts from
    "value" representation.  All "from_" prefix function converts to the
    "value"  representation.

    '''
    _dmm: Incomplete
    _fe_type: Incomplete
    def __init__(self, dmm, fe_type) -> None: ...
    @property
    def fe_type(self): ...
    def get_value_type(self) -> None: ...
    def get_data_type(self): ...
    def get_argument_type(self):
        """Return a LLVM type or nested tuple of LLVM type
        """
    def get_return_type(self): ...
    def as_data(self, builder, value) -> None: ...
    def as_argument(self, builder, value) -> None:
        """
        Takes one LLVM value
        Return a LLVM value or nested tuple of LLVM value
        """
    def as_return(self, builder, value) -> None: ...
    def from_data(self, builder, value) -> None: ...
    def from_argument(self, builder, value) -> None:
        """
        Takes a LLVM value or nested tuple of LLVM value
        Returns one LLVM value
        """
    def from_return(self, builder, value) -> None: ...
    def load_from_data_pointer(self, builder, ptr, align: Incomplete | None = None):
        """
        Load value from a pointer to data.
        This is the default implementation, sufficient for most purposes.
        """
    def traverse(self, builder):
        """
        Traverse contained members.
        Returns a iterable of contained (types, getters).
        Each getter is a one-argument function accepting a LLVM value.
        """
    def traverse_models(self):
        """
        Recursively list all models involved in this model.
        """
    def traverse_types(self):
        """
        Recursively list all frontend types involved in this model.
        """
    def inner_models(self):
        """
        List all *inner* models.
        """
    def get_nrt_meminfo(self, builder, value) -> None:
        """
        Returns the MemInfo object or None if it is not tracked.
        It is only defined for types.meminfo_pointer
        """
    def has_nrt_meminfo(self): ...
    def contains_nrt_meminfo(self):
        """
        Recursively check all contained types for need for NRT meminfo.
        """
    def _compared_fields(self): ...
    def __hash__(self): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...

class OmittedArgDataModel(DataModel):
    '''
    A data model for omitted arguments.  Only the "argument" representation
    is defined, other representations raise a NotImplementedError.
    '''
    def get_value_type(self): ...
    def get_argument_type(self): ...
    def as_argument(self, builder, val): ...
    def from_argument(self, builder, val) -> None: ...

class PrimitiveModel(DataModel):
    """A primitive type can be represented natively in the target in all
    usage contexts.
    """
    be_type: Incomplete
    def __init__(self, dmm, fe_type, be_type) -> None: ...
    def get_value_type(self): ...
    def as_data(self, builder, value): ...
    def as_argument(self, builder, value): ...
    def as_return(self, builder, value): ...
    def from_data(self, builder, value): ...
    def from_argument(self, builder, value): ...
    def from_return(self, builder, value): ...

class ProxyModel(DataModel):
    """
    Helper class for models which delegate to another model.
    """
    def get_value_type(self): ...
    def get_data_type(self): ...
    def get_return_type(self): ...
    def get_argument_type(self): ...
    def as_data(self, builder, value): ...
    def as_argument(self, builder, value): ...
    def as_return(self, builder, value): ...
    def from_data(self, builder, value): ...
    def from_argument(self, builder, value): ...
    def from_return(self, builder, value): ...

class EnumModel(ProxyModel):
    """
    Enum members are represented exactly like their values.
    """
    _proxied_model: Incomplete
    def __init__(self, dmm, fe_type) -> None: ...

class OpaqueModel(PrimitiveModel):
    """
    Passed as opaque pointers
    """
    _ptr_type: Incomplete
    def __init__(self, dmm, fe_type) -> None: ...

class MemInfoModel(OpaqueModel):
    def inner_models(self): ...
    def has_nrt_meminfo(self): ...
    def get_nrt_meminfo(self, builder, value): ...

class PointerModel(PrimitiveModel):
    _pointee_model: Incomplete
    _pointee_be_type: Incomplete
    def __init__(self, dmm, fe_type) -> None: ...

class EphemeralPointerModel(PointerModel):
    def get_data_type(self): ...
    def as_data(self, builder, value): ...
    def from_data(self, builder, value) -> None: ...
    def load_from_data_pointer(self, builder, ptr, align: Incomplete | None = None): ...

class EphemeralArrayModel(PointerModel):
    _data_type: Incomplete
    def __init__(self, dmm, fe_type) -> None: ...
    def get_data_type(self): ...
    def as_data(self, builder, value): ...
    def from_data(self, builder, value) -> None: ...
    def load_from_data_pointer(self, builder, ptr, align: Incomplete | None = None): ...

class ExternalFuncPointerModel(PrimitiveModel):
    def __init__(self, dmm, fe_type) -> None: ...

class UniTupleModel(DataModel):
    _elem_model: Incomplete
    _count: Incomplete
    _value_type: Incomplete
    _data_type: Incomplete
    def __init__(self, dmm, fe_type) -> None: ...
    def get_value_type(self): ...
    def get_data_type(self): ...
    def get_return_type(self): ...
    def get_argument_type(self): ...
    def as_argument(self, builder, value): ...
    def from_argument(self, builder, value): ...
    def as_data(self, builder, value): ...
    def from_data(self, builder, value): ...
    def as_return(self, builder, value): ...
    def from_return(self, builder, value): ...
    def traverse(self, builder): ...
    def inner_models(self): ...

class CompositeModel(DataModel):
    """Any model that is composed of multiple other models should subclass from
    this.
    """

class StructModel(CompositeModel):
    _value_type: Incomplete
    _data_type: Incomplete
    _fields: Incomplete
    _models: Incomplete
    def __init__(self, dmm, fe_type, members) -> None: ...
    def get_member_fe_type(self, name):
        """
        StructModel-specific: get the Numba type of the field named *name*.
        """
    def get_value_type(self): ...
    def get_data_type(self): ...
    def get_argument_type(self): ...
    def get_return_type(self): ...
    def _as(self, methname, builder, value): ...
    def _from(self, methname, builder, value): ...
    def as_data(self, builder, value):
        '''
        Converts the LLVM struct in `value` into a representation suited for
        storing into arrays.

        Note
        ----
        Current implementation rarely changes how types are represented for
        "value" and "data".  This is usually a pointless rebuild of the
        immutable LLVM struct value.  Luckily, LLVM optimization removes all
        redundancy.

        Sample usecase: Structures nested with pointers to other structures
        that can be serialized into  a flat representation when storing into
        array.
        '''
    def from_data(self, builder, value):
        '''
        Convert from "data" representation back into "value" representation.
        Usually invoked when loading from array.

        See notes in `as_data()`
        '''
    def load_from_data_pointer(self, builder, ptr, align: Incomplete | None = None): ...
    def as_argument(self, builder, value): ...
    def from_argument(self, builder, value): ...
    def as_return(self, builder, value): ...
    def from_return(self, builder, value): ...
    def get(self, builder, val, pos):
        """Get a field at the given position or the fieldname

        Args
        ----
        builder:
            LLVM IRBuilder
        val:
            value to be inserted
        pos: int or str
            field index or field name

        Returns
        -------
        Extracted value
        """
    def set(self, builder, stval, val, pos):
        """Set a field at the given position or the fieldname

        Args
        ----
        builder:
            LLVM IRBuilder
        stval:
            LLVM struct value
        val:
            value to be inserted
        pos: int or str
            field index or field name

        Returns
        -------
        A new LLVM struct with the value inserted
        """
    def get_field_position(self, field): ...
    @property
    def field_count(self): ...
    def get_type(self, pos):
        """Get the frontend type (numba type) of a field given the position
         or the fieldname

        Args
        ----
        pos: int or str
            field index or field name
        """
    def get_model(self, pos):
        """
        Get the datamodel of a field given the position or the fieldname.

        Args
        ----
        pos: int or str
            field index or field name
        """
    def traverse(self, builder): ...
    def inner_models(self): ...

class BooleanModel(DataModel):
    _bit_type: Incomplete
    _byte_type: Incomplete
    def get_value_type(self): ...
    def get_data_type(self): ...
    def get_return_type(self): ...
    def get_argument_type(self): ...
    def as_data(self, builder, value): ...
    def as_argument(self, builder, value): ...
    def as_return(self, builder, value): ...
    def from_data(self, builder, value): ...
    def from_argument(self, builder, value): ...
    def from_return(self, builder, value): ...

class IntegerModel(PrimitiveModel):
    def __init__(self, dmm, fe_type) -> None: ...

class FloatModel(PrimitiveModel):
    def __init__(self, dmm, fe_type) -> None: ...

class ComplexModel(StructModel):
    _element_type = NotImplemented
    def __init__(self, dmm, fe_type) -> None: ...

class TupleModel(StructModel):
    def __init__(self, dmm, fe_type) -> None: ...

class UnionModel(StructModel):
    def __init__(self, dmm, fe_type) -> None: ...

class PairModel(StructModel):
    def __init__(self, dmm, fe_type) -> None: ...

class ListPayloadModel(StructModel):
    def __init__(self, dmm, fe_type) -> None: ...

class ListModel(StructModel):
    def __init__(self, dmm, fe_type) -> None: ...

class ListIterModel(StructModel):
    def __init__(self, dmm, fe_type) -> None: ...

class SetEntryModel(StructModel):
    def __init__(self, dmm, fe_type) -> None: ...

class SetPayloadModel(StructModel):
    def __init__(self, dmm, fe_type) -> None: ...

class SetModel(StructModel):
    def __init__(self, dmm, fe_type) -> None: ...

class SetIterModel(StructModel):
    def __init__(self, dmm, fe_type) -> None: ...

class ArrayModel(StructModel):
    def __init__(self, dmm, fe_type) -> None: ...

class ArrayFlagsModel(StructModel):
    def __init__(self, dmm, fe_type) -> None: ...

class NestedArrayModel(ArrayModel):
    _be_type: Incomplete
    def __init__(self, dmm, fe_type) -> None: ...
    def as_storage_type(self):
        """Return the LLVM type representation for the storage of
        the nestedarray.
        """

class OptionalModel(StructModel):
    _value_model: Incomplete
    def __init__(self, dmm, fe_type) -> None: ...
    def get_return_type(self): ...
    def as_return(self, builder, value) -> None: ...
    def from_return(self, builder, value): ...
    def traverse(self, builder): ...

class RecordModel(CompositeModel):
    _models: Incomplete
    _be_type: Incomplete
    _be_ptr_type: Incomplete
    def __init__(self, dmm, fe_type) -> None: ...
    def get_value_type(self):
        """Passed around as reference to underlying data
        """
    def get_argument_type(self): ...
    def get_return_type(self): ...
    def get_data_type(self): ...
    def as_data(self, builder, value): ...
    def from_data(self, builder, value) -> None: ...
    def as_argument(self, builder, value): ...
    def from_argument(self, builder, value): ...
    def as_return(self, builder, value): ...
    def from_return(self, builder, value): ...
    def load_from_data_pointer(self, builder, ptr, align: Incomplete | None = None): ...

class UnicodeCharSeq(DataModel):
    _be_type: Incomplete
    def __init__(self, dmm, fe_type) -> None: ...
    def get_value_type(self): ...
    def get_data_type(self): ...
    def as_data(self, builder, value): ...
    def from_data(self, builder, value): ...
    def as_return(self, builder, value): ...
    def from_return(self, builder, value): ...
    def as_argument(self, builder, value): ...
    def from_argument(self, builder, value): ...

class CharSeq(DataModel):
    _be_type: Incomplete
    def __init__(self, dmm, fe_type) -> None: ...
    def get_value_type(self): ...
    def get_data_type(self): ...
    def as_data(self, builder, value): ...
    def from_data(self, builder, value): ...
    def as_return(self, builder, value): ...
    def from_return(self, builder, value): ...
    def as_argument(self, builder, value): ...
    def from_argument(self, builder, value): ...

class CContiguousFlatIter(StructModel):
    def __init__(self, dmm, fe_type, need_indices) -> None: ...

class FlatIter(StructModel):
    def __init__(self, dmm, fe_type) -> None: ...

class UniTupleIter(StructModel):
    def __init__(self, dmm, fe_type) -> None: ...

class SliceModel(StructModel):
    def __init__(self, dmm, fe_type) -> None: ...

class NPDatetimeModel(PrimitiveModel):
    def __init__(self, dmm, fe_type) -> None: ...

class ArrayIterator(StructModel):
    def __init__(self, dmm, fe_type) -> None: ...

class EnumerateType(StructModel):
    def __init__(self, dmm, fe_type) -> None: ...

class ZipType(StructModel):
    def __init__(self, dmm, fe_type) -> None: ...

class RangeIteratorType(StructModel):
    def __init__(self, dmm, fe_type) -> None: ...

class GeneratorModel(CompositeModel):
    _arg_models: Incomplete
    _state_models: Incomplete
    _args_be_type: Incomplete
    _state_be_type: Incomplete
    _be_type: Incomplete
    _be_ptr_type: Incomplete
    def __init__(self, dmm, fe_type) -> None: ...
    def get_value_type(self):
        """
        The generator closure is passed around as a reference.
        """
    def get_argument_type(self): ...
    def get_return_type(self): ...
    def get_data_type(self): ...
    def as_argument(self, builder, value): ...
    def from_argument(self, builder, value): ...
    def as_return(self, builder, value): ...
    def from_return(self, builder, value): ...
    def as_data(self, builder, value): ...
    def from_data(self, builder, value): ...

class ArrayCTypesModel(StructModel):
    def __init__(self, dmm, fe_type) -> None: ...

class RangeModel(StructModel):
    def __init__(self, dmm, fe_type) -> None: ...

class NdIndexModel(StructModel):
    def __init__(self, dmm, fe_type) -> None: ...

def handle_numpy_flat_type(dmm, ty): ...
def handle_numpy_ndenumerate_type(dmm, ty): ...
def handle_bound_function(dmm, ty): ...

class NdIter(StructModel):
    def __init__(self, dmm, fe_type) -> None: ...

class DeferredStructModel(CompositeModel):
    typename: Incomplete
    actual_fe_type: Incomplete
    def __init__(self, dmm, fe_type) -> None: ...
    def get_value_type(self): ...
    def get_data_type(self): ...
    def get_argument_type(self): ...
    def as_argument(self, builder, value): ...
    def from_argument(self, builder, value): ...
    def from_data(self, builder, value): ...
    def as_data(self, builder, value): ...
    def from_return(self, builder, value): ...
    def as_return(self, builder, value): ...
    def get(self, builder, value): ...
    def set(self, builder, value, content): ...
    def make_uninitialized(self, kind: str = 'value'): ...
    def _define(self) -> None: ...
    def _define_value_type(self, value_type) -> None: ...
    def _define_data_type(self, data_type) -> None: ...
    @property
    def _actual_model(self): ...
    def traverse(self, builder): ...

class StructPayloadModel(StructModel):
    """Model for the payload of a mutable struct
    """
    def __init__(self, dmm, fe_typ) -> None: ...

class StructRefModel(StructModel):
    """Model for a mutable struct.
    A reference to the payload
    """
    def __init__(self, dmm, fe_typ) -> None: ...
