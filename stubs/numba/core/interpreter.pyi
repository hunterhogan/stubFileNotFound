from _typeshed import Incomplete
from collections.abc import Generator
from numba.core import config as config, errors as errors, ir as ir
from numba.core.byteflow import AdaptCFA as AdaptCFA, AdaptDFA as AdaptDFA, BlockKind as BlockKind, Flow as Flow
from numba.core.errors import NotDefinedError as NotDefinedError, UnsupportedBytecodeError as UnsupportedBytecodeError, error_extras as error_extras
from numba.core.ir_utils import get_definition as get_definition, guard as guard
from numba.core.utils import BINOPS_TO_OPERATORS as BINOPS_TO_OPERATORS, INPLACE_BINOPS_TO_OPERATORS as INPLACE_BINOPS_TO_OPERATORS, PYVERSION as PYVERSION

class _UNKNOWN_VALUE:
    """Represents an unknown value, this is for ease of debugging purposes only.
    """
    _varname: Incomplete
    def __init__(self, varname) -> None: ...
    def __repr__(self) -> str: ...

_logger: Incomplete

class Assigner:
    """
    This object keeps track of potential assignment simplifications
    inside a code block.
    For example `$O.1 = x` followed by `y = $0.1` can be simplified
    into `y = x`, but it's not possible anymore if we have `x = z`
    in-between those two instructions.

    NOTE: this is not only an optimization, but is actually necessary
    due to certain limitations of Numba - such as only accepting the
    returning of an array passed as function argument.
    """
    dest_to_src: Incomplete
    src_invalidate: Incomplete
    unused_dests: Incomplete
    def __init__(self) -> None: ...
    def assign(self, srcvar, destvar):
        """
        Assign *srcvar* to *destvar*. Return either *srcvar* or a possible
        simplified assignment source (earlier assigned to *srcvar*).
        """
    def get_assignment_source(self, destname):
        """
        Get a possible assignment source (a ir.Var instance) to replace
        *destname*, otherwise None.
        """

def _remove_assignment_definition(old_body, idx, func_ir, already_deleted_defs) -> None:
    """
    Deletes the definition defined for old_body at index idx
    from func_ir. We assume this stmt will be deleted from
    new_body.

    In some optimizations we may update the same variable multiple times.
    In this situation, we only need to delete a particular definition once,
    this is tracked in already_deleted_def, which is a map from
    assignment name to the set of values that have already been
    deleted.
    """
def _call_function_ex_replace_kws_small(old_body, keyword_expr, new_body, buildmap_idx, func_ir, already_deleted_defs):
    """
    Extracts the kws args passed as varkwarg
    for CALL_FUNCTION_EX. This pass is taken when
    n_kws <= 15 and the bytecode looks like:

        # Start for each argument
        LOAD_FAST  # Load each argument.
        # End for each argument
        ...
        BUILD_CONST_KEY_MAP # Build a map

    In the generated IR, the varkwarg refers
    to a single build_map that contains all of the
    kws. In addition to returning the kws, this
    function updates new_body to remove all usage
    of the map.
    """
def _call_function_ex_replace_kws_large(old_body, buildmap_name, buildmap_idx, search_end, new_body, func_ir, errmsg, already_deleted_defs):
    """
    Extracts the kws args passed as varkwarg
    for CALL_FUNCTION_EX. This pass is taken when
    n_kws > 15 and the bytecode looks like:

        BUILD_MAP # Construct the map
        # Start for each argument
        LOAD_CONST # Load a constant for the name of the argument
        LOAD_FAST  # Load each argument.
        MAP_ADD # Append the (key, value) pair to the map
        # End for each argument

    In the IR generated, the initial build map is empty and a series
    of setitems are applied afterwards. THE IR looks like:

        $build_map_var = build_map(items=[])
        $constvar = const(str, ...) # create the const key
        # CREATE THE ARGUMENT, This may take multiple lines.
        $created_arg = ...
        $var = getattr(
            value=$build_map_var,
            attr=__setitem__,
        )
        $unused_var = call $var($constvar, $created_arg)

    We iterate through the IR, deleting all usages of the buildmap
    from the new_body, and adds the kws to a new kws list.
    """
def _call_function_ex_replace_args_small(old_body, tuple_expr, new_body, buildtuple_idx, func_ir, already_deleted_defs):
    """
    Extracts the args passed as vararg
    for CALL_FUNCTION_EX. This pass is taken when
    n_args <= 30 and the bytecode looks like:

        # Start for each argument
        LOAD_FAST  # Load each argument.
        # End for each argument
        ...
        BUILD_TUPLE # Create a tuple of the arguments

    In the IR generated, the vararg refer
    to a single build_tuple that contains all of the
    args. In addition to returning the args, this
    function updates new_body to remove all usage
    of the tuple.
    """
def _call_function_ex_replace_args_large(old_body, vararg_stmt, new_body, search_end, func_ir, errmsg, already_deleted_defs):
    """
    Extracts the args passed as vararg
    for CALL_FUNCTION_EX. This pass is taken when
    n_args > 30 and the bytecode looks like:

        BUILD_TUPLE # Create a list to append to
        # Start for each argument
        LOAD_FAST  # Load each argument.
        LIST_APPEND # Add the argument to the list
        # End for each argument
        ...
        LIST_TO_TUPLE # Convert the args to a tuple.

    In the IR generated, the tuple is created by concatenating
    together several 1 element tuples to an initial empty tuple.
    We traverse backwards in the IR, collecting args, until we
    find the original empty tuple. For example, the IR might
    look like:

        $orig_tuple = build_tuple(items=[])
        $first_var = build_tuple(items=[Var(arg0, test.py:6)])
        $next_tuple = $orig_tuple + $first_var
        ...
        $final_var = build_tuple(items=[Var(argn, test.py:6)])
        $final_tuple = $prev_tuple + $final_var
        $varargs_var = $final_tuple
    """
def peep_hole_call_function_ex_to_call_function_kw(func_ir):
    """
    This peephole rewrites a bytecode sequence unique to Python 3.10
    where CALL_FUNCTION_EX is used instead of CALL_FUNCTION_KW because of
    stack limitations set by CPython. This limitation is imposed whenever
    a function call has too many arguments or keyword arguments.

    https://github.com/python/cpython/blob/a58ebcc701dd6c43630df941481475ff0f615a81/Python/compile.c#L55
    https://github.com/python/cpython/blob/a58ebcc701dd6c43630df941481475ff0f615a81/Python/compile.c#L4442

    In particular, this change is imposed whenever (n_args / 2) + n_kws > 15.

    Different bytecode is generated for args depending on if n_args > 30
    or n_args <= 30 and similarly if n_kws > 15 or n_kws <= 15.

    This function unwraps the *args and **kwargs in the function call
    and places these values directly into the args and kwargs of the call.
    """
def peep_hole_list_to_tuple(func_ir):
    '''
    This peephole rewrites a bytecode sequence new to Python 3.9 that looks
    like e.g.:

    def foo(a):
        return (*a,)

    41          0 BUILD_LIST               0
                2 LOAD_FAST                0 (a)
                4 LIST_EXTEND              1
                6 LIST_TO_TUPLE
                8 RETURN_VAL

    essentially, the unpacking of tuples is written as a list which is appended
    to/extended and then "magicked" into a tuple by the new LIST_TO_TUPLE
    opcode.

    This peephole repeatedly analyses the bytecode in a block looking for a
    window between a `LIST_TO_TUPLE` and `BUILD_LIST` and...

    1. Turns the BUILD_LIST into a BUILD_TUPLE
    2. Sets an accumulator\'s initial value as the target of the BUILD_TUPLE
    3. Searches for \'extend\' on the original list and turns these into binary
       additions on the accumulator.
    4. Searches for \'append\' on the original list and turns these into a
       `BUILD_TUPLE` which is then appended via binary addition to the
       accumulator.
    5. Assigns the accumulator to the variable that exits the peephole and the
       rest of the block/code refers to as the result of the unpack operation.
    6. Patches up
    '''
def peep_hole_delete_with_exit(func_ir):
    """
    This rewrite removes variables used to store the `__exit__` function
    loaded by SETUP_WITH.
    """
def peep_hole_fuse_dict_add_updates(func_ir):
    """
    This rewrite removes d1._update_from_bytecode(d2)
    calls that are between two dictionaries, d1 and d2,
    in the same basic block. This pattern can appear as a
    result of Python 3.10 bytecode emission changes, which
    prevent large constant literal dictionaries
    (> 15 elements) from being constant. If both dictionaries
    are constant dictionaries defined in the same block and
    neither is used between the update call, then we replace d1
    with a new definition that combines the two dictionaries. At
    the bytecode translation stage we convert DICT_UPDATE into
    _update_from_bytecode, so we know that _update_from_bytecode
    always comes from the bytecode change and not user code.

    Python 3.10 may also rewrite the individual dictionaries
    as an empty build_map + many map_add. Here we again look
    for an _update_from_bytecode, and if so we replace these
    with a single constant dictionary.

    When running this algorithm we can always safely remove d2.

    This is the relevant section of the CPython 3.10 that causes
    this bytecode change:
    https://github.com/python/cpython/blob/3.10/Python/compile.c#L4048
    """
def peep_hole_split_at_pop_block(func_ir):
    """
    Split blocks that contain ir.PopBlock.

    This rewrite restores the IR structure to pre 3.11 so that withlifting
    can work correctly.
    """
def _build_new_build_map(func_ir, name, old_body, old_lineno, new_items):
    """
    Create a new build_map with a new set of key/value items
    but all the other info the same.
    """

class Interpreter:
    """A bytecode interpreter that builds up the IR.
    """
    _DEBUG_PRINT: bool
    func_id: Incomplete
    arg_count: Incomplete
    arg_names: Incomplete
    loc: Incomplete
    is_generator: Incomplete
    blocks: Incomplete
    definitions: Incomplete
    _exception_vars: Incomplete
    def __init__(self, func_id) -> None: ...
    bytecode: Incomplete
    scopes: Incomplete
    dfa: Incomplete
    cfa: Incomplete
    current_block: Incomplete
    current_block_offset: Incomplete
    last_active_offset: Incomplete
    active_exception_entries: Incomplete
    syntax_blocks: Incomplete
    dfainfo: Incomplete
    def interpret(self, bytecode):
        """
        Generate IR for this bytecode.
        """
    def post_process(self, peepholes, func_ir): ...
    def _end_try_blocks(self):
        """Closes all try blocks by inserting the required marker at the
        exception handler

        This is only needed for py3.11 because of the changes in exception
        handling. This merely maps the new py3.11 semantics back to the old way.

        What the code does:

        - For each block, compute the difference of blockstack to its incoming
          blocks' blockstack.
        - If the incoming blockstack has an extra TRY, the current block must
          be the EXCEPT block and we need to insert a marker.

        See also: _insert_try_block_end
        """
    def _legalize_exception_vars(self):
        """Search for unsupported use of exception variables.
        Note, they cannot be stored into user variable.
        """
    def init_first_block(self) -> None: ...
    def _iter_inst(self) -> Generator[Incomplete]: ...
    assigner: Incomplete
    def _start_new_block(self, offset) -> None: ...
    def _end_current_block(self) -> None: ...
    def _inject_call(self, func, gv_name, res_name: Incomplete | None = None) -> None:
        """A helper function to inject a call to *func* which is a python
        function.
        Parameters
        ----------
        func : callable
            The function object to be called.
        gv_name : str
            The variable name to be used to store the function object.
        res_name : str; optional
            The variable name to be used to store the call result.
            If ``None``, a name is created automatically.
        """
    def _insert_try_block_begin(self) -> None:
        """Insert IR-nodes to mark the start of a `try` block.
        """
    def _insert_try_block_end(self) -> None:
        """Insert IR-nodes to mark the end of a `try` block.
        """
    def _insert_exception_variables(self) -> None:
        """Insert IR-nodes to initialize the exception variables.
        """
    def _insert_exception_check(self) -> None:
        """Called before the end of a block to inject checks if raised.
        """
    def _remove_unused_temporaries(self) -> None:
        """
        Remove assignments to unused temporary variables from the
        current block.
        """
    def _var_used_in_binop(self, varname, expr):
        """return True if 'expr' is a binary expression and 'varname' is used
        in it as an argument
        """
    def _insert_outgoing_phis(self) -> None:
        """
        Add assignments to forward requested outgoing values
        to subsequent blocks.
        """
    def get_global_value(self, name):
        """
        Get a global value from the func_global (first) or
        as a builtins (second).  If both failed, return a ir.UNDEFINED.
        """
    def get_closure_value(self, index):
        """
        Get a value from the cell contained in this function's closure.
        If not set, return a ir.UNDEFINED.
        """
    @property
    def current_scope(self): ...
    @property
    def code_consts(self): ...
    @property
    def code_locals(self): ...
    @property
    def code_names(self): ...
    @property
    def code_cellvars(self): ...
    @property
    def code_freevars(self): ...
    def _dispatch(self, inst, kws): ...
    def store(self, value, name, redefine: bool = False):
        """
        Store *value* (a Expr or Var instance) into the variable named *name*
        (a str object). Returns the target variable.
        """
    def get(self, name):
        """
        Get the variable (a Var instance) with the given *name*.
        """
    def insert_block(self, offset, scope: Incomplete | None = None, loc: Incomplete | None = None): ...
    def op_NOP(self, inst) -> None: ...
    def op_RESUME(self, inst) -> None: ...
    def op_CACHE(self, inst) -> None: ...
    def op_PRECALL(self, inst) -> None: ...
    def op_PUSH_NULL(self, inst) -> None: ...
    def op_RETURN_GENERATOR(self, inst) -> None: ...
    def op_PRINT_ITEM(self, inst, item, printvar, res) -> None: ...
    def op_PRINT_NEWLINE(self, inst, printvar, res) -> None: ...
    def op_UNPACK_SEQUENCE(self, inst, iterable, stores, tupleobj) -> None: ...
    def op_FORMAT_SIMPLE(self, inst, value, res, strvar): ...
    def op_FORMAT_VALUE(self, inst, value, res, strvar) -> None:
        """
        FORMAT_VALUE(flags): flags argument specifies format spec which is not
        supported yet. Currently, str() is simply called on the value.
        https://docs.python.org/3/library/dis.html#opcode-FORMAT_VALUE
        """
    def op_BUILD_STRING(self, inst, strings, tmps) -> None:
        """
        BUILD_STRING(count): Concatenates count strings.
        Required for supporting f-strings.
        https://docs.python.org/3/library/dis.html#opcode-BUILD_STRING
        """
    def op_BUILD_SLICE(self, inst, start, stop, step, res, slicevar) -> None: ...
    def op_BINARY_SLICE(self, inst, start, end, container, res, slicevar, temp_res) -> None: ...
    def op_STORE_SLICE(self, inst, start, end, container, value, res, slicevar) -> None: ...
    def op_SLICE_0(self, inst, base, res, slicevar, indexvar, nonevar) -> None: ...
    def op_SLICE_1(self, inst, base, start, nonevar, res, slicevar, indexvar) -> None: ...
    def op_SLICE_2(self, inst, base, nonevar, stop, res, slicevar, indexvar) -> None: ...
    def op_SLICE_3(self, inst, base, start, stop, res, slicevar, indexvar) -> None: ...
    def op_STORE_SLICE_0(self, inst, base, value, slicevar, indexvar, nonevar) -> None: ...
    def op_STORE_SLICE_1(self, inst, base, start, nonevar, value, slicevar, indexvar) -> None: ...
    def op_STORE_SLICE_2(self, inst, base, nonevar, stop, value, slicevar, indexvar) -> None: ...
    def op_STORE_SLICE_3(self, inst, base, start, stop, value, slicevar, indexvar) -> None: ...
    def op_DELETE_SLICE_0(self, inst, base, slicevar, indexvar, nonevar) -> None: ...
    def op_DELETE_SLICE_1(self, inst, base, start, nonevar, slicevar, indexvar) -> None: ...
    def op_DELETE_SLICE_2(self, inst, base, nonevar, stop, slicevar, indexvar) -> None: ...
    def op_DELETE_SLICE_3(self, inst, base, start, stop, slicevar, indexvar) -> None: ...
    def _op_LOAD_FAST(self, inst, res) -> None: ...
    def op_LOAD_FAST(self, inst, res, as_load_deref: bool = False) -> None: ...
    op_LOAD_FAST = _op_LOAD_FAST
    def op_LOAD_FAST_LOAD_FAST(self, inst, res1, res2) -> None: ...
    def op_STORE_FAST_LOAD_FAST(self, inst, store_value, load_res) -> None: ...
    def op_STORE_FAST_STORE_FAST(self, inst, value1, value2) -> None: ...
    op_LOAD_FAST_CHECK = op_LOAD_FAST
    def op_LOAD_FAST_AND_CLEAR(self, inst, res) -> None: ...
    def op_STORE_FAST(self, inst, value) -> None: ...
    def op_DELETE_FAST(self, inst) -> None: ...
    def op_DUP_TOPX(self, inst, orig, duped) -> None: ...
    op_DUP_TOP = op_DUP_TOPX
    op_DUP_TOP_TWO = op_DUP_TOPX
    def op_STORE_ATTR(self, inst, target, value) -> None: ...
    def op_DELETE_ATTR(self, inst, target) -> None: ...
    def op_LOAD_ATTR(self, inst, item, res) -> None: ...
    def op_LOAD_CONST(self, inst, res) -> None: ...
    def op_LOAD_GLOBAL(self, inst, idx, res) -> None: ...
    def op_LOAD_GLOBAL(self, inst, res) -> None: ...
    def op_COPY_FREE_VARS(self, inst) -> None: ...
    def op_LOAD_DEREF(self, inst, res) -> None: ...
    def op_LOAD_DEREF(self, inst, res) -> None: ...
    def op_MAKE_CELL(self, inst) -> None: ...
    def op_STORE_DEREF(self, inst, value) -> None: ...
    def op_STORE_DEREF(self, inst, value) -> None: ...
    def op_SETUP_LOOP(self, inst) -> None: ...
    def op_SETUP_WITH(self, inst, contextmanager, exitfn: Incomplete | None = None) -> None: ...
    def op_BEFORE_WITH(self, inst, contextmanager, exitfn, end) -> None: ...
    def op_SETUP_FINALLY(self, inst) -> None: ...
    def op_WITH_CLEANUP(self, inst) -> None:
        """no-op"""
    def op_WITH_CLEANUP_START(self, inst) -> None:
        """no-op"""
    def op_WITH_CLEANUP_FINISH(self, inst) -> None:
        """no-op"""
    def op_END_FINALLY(self, inst) -> None:
        """no-op"""
    def op_BEGIN_FINALLY(self, inst, temps) -> None: ...
    def op_CALL(self, inst, func, args, kw_names, res) -> None: ...
    def op_CALL_KW(self, inst, func, args, kw_names, res) -> None: ...
    def op_CALL_FUNCTION(self, inst, func, args, res) -> None: ...
    def op_CALL_FUNCTION_KW(self, inst, func, args, names, res) -> None: ...
    def op_CALL_FUNCTION_EX(self, inst, func, vararg, varkwarg, res) -> None: ...
    def _build_tuple_unpack(self, inst, tuples, temps, is_assign) -> None: ...
    def op_BUILD_TUPLE_UNPACK_WITH_CALL(self, inst, tuples, temps, is_assign) -> None: ...
    def op_BUILD_TUPLE_UNPACK(self, inst, tuples, temps, is_assign) -> None: ...
    def op_LIST_TO_TUPLE(self, inst, const_list, res) -> None: ...
    def op_BUILD_CONST_KEY_MAP(self, inst, keys, keytmps, values, res): ...
    def op_GET_ITER(self, inst, value, res) -> None: ...
    def op_FOR_ITER(self, inst, iterator, pair, indval, pred) -> None:
        """
        Assign new block other this instruction.
        """
    def op_BINARY_SUBSCR(self, inst, target, index, res) -> None: ...
    def op_STORE_SUBSCR(self, inst, target, index, value) -> None: ...
    def op_DELETE_SUBSCR(self, inst, target, index) -> None: ...
    def op_BUILD_TUPLE(self, inst, items, res) -> None: ...
    def op_BUILD_LIST(self, inst, items, res) -> None: ...
    def op_BUILD_SET(self, inst, items, res) -> None: ...
    def op_SET_UPDATE(self, inst, target, value, updatevar, res) -> None: ...
    def op_DICT_UPDATE(self, inst, target, value, updatevar, res) -> None: ...
    def op_BUILD_MAP(self, inst, items, size, res): ...
    def op_STORE_MAP(self, inst, dct, key, value) -> None: ...
    def op_UNARY_NEGATIVE(self, inst, value, res): ...
    def op_UNARY_POSITIVE(self, inst, value, res): ...
    def op_UNARY_INVERT(self, inst, value, res): ...
    def op_UNARY_NOT(self, inst, value, res): ...
    def _binop(self, op, lhs, rhs, res) -> None: ...
    def _inplace_binop(self, op, lhs, rhs, res) -> None: ...
    def op_BINARY_OP(self, inst, op, lhs, rhs, res) -> None: ...
    def op_BINARY_ADD(self, inst, lhs, rhs, res) -> None: ...
    def op_BINARY_SUBTRACT(self, inst, lhs, rhs, res) -> None: ...
    def op_BINARY_MULTIPLY(self, inst, lhs, rhs, res) -> None: ...
    def op_BINARY_DIVIDE(self, inst, lhs, rhs, res) -> None: ...
    def op_BINARY_TRUE_DIVIDE(self, inst, lhs, rhs, res) -> None: ...
    def op_BINARY_FLOOR_DIVIDE(self, inst, lhs, rhs, res) -> None: ...
    def op_BINARY_MODULO(self, inst, lhs, rhs, res) -> None: ...
    def op_BINARY_POWER(self, inst, lhs, rhs, res) -> None: ...
    def op_BINARY_MATRIX_MULTIPLY(self, inst, lhs, rhs, res) -> None: ...
    def op_BINARY_LSHIFT(self, inst, lhs, rhs, res) -> None: ...
    def op_BINARY_RSHIFT(self, inst, lhs, rhs, res) -> None: ...
    def op_BINARY_AND(self, inst, lhs, rhs, res) -> None: ...
    def op_BINARY_OR(self, inst, lhs, rhs, res) -> None: ...
    def op_BINARY_XOR(self, inst, lhs, rhs, res) -> None: ...
    def op_INPLACE_ADD(self, inst, lhs, rhs, res) -> None: ...
    def op_INPLACE_SUBTRACT(self, inst, lhs, rhs, res) -> None: ...
    def op_INPLACE_MULTIPLY(self, inst, lhs, rhs, res) -> None: ...
    def op_INPLACE_DIVIDE(self, inst, lhs, rhs, res) -> None: ...
    def op_INPLACE_TRUE_DIVIDE(self, inst, lhs, rhs, res) -> None: ...
    def op_INPLACE_FLOOR_DIVIDE(self, inst, lhs, rhs, res) -> None: ...
    def op_INPLACE_MODULO(self, inst, lhs, rhs, res) -> None: ...
    def op_INPLACE_POWER(self, inst, lhs, rhs, res) -> None: ...
    def op_INPLACE_MATRIX_MULTIPLY(self, inst, lhs, rhs, res) -> None: ...
    def op_INPLACE_LSHIFT(self, inst, lhs, rhs, res) -> None: ...
    def op_INPLACE_RSHIFT(self, inst, lhs, rhs, res) -> None: ...
    def op_INPLACE_AND(self, inst, lhs, rhs, res) -> None: ...
    def op_INPLACE_OR(self, inst, lhs, rhs, res) -> None: ...
    def op_INPLACE_XOR(self, inst, lhs, rhs, res) -> None: ...
    def op_JUMP_ABSOLUTE(self, inst) -> None: ...
    def op_JUMP_FORWARD(self, inst) -> None: ...
    def op_JUMP_BACKWARD(self, inst) -> None: ...
    op_JUMP_BACKWARD_NO_INTERRUPT = op_JUMP_BACKWARD
    def op_POP_BLOCK(self, inst, kind: Incomplete | None = None) -> None: ...
    def op_RETURN_VALUE(self, inst, retval, castval) -> None: ...
    def op_RETURN_CONST(self, inst, retval, castval) -> None: ...
    def op_TO_BOOL(self, inst, val, res) -> None: ...
    def op_COMPARE_OP(self, inst, lhs, rhs, res) -> None: ...
    def op_IS_OP(self, inst, lhs, rhs, res) -> None: ...
    def op_CONTAINS_OP(self, inst, lhs, rhs, res) -> None: ...
    def op_BREAK_LOOP(self, inst, end: Incomplete | None = None) -> None: ...
    def _op_JUMP_IF(self, inst, pred, iftrue) -> None: ...
    def op_JUMP_IF_FALSE(self, inst, pred) -> None: ...
    def op_JUMP_IF_TRUE(self, inst, pred) -> None: ...
    def _jump_if_none(self, inst, pred, iftrue) -> None: ...
    def op_POP_JUMP_FORWARD_IF_NONE(self, inst, pred) -> None: ...
    def op_POP_JUMP_FORWARD_IF_NOT_NONE(self, inst, pred) -> None: ...
    def op_POP_JUMP_IF_NONE(self, inst, pred) -> None: ...
    def op_POP_JUMP_IF_NOT_NONE(self, inst, pred) -> None: ...
    def op_POP_JUMP_BACKWARD_IF_NONE(self, inst, pred) -> None: ...
    def op_POP_JUMP_BACKWARD_IF_NOT_NONE(self, inst, pred) -> None: ...
    def op_POP_JUMP_FORWARD_IF_FALSE(self, inst, pred) -> None: ...
    def op_POP_JUMP_FORWARD_IF_TRUE(self, inst, pred) -> None: ...
    def op_POP_JUMP_BACKWARD_IF_FALSE(self, inst, pred) -> None: ...
    def op_POP_JUMP_BACKWARD_IF_TRUE(self, inst, pred) -> None: ...
    def op_POP_JUMP_IF_FALSE(self, inst, pred) -> None: ...
    def op_POP_JUMP_IF_TRUE(self, inst, pred) -> None: ...
    def op_JUMP_IF_FALSE_OR_POP(self, inst, pred) -> None: ...
    def op_JUMP_IF_TRUE_OR_POP(self, inst, pred) -> None: ...
    def op_CHECK_EXC_MATCH(self, inst, pred, tos, tos1) -> None: ...
    def op_JUMP_IF_NOT_EXC_MATCH(self, inst, pred, tos, tos1) -> None: ...
    def op_RERAISE(self, inst, exc) -> None: ...
    def op_RAISE_VARARGS(self, inst, exc) -> None: ...
    def op_YIELD_VALUE(self, inst, value, res): ...
    def op_MAKE_FUNCTION(self, inst, name, code, closure, annotations, kwdefaults, defaults, res) -> None: ...
    def op_MAKE_CLOSURE(self, inst, name, code, closure, annotations, kwdefaults, defaults, res) -> None: ...
    def op_LOAD_CLOSURE(self, inst, res) -> None: ...
    def op_LOAD_CLOSURE(self, inst, res) -> None: ...
    def op_LIST_APPEND(self, inst, target, value, appendvar, res) -> None: ...
    def op_LIST_EXTEND(self, inst, target, value, extendvar, res) -> None: ...
    def op_MAP_ADD(self, inst, target, key, value, setitemvar, res) -> None: ...
    def op_LOAD_ASSERTION_ERROR(self, inst, res) -> None: ...
    def op_LOAD_METHOD(self, *args, **kws) -> None: ...
    def op_CALL_METHOD(self, *args, **kws) -> None: ...
    def op_CALL_INTRINSIC_1(self, inst, operand, **kwargs) -> None: ...

class INTRINSIC_STOPITERATION_ERROR(AssertionError): ...
