from _typeshed import Incomplete
from numba import cuda as cuda
from numba.core import cgutils as cgutils, targetconfig as targetconfig, types as types, typing as typing
from numba.core.imputils import Registry as Registry
from numba.cuda import libdevice as libdevice
from numba.types import float32 as float32, float64 as float64, int64 as int64, uint64 as uint64

registry: Incomplete
lower: Incomplete
booleans: Incomplete
unarys: Incomplete
unarys_fastmath: Incomplete
binarys: Incomplete
binarys_fastmath: Incomplete

def math_isinf_isnan_int(context, builder, sig, args): ...
def maybe_fast_truediv(context, builder, sig, args): ...
def math_isfinite_int(context, builder, sig, args): ...
def fp16_sin_impl(context, builder, sig, args): ...
def fp16_cos_impl(context, builder, sig, args): ...
def fp16_log_impl(context, builder, sig, args): ...
def fp16_log10_impl(context, builder, sig, args): ...
def fp16_log2_impl(context, builder, sig, args): ...
def fp16_exp_impl(context, builder, sig, args): ...
def fp16_floor_impl(context, builder, sig, args): ...
def fp16_ceil_impl(context, builder, sig, args): ...
def fp16_sqrt_impl(context, builder, sig, args): ...
def fp16_fabs_impl(context, builder, sig, args): ...
def fp16_trunc_impl(context, builder, sig, args): ...
def impl_boolean(key, ty, libfunc): ...
def get_lower_unary_impl(key, ty, libfunc): ...
def get_unary_impl_for_fn_and_ty(fn, ty): ...
def impl_unary(key, ty, libfunc) -> None: ...
def impl_unary_int(key, ty, libfunc): ...
def get_lower_binary_impl(key, ty, libfunc): ...
def get_binary_impl_for_fn_and_ty(fn, ty): ...
def impl_binary(key, ty, libfunc) -> None: ...
def impl_binary_int(key, ty, libfunc): ...

impl32: Incomplete
impl64: Incomplete

def impl_pow_int(ty, libfunc): ...
def impl_modf(ty, libfunc): ...
def impl_frexp(ty, libfunc): ...
def impl_ldexp(ty, libfunc): ...
def impl_tanh(ty, libfunc): ...
def cpow_implement(fty, cty): ...
