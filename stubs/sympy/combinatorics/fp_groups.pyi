from _typeshed import Incomplete
from sympy.combinatorics.free_groups import FreeGroupElement
from sympy.printing.defaults import DefaultPrinting
from sympy.utilities import public

__all__ = ['fp_group', 'xfp_group', 'vfp_group']

@public
def fp_group(fr_grp, relators=()): ...
@public
def xfp_group(fr_grp, relators=()): ...
@public
def vfp_group(fr_grpm, relators): ...

class FpGroup(DefaultPrinting):
    """
    The FpGroup would take a FreeGroup and a list/tuple of relators, the
    relators would be specified in such a way that each of them be equal to the
    identity of the provided free group.

    """
    is_group: bool
    is_FpGroup: bool
    is_PermutationGroup: bool
    free_group: Incomplete
    relators: Incomplete
    generators: Incomplete
    dtype: Incomplete
    _coset_table: Incomplete
    _is_standardized: bool
    _order: Incomplete
    _center: Incomplete
    _rewriting_system: Incomplete
    _perm_isomorphism: Incomplete
    def __init__(self, fr_grp, relators) -> None: ...
    def _generators(self): ...
    def make_confluent(self) -> None:
        """
        Try to make the group's rewriting system confluent

        """
    def reduce(self, word):
        """
        Return the reduced form of `word` in `self` according to the group's
        rewriting system. If it's confluent, the reduced form is the unique normal
        form of the word in the group.

        """
    def equals(self, word1, word2):
        """
        Compare `word1` and `word2` for equality in the group
        using the group's rewriting system. If the system is
        confluent, the returned answer is necessarily correct.
        (If it is not, `False` could be returned in some cases
        where in fact `word1 == word2`)

        """
    @property
    def identity(self): ...
    def __contains__(self, g) -> bool: ...
    def subgroup(self, gens, C=None, homomorphism: bool = False):
        '''
        Return the subgroup generated by `gens` using the
        Reidemeister-Schreier algorithm
        homomorphism -- When set to True, return a dictionary containing the images
                     of the presentation generators in the original group.

        Examples
        ========

        >>> from sympy.combinatorics.fp_groups import FpGroup
        >>> from sympy.combinatorics import free_group
        >>> F, x, y = free_group("x, y")
        >>> f = FpGroup(F, [x**3, y**5, (x*y)**2])
        >>> H = [x*y, x**-1*y**-1*x*y*x]
        >>> K, T = f.subgroup(H, homomorphism=True)
        >>> T(K.generators)
        [x*y, x**-1*y**2*x**-1]

        '''
    def coset_enumeration(self, H, strategy: str = 'relator_based', max_cosets=None, draft=None, incomplete: bool = False):
        """
        Return an instance of ``coset table``, when Todd-Coxeter algorithm is
        run over the ``self`` with ``H`` as subgroup, using ``strategy``
        argument as strategy. The returned coset table is compressed but not
        standardized.

        An instance of `CosetTable` for `fp_grp` can be passed as the keyword
        argument `draft` in which case the coset enumeration will start with
        that instance and attempt to complete it.

        When `incomplete` is `True` and the function is unable to complete for
        some reason, the partially complete table will be returned.

        """
    def standardize_coset_table(self) -> None:
        """
        Standardized the coset table ``self`` and makes the internal variable
        ``_is_standardized`` equal to ``True``.

        """
    def coset_table(self, H, strategy: str = 'relator_based', max_cosets=None, draft=None, incomplete: bool = False):
        """
        Return the mathematical coset table of ``self`` in ``H``.

        """
    def order(self, strategy: str = 'relator_based'):
        '''
        Returns the order of the finitely presented group ``self``. It uses
        the coset enumeration with identity group as subgroup, i.e ``H=[]``.

        Examples
        ========

        >>> from sympy.combinatorics import free_group
        >>> from sympy.combinatorics.fp_groups import FpGroup
        >>> F, x, y = free_group("x, y")
        >>> f = FpGroup(F, [x, y**2])
        >>> f.order(strategy="coset_table_based")
        2

        '''
    def _is_infinite(self):
        """
        Test if the group is infinite. Return `True` if the test succeeds
        and `None` otherwise

        """
    def _finite_index_subgroup(self, s=None):
        """
        Find the elements of `self` that generate a finite index subgroup
        and, if found, return the list of elements and the coset table of `self` by
        the subgroup, otherwise return `(None, None)`

        """
    def most_frequent_generator(self): ...
    def random(self): ...
    def index(self, H, strategy: str = 'relator_based'):
        '''
        Return the index of subgroup ``H`` in group ``self``.

        Examples
        ========

        >>> from sympy.combinatorics import free_group
        >>> from sympy.combinatorics.fp_groups import FpGroup
        >>> F, x, y = free_group("x, y")
        >>> f = FpGroup(F, [x**5, y**4, y*x*y**3*x**3])
        >>> f.index([x])
        4

        '''
    def __str__(self) -> str: ...
    __repr__ = __str__
    def _to_perm_group(self):
        """
        Return an isomorphic permutation group and the isomorphism.
        The implementation is dependent on coset enumeration so
        will only terminate for finite groups.

        """
    def _perm_group_list(self, method_name, *args):
        """
        Given the name of a `PermutationGroup` method (returning a subgroup
        or a list of subgroups) and (optionally) additional arguments it takes,
        return a list or a list of lists containing the generators of this (or
        these) subgroups in terms of the generators of `self`.

        """
    def derived_series(self):
        """
        Return the list of lists containing the generators
        of the subgroups in the derived series of `self`.

        """
    def lower_central_series(self):
        """
        Return the list of lists containing the generators
        of the subgroups in the lower central series of `self`.

        """
    def center(self):
        """
        Return the list of generators of the center of `self`.

        """
    def derived_subgroup(self):
        """
        Return the list of generators of the derived subgroup of `self`.

        """
    def centralizer(self, other):
        """
        Return the list of generators of the centralizer of `other`
        (a list of elements of `self`) in `self`.

        """
    def normal_closure(self, other):
        """
        Return the list of generators of the normal closure of `other`
        (a list of elements of `self`) in `self`.

        """
    def _perm_property(self, attr):
        """
        Given an attribute of a `PermutationGroup`, return
        its value for a permutation group isomorphic to `self`.

        """
    @property
    def is_abelian(self):
        """
        Check if `self` is abelian.

        """
    @property
    def is_nilpotent(self):
        """
        Check if `self` is nilpotent.

        """
    @property
    def is_solvable(self):
        """
        Check if `self` is solvable.

        """
    @property
    def elements(self):
        """
        List the elements of `self`.

        """
    @property
    def is_cyclic(self):
        """
        Return ``True`` if group is Cyclic.

        """
    def abelian_invariants(self):
        """
        Return Abelian Invariants of a group.
        """
    def composition_series(self):
        """
        Return subnormal series of maximum length for a group.
        """

class FpSubgroup(DefaultPrinting):
    """
    The class implementing a subgroup of an FpGroup or a FreeGroup
    (only finite index subgroups are supported at this point). This
    is to be used if one wishes to check if an element of the original
    group belongs to the subgroup

    """
    parent: Incomplete
    generators: Incomplete
    _min_words: Incomplete
    C: Incomplete
    normal: Incomplete
    def __init__(self, G, gens, normal: bool = False) -> None: ...
    def __contains__(self, g) -> bool: ...
    def order(self): ...
    def to_FpGroup(self): ...
    def __str__(self) -> str: ...
    __repr__ = __str__
FpGroupElement = FreeGroupElement
