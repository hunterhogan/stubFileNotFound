from _typeshed import Incomplete
from sympy.codegen.ast import Assignment as Assignment, Declaration as Declaration, Pointer as Pointer, Type as Type, Variable as Variable, bool_ as bool_, complex128 as complex128, complex64 as complex64, complex_ as complex_, float32 as float32, float64 as float64, float80 as float80, int16 as int16, int32 as int32, int64 as int64, int8 as int8, intc as intc, integer as integer, none as none, pointer_const as pointer_const, real as real, uint16 as uint16, uint32 as uint32, uint64 as uint64, uint8 as uint8, untyped as untyped, value_const as value_const
from sympy.core.numbers import Float as Float, equal_valued as equal_valued
from sympy.printing.codeprinter import CodePrinter as CodePrinter, ccode as ccode, print_ccode as print_ccode, requires as requires
from sympy.printing.precedence import PRECEDENCE as PRECEDENCE, precedence as precedence
from typing import Any

known_functions_C89: Incomplete
known_functions_C99: Incomplete
reserved_words: Incomplete
reserved_words_c99: Incomplete

def get_math_macros():
    ''' Returns a dictionary with math-related macros from math.h/cmath

    Note that these macros are not strictly required by the C/C++-standard.
    For MSVC they are enabled by defining "_USE_MATH_DEFINES" (preferably
    via a compilation flag).

    Returns
    =======

    Dictionary mapping SymPy expressions to strings (macro names)

    '''
def _as_macro_if_defined(meth):
    """ Decorator for printer methods

    When a Printer's method is decorated using this decorator the expressions printed
    will first be looked for in the attribute ``math_macros``, and if present it will
    print the macro name in ``math_macros`` followed by a type suffix for the type
    ``real``. e.g. printing ``sympy.pi`` would print ``M_PIl`` if real is mapped to float80.

    """

class C89CodePrinter(CodePrinter):
    """A printer to convert Python expressions to strings of C code"""
    printmethod: str
    language: str
    standard: str
    reserved_words: Incomplete
    _default_settings: dict[str, Any]
    type_aliases: Incomplete
    type_mappings: dict[Type, Any]
    type_headers: Incomplete
    type_macros: dict[Type, tuple[str, ...]]
    type_func_suffixes: Incomplete
    type_literal_suffixes: Incomplete
    type_math_macro_suffixes: Incomplete
    math_macros: Incomplete
    _ns: str
    _kf: dict[str, Any]
    known_functions: Incomplete
    _dereference: Incomplete
    headers: Incomplete
    libraries: Incomplete
    macros: Incomplete
    def __init__(self, settings: Incomplete | None = None) -> None: ...
    def _rate_index_position(self, p): ...
    def _get_statement(self, codestring):
        """ Get code string as a statement - i.e. ending with a semicolon. """
    def _get_comment(self, text): ...
    def _declare_number_const(self, name, value): ...
    def _format_code(self, lines): ...
    def _traverse_matrix_indices(self, mat): ...
    def _print_Mul(self, expr, **kwargs): ...
    def _print_Pow(self, expr): ...
    def _print_Mod(self, expr): ...
    def _print_Rational(self, expr): ...
    def _print_Indexed(self, expr): ...
    def _print_Idx(self, expr): ...
    def _print_NumberSymbol(self, expr): ...
    def _print_Infinity(self, expr): ...
    def _print_NegativeInfinity(self, expr): ...
    def _print_Piecewise(self, expr): ...
    def _print_ITE(self, expr): ...
    def _print_MatrixElement(self, expr): ...
    def _print_Symbol(self, expr): ...
    def _print_Relational(self, expr): ...
    def _print_For(self, expr): ...
    def _print_sign(self, func): ...
    def _print_Max(self, expr): ...
    def _print_Min(self, expr): ...
    def indent_code(self, code):
        """Accepts a string of code or a list of code lines"""
    def _get_func_suffix(self, type_): ...
    def _get_literal_suffix(self, type_): ...
    def _get_math_macro_suffix(self, type_): ...
    def _print_Tuple(self, expr): ...
    _print_List = _print_Tuple
    def _print_Type(self, type_): ...
    def _print_Declaration(self, decl): ...
    def _print_Float(self, flt): ...
    def _print_BooleanTrue(self, expr): ...
    def _print_BooleanFalse(self, expr): ...
    def _print_Element(self, elem): ...
    def _print_CodeBlock(self, expr):
        """ Elements of code blocks printed as statements. """
    def _print_While(self, expr): ...
    def _print_Scope(self, expr): ...
    def _print_Print(self, expr): ...
    def _print_Stream(self, strm): ...
    def _print_FunctionPrototype(self, expr): ...
    def _print_FunctionDefinition(self, expr): ...
    def _print_Return(self, expr): ...
    def _print_CommaOperator(self, expr): ...
    def _print_Label(self, expr): ...
    def _print_goto(self, expr): ...
    def _print_PreIncrement(self, expr): ...
    def _print_PostIncrement(self, expr): ...
    def _print_PreDecrement(self, expr): ...
    def _print_PostDecrement(self, expr): ...
    def _print_struct(self, expr): ...
    def _print_BreakToken(self, _): ...
    def _print_ContinueToken(self, _): ...
    _print_union = _print_struct

class C99CodePrinter(C89CodePrinter):
    standard: str
    reserved_words: Incomplete
    type_mappings: Incomplete
    type_headers: Incomplete
    _kf: dict[str, Any]
    _prec_funcs: Incomplete
    def _print_Infinity(self, expr): ...
    def _print_NegativeInfinity(self, expr): ...
    def _print_NaN(self, expr): ...
    def _print_math_func(self, expr, nest: bool = False, known: Incomplete | None = None): ...
    def _print_Max(self, expr): ...
    def _print_Min(self, expr): ...
    def _get_loop_opening_ending(self, indices): ...

class C11CodePrinter(C99CodePrinter):
    def _print_alignof(self, expr): ...

c_code_printers: Incomplete
