from sympy.core import Add as Add, Dummy as Dummy, symbols as symbols
from sympy.core.numbers import Rational as Rational
from sympy.polys import ComputationFailed as ComputationFailed, Poly as Poly, cancel as cancel, parallel_poly_from_expr as parallel_poly_from_expr, reduced as reduced
from sympy.polys.monomials import Monomial as Monomial, monomial_div as monomial_div
from sympy.polys.polyerrors import DomainError as DomainError, PolificationFailed as PolificationFailed
from sympy.utilities.misc import debug as debug, debugf as debugf

def ratsimp(expr):
    """
    Put an expression over a common denominator, cancel and reduce.

    Examples
    ========

    >>> from sympy import ratsimp
    >>> from sympy.abc import x, y
    >>> ratsimp(1/x + 1/y)
    (x + y)/(x*y)
    """
def ratsimpmodprime(expr, G, *gens, quick: bool = True, polynomial: bool = False, **args):
    """
    Simplifies a rational expression ``expr`` modulo the prime ideal
    generated by ``G``.  ``G`` should be a Groebner basis of the
    ideal.

    Examples
    ========

    >>> from sympy.simplify.ratsimp import ratsimpmodprime
    >>> from sympy.abc import x, y
    >>> eq = (x + y**5 + y)/(x - y)
    >>> ratsimpmodprime(eq, [x*y**5 - x - y], x, y, order='lex')
    (-x**2 - x*y - x - y)/(-x**2 + x*y)

    If ``polynomial`` is ``False``, the algorithm computes a rational
    simplification which minimizes the sum of the total degrees of
    the numerator and the denominator.

    If ``polynomial`` is ``True``, this function just brings numerator and
    denominator into a canonical form. This is much faster, but has
    potentially worse results.

    References
    ==========

    .. [1] M. Monagan, R. Pearce, Rational Simplification Modulo a Polynomial
        Ideal, https://dl.acm.org/doi/pdf/10.1145/1145768.1145809
        (specifically, the second algorithm)
    """
