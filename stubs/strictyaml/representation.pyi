"""
This type stub file was generated by pyright.
"""

import sys
from collections import OrderedDict as OrderedDictBase

if sys.version_info[0] == 3:
    unicode = str
if sys.version_info[: 2] < (3, 7):
    class OrderedDict(OrderedDictBase):
        def __repr__(self): # -> str:
            ...
        
    
    
else:
    OrderedDict = ...
class YAMLIterator:
    def __init__(self, yaml_object) -> None:
        ...
    
    def __iter__(self): # -> Self:
        ...
    
    def next(self):
        ...
    
    def __next__(self):
        ...
    


class YAML:
    """
    A YAML object represents a block of YAML which can be:

    * Used to extract parsed data from the YAML (.data).
    * Used to render to a string of YAML, with comments (.as_yaml()).
    * Revalidated with a stricter schema (.revalidate(schema)).
    """
    def __init__(self, value, validator=...) -> None:
        ...
    
    def __int__(self) -> int:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __unicode__(self): # -> str | None:
        ...
    
    def revalidate(self, schema): # -> None:
        ...
    
    @property
    def data(self): # -> OrderedDict | list[Any] | str | Any:
        """
        Returns raw data representation of the document or document segment.

        Mappings are rendered as ordered dicts, sequences as lists and scalar values
        as whatever the validator returns (int, string, etc.).

        If no validators are used, scalar values are always returned as strings.
        """
        ...
    
    def as_marked_up(self): # -> Any:
        """
        Returns strictyaml.ruamel CommentedSeq/CommentedMap objects
        with comments. This can be fed directly into a strictyaml.ruamel
        dumper.
        """
        ...
    
    @property
    def start_line(self): # -> int:
        """
        Return line number that the element starts on (including preceding comments).
        """
        ...
    
    @property
    def end_line(self): # -> int:
        """
        Return line number that the element ends on (including trailing comments).
        """
        ...
    
    def lines(self): # -> str:
        """
        Return a string of the lines which make up the selected line
        including preceding and trailing comments.
        """
        ...
    
    def lines_before(self, how_many): # -> str:
        ...
    
    def lines_after(self, how_many): # -> str:
        ...
    
    def __float__(self): # -> float:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __bool__(self): # -> bool | None:
        ...
    
    def __nonzero__(self): # -> bool | None:
        ...
    
    def __getitem__(self, index):
        ...
    
    def __setitem__(self, index, value): # -> None:
        ...
    
    def __delitem__(self, index): # -> None:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def as_yaml(self):
        """
        Render the YAML node and subnodes as string.
        """
        ...
    
    def items(self): # -> list[tuple[Any, Any]]:
        ...
    
    def keys(self): # -> list[Any]:
        ...
    
    def values(self): # -> list[Any]:
        ...
    
    def get(self, index, default=...): # -> None:
        ...
    
    def __contains__(self, item): # -> bool:
        ...
    
    def __iter__(self): # -> YAMLIterator:
        ...
    
    @property
    def validator(self): # -> None:
        ...
    
    @property
    def text(self): # -> Any | str | None:
        """
        Return string value of scalar, whatever value it was parsed as.
        """
        ...
    
    def copy(self): # -> Self:
        ...
    
    def __gt__(self, val) -> bool:
        ...
    
    def __lt__(self, val) -> bool:
        ...
    
    @property
    def value(self): # -> Any:
        ...
    
    def is_mapping(self): # -> bool:
        ...
    
    def is_sequence(self): # -> bool:
        ...
    
    def is_scalar(self): # -> bool:
        ...
    
    @property
    def scalar(self): # -> Any:
        ...
    
    def whole_document(self): # -> Any:
        ...
    
    def __eq__(self, value) -> bool:
        ...
    
    def __ne__(self, value) -> bool:
        ...
    


