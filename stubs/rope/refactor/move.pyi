"""
This type stub file was generated by pyright.
"""

import typing
from typing import List, Optional, Union
from rope.base import project, resources

"""A module containing classes for move refactoring

`create_move()` is a factory for creating move refactoring objects
based on inputs.

"""
if typing.TYPE_CHECKING:
    ...
def create_move(project, resource, offset=...): # -> MoveModule | MoveMethod | MoveGlobal:
    """A factory for creating Move objects

    Based on `resource` and `offset`, return one of `MoveModule`,
    `MoveGlobal` or `MoveMethod` for performing move refactoring.

    """
    ...

class MoveMethod:
    """For moving methods

    It makes a new method in the destination class and changes
    the body of the old method to call the new method.  You can
    inline the old method to change all of its occurrences.

    """
    def __init__(self, project, resource, offset) -> None:
        ...
    
    def get_changes(self, dest_attr: str, new_name: Optional[str] = ..., resources: Optional[List[resources.File]] = ..., task_handle=...): # -> ChangeSet:
        """Return the changes needed for this refactoring

        Parameters:

        - `dest_attr`: the name of the destination attribute
        - `new_name`: the name of the new method; if `None` uses
          the old name
        - `resources` can be a list of `rope.base.resources.File` to
          apply this refactoring on.  If `None`, the restructuring
          will be applied to all python files.

        """
        ...
    
    def get_method_name(self):
        ...
    
    def get_new_method(self, name): # -> str:
        ...
    


class MoveGlobal:
    """For moving global function and classes"""
    project: project.Project
    def __init__(self, project, resource, offset) -> None:
        ...
    
    def get_changes(self, dest: Optional[Union[str, resources.Resource]], resources: Optional[List[resources.File]] = ..., task_handle=...): # -> ChangeSet:
        """Return the changes needed for this refactoring

        Parameters:

        - `dest`: the Resource or dotted moddule name of the move destination
        - `resources` can be a list of `rope.base.resources.File` to
          apply this refactoring on.  If `None`, the restructuring
          will be applied to all python files.

        """
        ...
    


class MoveModule:
    """For moving modules and packages"""
    def __init__(self, project, resource) -> None:
        ...
    
    def get_changes(self, dest: resources.Resource, resources: Optional[List[resources.File]] = ..., task_handle=...): # -> ChangeSet:
        ...
    


class _ChangeMoveOccurrencesHandle:
    def __init__(self, new_name) -> None:
        ...
    
    def occurred_inside_skip(self, change_collector, occurrence): # -> None:
        ...
    
    def occurred_outside_skip(self, change_collector, occurrence): # -> None:
        ...
    


class _MoveTools:
    def __init__(self, project, source, pyname, old_name) -> None:
        ...
    
    def remove_old_imports(self, pymodule): # -> None:
        class CanSelect:
            ...
        
        
    
    def rename_in_module(self, new_name, pymodule=..., imports=..., resource=...):
        ...
    
    def occurs_in_module(self, pymodule=..., resource=..., imports=...): # -> bool:
        ...
    
    def new_pymodule(self, pymodule, source):
        ...
    
    def new_source(self, pymodule, source):
        ...
    
    def add_imports(self, pymodule, new_imports):
        ...
    


def moving_code_with_imports(project, resource, source): # -> tuple[Any, list[Any]]:
    ...

class ModuleSkipRenamerHandle:
    def occurred_outside_skip(self, change_collector, occurrence): # -> None:
        ...
    
    def occurred_inside_skip(self, change_collector, occurrence): # -> None:
        ...
    


class ModuleSkipRenamer:
    """Rename occurrences in a module

    This class can be used when you want to treat a region in a file
    separately from other parts when renaming.

    """
    def __init__(self, occurrence_finder, resource, handle=..., skip_start=..., skip_end=..., replacement=...) -> None:
        """Constructor

        if replacement is `None` the region is not changed.  Otherwise
        it is replaced with `replacement`.

        """
        ...
    
    def get_changed_module(self): # -> None:
        ...
    


