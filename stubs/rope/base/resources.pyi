"""
This type stub file was generated by pyright.
"""

import os
from pathlib import Path

"""Files and folders in a project are represented as resource objects.

Files and folders are access through `Resource` objects. `Resource` has
two subclasses: `File` and `Folder`. What we care about is that
refactorings and `rope.base.change.Change`s use resources.

There are two options to create a `Resource` for a path in a project.
Note that in these examples `path` is the path to a file or folder
relative to the project's root. A project's root folder is represented
by an empty string.

  1) Use the `rope.base.Project.get_resource()` method. E.g.:

       myresource = myproject.get_resource(path)


  2) Use the `rope.base.libutils` module. `libutils` has a function
     named `path_to_resource()`. It takes a project and a path:

       from rope.base import libutils

       myresource = libutils.path_to_resource(myproject, path)

Once we have a `Resource`, we can retrieve information from it, like
getting the path relative to the project's root (via `path`), reading
from and writing to the resource, moving the resource, etc.
"""
class Resource(os.PathLike):
    """Represents files and folders in a project"""
    def __init__(self, project, path) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __fspath__(self) -> str:
        """Return the file system path of this resource"""
        ...
    
    def move(self, new_location): # -> None:
        """Move resource to `new_location`"""
        ...
    
    def remove(self): # -> None:
        """Remove resource from the project"""
        ...
    
    def is_dir(self): # -> None:
        """Alias for `is_folder()`"""
        ...
    
    def is_folder(self): # -> None:
        """Return True if the resource is a Folder"""
        ...
    
    def create(self): # -> None:
        """Create this resource"""
        ...
    
    def exists(self): # -> bool:
        ...
    
    @property
    def parent(self):
        ...
    
    @property
    def path(self) -> str:
        """Return the path of this resource relative to the project root

        The path is the list of parent directories separated by '/' followed
        by the resource name.
        """
        ...
    
    @property
    def name(self) -> str:
        """Return the name of this resource"""
        ...
    
    @property
    def real_path(self) -> str:
        ...
    
    @property
    def pathlib(self) -> Path:
        """Return the file as a pathlib path."""
        ...
    
    def __eq__(self, obj) -> bool:
        ...
    
    def __ne__(self, obj) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    


class File(Resource):
    """Represents a file"""
    def __init__(self, project, name) -> None:
        ...
    
    def read(self): # -> str:
        ...
    
    def read_bytes(self): # -> bytes:
        ...
    
    def write(self, contents): # -> None:
        ...
    
    def is_folder(self): # -> Literal[False]:
        ...
    
    def create(self): # -> None:
        ...
    


class Folder(Resource):
    """Represents a folder"""
    def is_folder(self): # -> Literal[True]:
        ...
    
    def get_children(self): # -> list[Any]:
        """Return the children of this folder"""
        ...
    
    def create_file(self, file_name):
        ...
    
    def create_folder(self, folder_name):
        ...
    
    def get_child(self, name):
        ...
    
    def has_child(self, name): # -> bool:
        ...
    
    def get_files(self): # -> list[Any]:
        ...
    
    def get_folders(self): # -> list[Any]:
        ...
    
    def contains(self, resource): # -> bool:
        ...
    
    def create(self): # -> None:
        ...
    


class _ResourceMatcher:
    def __init__(self) -> None:
        ...
    
    def set_patterns(self, patterns): # -> None:
        """Specify which resources to match

        `patterns` is a `list` of `str` that can contain ``*`` and
        ``?`` signs for matching resource names.

        """
        ...
    
    def does_match(self, resource): # -> bool:
        ...
    
    @property
    def compiled_patterns(self): # -> list[Any]:
        ...
    


