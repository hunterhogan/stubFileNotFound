"""
This type stub file was generated by pyright.
"""

from typing import Optional
from rope.base import exceptions

class PyObject:
    def __init__(self, type_) -> None:
        ...
    
    def get_attributes(self): # -> dict[Any, Any]:
        ...
    
    def get_attribute(self, name):
        ...
    
    def get_module(self): # -> None:
        ...
    
    def get_type(self): # -> Self:
        ...
    
    def __getitem__(self, key):
        """The same as ``get_attribute(key)``"""
        ...
    
    def __contains__(self, key): # -> bool:
        """The same as ``key in self.get_attributes()``"""
        ...
    
    def __eq__(self, obj) -> bool:
        """Check the equality of two `PyObject`

        Currently it is assumed that instances (the direct instances
        of `PyObject`, not the instances of its subclasses) are equal
        if their types are equal.  For every other object like
        defineds or builtins rope assumes objects are reference
        objects and their identities should match.

        """
        ...
    
    def __ne__(self, obj) -> bool:
        ...
    
    def __hash__(self) -> int:
        """See docs for `__eq__()` method"""
        ...
    
    def __iter__(self): # -> Iterator[Any]:
        """The same as ``iter(self.get_attributes())``"""
        ...
    
    _types = ...
    _unknown = ...


def get_base_type(name):
    """Return the base type with name `name`.

    The base types are 'Type', 'Function', 'Module' and 'Unknown'.  It
    was used to check the type of a `PyObject` but currently its use
    is discouraged.  Use classes defined in this module instead.
    For example instead of
    ``pyobject.get_type() == get_base_type('Function')`` use
    ``isinstance(pyobject, AbstractFunction)``.

    You can use `AbstractClass` for classes, `AbstractFunction` for
    functions, and `AbstractModule` for modules.  You can also use
    `PyFunction` and `PyClass` for testing if an object is
    defined somewhere and rope can access its source.  These classes
    provide more methods.

    """
    ...

def get_unknown(): # -> None:
    """Return a pyobject whose type is unknown

    Note that two unknown objects are equal.  So for example you can
    write::

      if pyname.get_object() == get_unknown():
          print('cannot determine what this pyname holds')

    Rope could have used `None` for indicating unknown objects but
    we had to check that in many places.  So actually this method
    returns a null object.

    """
    ...

class AbstractClass(PyObject):
    def __init__(self) -> None:
        ...
    
    def get_name(self): # -> None:
        ...
    
    def get_doc(self): # -> None:
        ...
    
    def get_superclasses(self): # -> list[Any]:
        ...
    


class AbstractFunction(PyObject):
    def __init__(self) -> None:
        ...
    
    def get_name(self): # -> None:
        ...
    
    def get_doc(self): # -> None:
        ...
    
    def get_param_names(self, special_args=...): # -> list[Any]:
        ...
    
    def get_returned_object(self, args): # -> None:
        ...
    


class AbstractModule(PyObject):
    def __init__(self, doc=...) -> None:
        ...
    
    def get_doc(self): # -> None:
        ...
    
    def get_resource(self): # -> None:
        ...
    


class PyDefinedObject:
    """Python defined names that rope can access their sources"""
    def __init__(self, pycore, ast_node, parent) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    @property
    def absolute_name(self):
        ...
    
    visitor_class = ...
    def get_attributes(self):
        ...
    
    def get_attribute(self, name):
        ...
    
    def get_scope(self): # -> None:
        ...
    
    def get_module(self): # -> Self:
        ...
    
    def get_name(self): # -> None:
        ...
    
    def get_doc(self) -> Optional[str]:
        ...
    
    def get_ast(self): # -> Any:
        ...
    


class PyFunction(PyDefinedObject, AbstractFunction):
    ...


class PyComprehension(PyDefinedObject, PyObject):
    def get_name(self): # -> Literal['<comprehension>']:
        ...
    


class PyClass(PyDefinedObject, AbstractClass):
    ...


class _ConcludedData:
    def __init__(self) -> None:
        ...
    
    def set(self, data): # -> None:
        ...
    
    def get(self): # -> None:
        ...
    
    data = ...
    def __str__(self) -> str:
        ...
    


class _PyModule(PyDefinedObject, AbstractModule):
    def __init__(self, pycore, ast_node, resource) -> None:
        ...
    
    @property
    def absolute_name(self) -> str:
        ...
    
    def get_resource(self): # -> Any:
        ...
    


class PyModule(_PyModule):
    ...


class PyPackage(_PyModule):
    ...


class IsBeingInferredError(exceptions.RopeError):
    ...


