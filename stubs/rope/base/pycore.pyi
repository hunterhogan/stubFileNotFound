"""
This type stub file was generated by pyright.
"""

from rope.base import utils

class PyCore:
    def __init__(self, project) -> None:
        ...
    
    @property
    def automatic_soa(self):
        ...
    
    def is_python_file(self, resource): # -> bool:
        ...
    
    @utils.deprecated("Use `project.get_module` instead")
    def get_module(self, name, folder=...):
        """Returns a `PyObject` if the module was found."""
        ...
    
    def builtin_module(self, name): # -> BuiltinModule | None:
        ...
    
    @utils.deprecated("Use `project.get_relative_module` instead")
    def get_relative_module(self, name, folder, level):
        ...
    
    @utils.deprecated("Use `libutils.get_string_module` instead")
    def get_string_module(self, code, resource=..., force_errors=...): # -> PyModule:
        """Returns a `PyObject` object for the given code

        If `force_errors` is `True`, `exceptions.ModuleSyntaxError` is
        raised if module has syntax errors.  This overrides
        ``ignore_syntax_errors`` project config.

        """
        ...
    
    @utils.deprecated("Use `libutils.get_string_scope` instead")
    def get_string_scope(self, code, resource=...): # -> None:
        """Returns a `Scope` object for the given code"""
        ...
    
    @utils.deprecated("Use `project.get_python_path_folders` instead")
    def get_python_path_folders(self):
        ...
    
    @utils.deprecated("Use `project.find_module` instead")
    def find_module(self, modname, folder=...):
        """Returns a resource corresponding to the given module

        returns None if it can not be found
        """
        ...
    
    @utils.deprecated("Use `project.find_relative_module` instead")
    def find_relative_module(self, modname, folder, level):
        ...
    
    @utils.deprecated("Use `project.get_source_folders` instead")
    def get_source_folders(self):
        """Returns project source folders"""
        ...
    
    def resource_to_pyobject(self, resource, force_errors=...): # -> PyModule | PyPackage:
        ...
    
    @utils.deprecated("Use `project.get_python_files` instead")
    def get_python_files(self):
        """Returns all python files available in the project"""
        ...
    
    def run_module(self, resource, args=..., stdin=..., stdout=...): # -> PythonFileRunner:
        """Run `resource` module

        Returns a `rope.base.oi.doa.PythonFileRunner` object for
        controlling the process.

        """
        ...
    
    def analyze_module(self, resource, should_analyze=..., search_subscopes=..., followed_calls=...): # -> None:
        """Analyze `resource` module for static object inference

        This function forces rope to analyze this module to collect
        information about function calls.  `should_analyze` is a
        function that is called with a `PyDefinedObject` argument.  If
        it returns `True` the element is analyzed.  If it is `None` or
        returns `False` the element is not analyzed.

        `search_subscopes` is like `should_analyze`; The difference is
        that if it returns `False` the sub-scopes are all ignored.
        That is it is assumed that `should_analyze` returns `False`
        for all of its subscopes.

        `followed_calls` override the value of ``soa_followed_calls``
        project config.
        """
        ...
    
    def get_classes(self, task_handle=...): # -> list[Any]:
        ...
    
    def __str__(self) -> str:
        ...
    
    @utils.deprecated("Use `libutils.modname` instead")
    def modname(self, resource):
        ...
    
    @property
    @utils.cacheit
    def extension_modules(self): # -> set[Any]:
        ...
    


class _ModuleCache:
    def __init__(self, pycore) -> None:
        ...
    
    def get_pymodule(self, resource, force_errors=...): # -> PyModule | PyPackage:
        ...
    
    def forget_all_data(self): # -> None:
        ...
    
    def __str__(self) -> str:
        ...
    


class _ExtensionCache:
    def __init__(self, pycore) -> None:
        ...
    
    def get_pymodule(self, name): # -> BuiltinModule | None:
        ...
    


def perform_soa_on_changed_scopes(project, resource, old_contents): # -> None:
    ...

class _TextChangeDetector:
    def __init__(self, old, new) -> None:
        ...
    
    def is_changed(self, start, end): # -> bool:
        """Tell whether any of start till end lines have changed

        The end points are inclusive and indices start from 1.
        """
        ...
    
    def consume_changes(self, start, end): # -> bool:
        """Clear the changed status of lines from start till end"""
        ...
    


