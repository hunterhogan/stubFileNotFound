"""
This type stub file was generated by pyright.
"""

import contextlib as cl

"""Fanout cache automatically shards keys and values."""
class FanoutCache:
    """Cache that shards keys and values."""
    def __init__(self, directory=..., shards=..., timeout=..., disk=..., **settings) -> None:
        """Initialize cache instance.

        :param str directory: cache directory
        :param int shards: number of shards to distribute writes
        :param float timeout: SQLite connection timeout
        :param disk: `Disk` instance for serialization
        :param settings: any of `DEFAULT_SETTINGS`

        """
        ...
    
    @property
    def directory(self): # -> str:
        """Cache directory."""
        ...
    
    def __getattr__(self, name): # -> Any:
        ...
    
    @cl.contextmanager
    def transact(self, retry=...): # -> Generator[None, Any, None]:
        """Context manager to perform a transaction by locking the cache.

        While the cache is locked, no other write operation is permitted.
        Transactions should therefore be as short as possible. Read and write
        operations performed in a transaction are atomic. Read operations may
        occur concurrent to a transaction.

        Transactions may be nested and may not be shared between threads.

        Blocks until transactions are held on all cache shards by retrying as
        necessary.

        >>> cache = FanoutCache()
        >>> with cache.transact():  # Atomically increment two keys.
        ...     _ = cache.incr('total', 123.4)
        ...     _ = cache.incr('count', 1)
        >>> with cache.transact():  # Atomically calculate average.
        ...     average = cache['total'] / cache['count']
        >>> average
        123.4

        :return: context manager for use in `with` statement

        """
        ...
    
    def set(self, key, value, expire=..., read=..., tag=..., retry=...): # -> bool:
        """Set `key` and `value` item in cache.

        When `read` is `True`, `value` should be a file-like object opened
        for reading in binary mode.

        If database timeout occurs then fails silently unless `retry` is set to
        `True` (default `False`).

        :param key: key for item
        :param value: value for item
        :param float expire: seconds until the key expires
            (default None, no expiry)
        :param bool read: read value as raw bytes from file (default False)
        :param str tag: text to associate with key (default None)
        :param bool retry: retry if database timeout occurs (default False)
        :return: True if item was set

        """
        ...
    
    def __setitem__(self, key, value): # -> None:
        """Set `key` and `value` item in cache.

        Calls :func:`FanoutCache.set` internally with `retry` set to `True`.

        :param key: key for item
        :param value: value for item

        """
        ...
    
    def touch(self, key, expire=..., retry=...): # -> bool:
        """Touch `key` in cache and update `expire` time.

        If database timeout occurs then fails silently unless `retry` is set to
        `True` (default `False`).

        :param key: key for item
        :param float expire: seconds until the key expires
            (default None, no expiry)
        :param bool retry: retry if database timeout occurs (default False)
        :return: True if key was touched

        """
        ...
    
    def add(self, key, value, expire=..., read=..., tag=..., retry=...): # -> bool:
        """Add `key` and `value` item to cache.

        Similar to `set`, but only add to cache if key not present.

        This operation is atomic. Only one concurrent add operation for given
        key from separate threads or processes will succeed.

        When `read` is `True`, `value` should be a file-like object opened
        for reading in binary mode.

        If database timeout occurs then fails silently unless `retry` is set to
        `True` (default `False`).

        :param key: key for item
        :param value: value for item
        :param float expire: seconds until the key expires
            (default None, no expiry)
        :param bool read: read value as bytes from file (default False)
        :param str tag: text to associate with key (default None)
        :param bool retry: retry if database timeout occurs (default False)
        :return: True if item was added

        """
        ...
    
    def incr(self, key, delta=..., default=..., retry=...): # -> int | Any | None:
        """Increment value by delta for item with key.

        If key is missing and default is None then raise KeyError. Else if key
        is missing and default is not None then use default for value.

        Operation is atomic. All concurrent increment operations will be
        counted individually.

        Assumes value may be stored in a SQLite column. Most builds that target
        machines with 64-bit pointer widths will support 64-bit signed
        integers.

        If database timeout occurs then fails silently unless `retry` is set to
        `True` (default `False`).

        :param key: key for item
        :param int delta: amount to increment (default 1)
        :param int default: value if key is missing (default 0)
        :param bool retry: retry if database timeout occurs (default False)
        :return: new value for item on success else None
        :raises KeyError: if key is not found and default is None

        """
        ...
    
    def decr(self, key, delta=..., default=..., retry=...): # -> int | Any | None:
        """Decrement value by delta for item with key.

        If key is missing and default is None then raise KeyError. Else if key
        is missing and default is not None then use default for value.

        Operation is atomic. All concurrent decrement operations will be
        counted individually.

        Unlike Memcached, negative values are supported. Value may be
        decremented below zero.

        Assumes value may be stored in a SQLite column. Most builds that target
        machines with 64-bit pointer widths will support 64-bit signed
        integers.

        If database timeout occurs then fails silently unless `retry` is set to
        `True` (default `False`).

        :param key: key for item
        :param int delta: amount to decrement (default 1)
        :param int default: value if key is missing (default 0)
        :param bool retry: retry if database timeout occurs (default False)
        :return: new value for item on success else None
        :raises KeyError: if key is not found and default is None

        """
        ...
    
    def get(self, key, default=..., read=..., expire_time=..., tag=..., retry=...): # -> tuple[Any | None, None, None] | tuple[Any | None, None] | tuple[bytes | Any | BufferedReader[_BufferedReaderStream] | str | None, Any, Any] | tuple[bytes | Any | BufferedReader[_BufferedReaderStream] | str | None, Any] | bytes | BufferedReader[_BufferedReaderStream] | str | Any | None:
        """Retrieve value from cache. If `key` is missing, return `default`.

        If database timeout occurs then returns `default` unless `retry` is set
        to `True` (default `False`).

        :param key: key for item
        :param default: return value if key is missing (default None)
        :param bool read: if True, return file handle to value
            (default False)
        :param float expire_time: if True, return expire_time in tuple
            (default False)
        :param tag: if True, return tag in tuple (default False)
        :param bool retry: retry if database timeout occurs (default False)
        :return: value for item if key is found else default

        """
        ...
    
    def __getitem__(self, key): # -> tuple[Any | None, None, None] | tuple[Any | None, None] | tuple[bytes | Any | BufferedReader[_BufferedReaderStream] | str | None, Any, Any] | tuple[bytes | Any | BufferedReader[_BufferedReaderStream] | str | None, Any] | bytes | BufferedReader[_BufferedReaderStream] | str | Any | None:
        """Return corresponding value for `key` from cache.

        Calls :func:`FanoutCache.get` internally with `retry` set to `True`.

        :param key: key for item
        :return: value for item
        :raises KeyError: if key is not found

        """
        ...
    
    def read(self, key): # -> tuple[Any | None, None, None] | tuple[Any | None, None] | tuple[bytes | Any | BufferedReader[_BufferedReaderStream] | str | None, Any, Any] | tuple[bytes | Any | BufferedReader[_BufferedReaderStream] | str | None, Any] | bytes | BufferedReader[_BufferedReaderStream] | str | Any | None:
        """Return file handle corresponding to `key` from cache.

        :param key: key for item
        :return: file open for reading in binary mode
        :raises KeyError: if key is not found

        """
        ...
    
    def __contains__(self, key): # -> bool:
        """Return `True` if `key` matching item is found in cache.

        :param key: key for item
        :return: True if key is found

        """
        ...
    
    def pop(self, key, default=..., expire_time=..., tag=..., retry=...): # -> tuple[Any | None, None, None] | tuple[Any | None, None] | tuple[bytes | Any | BufferedReader[_BufferedReaderStream] | str | None, Any, Any] | tuple[bytes | Any | BufferedReader[_BufferedReaderStream] | str | None, Any] | bytes | BufferedReader[_BufferedReaderStream] | str | Any | None:
        """Remove corresponding item for `key` from cache and return value.

        If `key` is missing, return `default`.

        Operation is atomic. Concurrent operations will be serialized.

        If database timeout occurs then fails silently unless `retry` is set to
        `True` (default `False`).

        :param key: key for item
        :param default: return value if key is missing (default None)
        :param float expire_time: if True, return expire_time in tuple
            (default False)
        :param tag: if True, return tag in tuple (default False)
        :param bool retry: retry if database timeout occurs (default False)
        :return: value for item if key is found else default

        """
        ...
    
    def delete(self, key, retry=...): # -> bool:
        """Delete corresponding item for `key` from cache.

        Missing keys are ignored.

        If database timeout occurs then fails silently unless `retry` is set to
        `True` (default `False`).

        :param key: key for item
        :param bool retry: retry if database timeout occurs (default False)
        :return: True if item was deleted

        """
        ...
    
    def __delitem__(self, key): # -> None:
        """Delete corresponding item for `key` from cache.

        Calls :func:`FanoutCache.delete` internally with `retry` set to `True`.

        :param key: key for item
        :raises KeyError: if key is not found

        """
        ...
    
    def check(self, fix=..., retry=...): # -> Any:
        """Check database and file system consistency.

        Intended for use in testing and post-mortem error analysis.

        While checking the cache table for consistency, a writer lock is held
        on the database. The lock blocks other cache clients from writing to
        the database. For caches with many file references, the lock may be
        held for a long time. For example, local benchmarking shows that a
        cache with 1,000 file references takes ~60ms to check.

        If database timeout occurs then fails silently unless `retry` is set to
        `True` (default `False`).

        :param bool fix: correct inconsistencies
        :param bool retry: retry if database timeout occurs (default False)
        :return: list of warnings
        :raises Timeout: if database timeout occurs

        """
        ...
    
    def expire(self, retry=...): # -> Any | Literal[0]:
        """Remove expired items from cache.

        If database timeout occurs then fails silently unless `retry` is set to
        `True` (default `False`).

        :param bool retry: retry if database timeout occurs (default False)
        :return: count of items removed

        """
        ...
    
    def create_tag_index(self): # -> None:
        """Create tag index on cache database.

        Better to initialize cache with `tag_index=True` than use this.

        :raises Timeout: if database timeout occurs

        """
        ...
    
    def drop_tag_index(self): # -> None:
        """Drop tag index on cache database.

        :raises Timeout: if database timeout occurs

        """
        ...
    
    def evict(self, tag, retry=...): # -> Any | Literal[0]:
        """Remove items with matching `tag` from cache.

        If database timeout occurs then fails silently unless `retry` is set to
        `True` (default `False`).

        :param str tag: tag identifying items
        :param bool retry: retry if database timeout occurs (default False)
        :return: count of items removed

        """
        ...
    
    def cull(self, retry=...): # -> Any | Literal[0]:
        """Cull items from cache until volume is less than size limit.

        If database timeout occurs then fails silently unless `retry` is set to
        `True` (default `False`).

        :param bool retry: retry if database timeout occurs (default False)
        :return: count of items removed

        """
        ...
    
    def clear(self, retry=...): # -> Any | Literal[0]:
        """Remove all items from cache.

        If database timeout occurs then fails silently unless `retry` is set to
        `True` (default `False`).

        :param bool retry: retry if database timeout occurs (default False)
        :return: count of items removed

        """
        ...
    
    def stats(self, enable=..., reset=...): # -> tuple[Any, Any]:
        """Return cache statistics hits and misses.

        :param bool enable: enable collecting statistics (default True)
        :param bool reset: reset hits and misses to 0 (default False)
        :return: (hits, misses)

        """
        ...
    
    def volume(self): # -> int:
        """Return estimated total size of cache on disk.

        :return: size in bytes

        """
        ...
    
    def close(self): # -> None:
        """Close database connection."""
        ...
    
    def __enter__(self): # -> Self:
        ...
    
    def __exit__(self, *exception): # -> None:
        ...
    
    def __getstate__(self): # -> tuple[str, int, Any, type[Any]]:
        ...
    
    def __setstate__(self, state): # -> None:
        ...
    
    def __iter__(self): # -> chain[bytes | Any | None]:
        """Iterate keys in cache including expired items."""
        ...
    
    def __reversed__(self): # -> chain[bytes | Any | None]:
        """Reverse iterate keys in cache including expired items."""
        ...
    
    def __len__(self): # -> int:
        """Count of items in cache including expired items."""
        ...
    
    def reset(self, key, value=...): # -> Any | Constant:
        """Reset `key` and `value` item from Settings table.

        If `value` is not given, it is reloaded from the Settings
        table. Otherwise, the Settings table is updated.

        Settings attributes on cache objects are lazy-loaded and
        read-only. Use `reset` to update the value.

        Settings with the ``sqlite_`` prefix correspond to SQLite
        pragmas. Updating the value will execute the corresponding PRAGMA
        statement.

        :param str key: Settings key for item
        :param value: value for item (optional)
        :return: updated value for item

        """
        ...
    
    def cache(self, name, timeout=..., disk=..., **settings): # -> Cache:
        """Return Cache with given `name` in subdirectory.

        If disk is none (default), uses the fanout cache disk.

        >>> fanout_cache = FanoutCache()
        >>> cache = fanout_cache.cache('test')
        >>> cache.set('abc', 123)
        True
        >>> cache.get('abc')
        123
        >>> len(cache)
        1
        >>> cache.delete('abc')
        True

        :param str name: subdirectory name for Cache
        :param float timeout: SQLite connection timeout
        :param disk: Disk type or subclass for serialization
        :param settings: any of DEFAULT_SETTINGS
        :return: Cache with given name

        """
        ...
    
    def deque(self, name, maxlen=...): # -> Deque:
        """Return Deque with given `name` in subdirectory.

        >>> cache = FanoutCache()
        >>> deque = cache.deque('test')
        >>> deque.extend('abc')
        >>> deque.popleft()
        'a'
        >>> deque.pop()
        'c'
        >>> len(deque)
        1

        :param str name: subdirectory name for Deque
        :param maxlen: max length (default None, no max)
        :return: Deque with given name

        """
        ...
    
    def index(self, name): # -> Index:
        """Return Index with given `name` in subdirectory.

        >>> cache = FanoutCache()
        >>> index = cache.index('test')
        >>> index['abc'] = 123
        >>> index['def'] = 456
        >>> index['ghi'] = 789
        >>> index.popitem()
        ('ghi', 789)
        >>> del index['abc']
        >>> len(index)
        1
        >>> index['def']
        456

        :param str name: subdirectory name for Index
        :return: Index with given name

        """
        ...
    


