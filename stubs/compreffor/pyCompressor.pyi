"""
This type stub file was generated by pyright.
"""

from compreffor import timer

"""
Tool to subroutinize a CFF OpenType font.

Usage (command line):
>> ./pyCompressor.py /path/to/font.otf
# font written to /path/to/font.compressed.otf

Usage (in Python):
>> font = TTFont(path_to_font)
>> compreffor = Compreffor(font)
>> compreffor.compress()
>> font.save(path_to_output)
"""
log = ...
SINGLE_BYTE_OPS = ...
__all__ = ["CandidateSubr", "SubstringFinder", "Compreffor", "compreff"]
def tokenCost(token): # -> int | None:
    """Calculate the bytecode size of a T2 Charstring token"""
    ...

class CandidateSubr:
    """
    Records a substring of a charstring that is generally
    repeated throughout many glyphs.

    Instance variables:
    length -- length of substring
    location -- tuple of form (glyph_idx, start_pos) where a ref string starts
    freq -- number of times it appears
    chstrings -- chstrings from whence this substring came
    cost_map -- array from simple alphabet -> actual token
    """
    __slots__ = ...
    def __init__(self, length, ref_loc, freq=..., chstrings=..., cost_map=...) -> None:
        ...
    
    def __len__(self): # -> Any:
        """Return the number of tokens in this substring"""
        ...
    
    def value(self):
        """Returns the actual substring value"""
        ...
    
    def subr_saving(self, use_usages=..., true_cost=..., call_cost=..., subr_overhead=...): # -> int:
        """
        Return the savings that will be realized by subroutinizing
        this substring.

        Arguments:
        use_usages -- indicate to use the value in `_usages` rather than `freq`
        true_cost -- take account of subroutine calls
        call_cost -- the cost to call a subroutine
        subr_overhead -- the cost to define a subroutine
        """
        ...
    
    def real_cost(self, call_cost=...): # -> int:
        """Account for subroutine calls in cost computation. Not cached because
        the subroutines used will change over time."""
        ...
    
    def cost(self): # -> int:
        """Return the size (in bytes) that the bytecode for this takes up"""
        ...
    
    def encoding(self):
        ...
    
    def usages(self):
        ...
    
    def frequency(self): # -> int:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class SubstringFinder:
    """
    This class facilitates the finding of repeated substrings
    within a glyph_set. Typical usage involves creation of an instance
    and then calling `get_substrings`, which returns a sorted list
    of `CandidateSubr`s.

    Instance variables:
    suffixes -- sorted array of suffixes
    data --
      A 2-level array of charstrings:
        - The first level separates by glyph
        - The second level separates by token
            in a glyph's charstring
    alphabet_size -- size of alphabet
    length -- sum of the lengths of the individual glyphstrings
    rev_keymap -- map from simple alphabet -> original tokens
    cost_map -- map from simple alphabet -> bytecost of token
    glyph_set_keys -- glyph_set_keys[i] gives the glyph id for data[i]
    _completed_suffixes -- boolean whether the suffix array is ready and sorted
    """
    __slots__ = ...
    def __init__(self, glyph_set) -> None:
        ...
    
    def process_chstrings(self, glyph_set): # -> None:
        """Remap the charstring alphabet and put into self.data"""
        ...
    
    def get_suffixes(self): # -> list[Any]:
        """Return the sorted suffix array"""
        ...
    
    @timer("get LCP array")
    def get_lcp(self): # -> list[int]:
        """Returns the LCP array"""
        ...
    
    def get_substrings(self, min_freq=..., check_positive=..., sort_by_length=...): # -> list[Any]:
        """
        Return repeated substrings (type CandidateSubr) from the charstrings
        sorted by subroutine savings with freq >= min_freq using the LCP array.

        Arguments:
        min_freq -- the minimum frequency required to include a substring
        check_positive -- if True, only allow substrings with positive subr_saving
        sort_by_length -- if True, return substrings sorted by length, else by saving
        """
        ...
    


class Compreffor:
    """
    Manager class for the compreffor.

    Usage:
    >> font = TTFont(path_to_font)
    >> compreffor = Compreffor(font)
    >> compreffor.compress()
    >> font.save("/path/to/output.otf")
    """
    SINGLE_PROCESS = ...
    ALPHA = ...
    K = ...
    PROCESSES = ...
    NROUNDS = ...
    LATIN_POOL_CHUNKRATIO = ...
    POOL_CHUNKRATIO = ...
    CHUNK_CHARSET_CUTOFF = ...
    NSUBRS_LIMIT = ...
    SUBR_NEST_LIMIT = ...
    def __init__(self, font, nrounds=..., max_subrs=..., chunk_ratio=..., processes=..., test_mode=...) -> None:
        """
        Initialize the compressor.

        Arguments:
        font -- the TTFont to compress, must be a CFF font
        nrounds -- specifies the number of rounds to run
        max_subrs -- specify the limit on the number of subrs in an INDEX
        chunk_ratio -- sets the POOL_CHUNKRATIO parameter
        processes -- specify the number of parallel processes (1 to not
            parallelize)
        test_mode -- disables some checks (such as positive subr_saving)
        """
        ...
    
    def compress(self): # -> None:
        """Compress the provided font using the iterative method"""
        ...
    
    @staticmethod
    @timer("apply subroutines")
    def apply_subrs(top_dict, encoding, gsubrs, lsubrs): # -> None:
        ...
    
    @staticmethod
    def test_call_cost(subr, subrs): # -> Literal[3, 2, 1]:
        """See how much it would cost to call subr if it were inserted into subrs"""
        ...
    
    @staticmethod
    def insert_by_usage(subr, subrs): # -> None:
        """Insert subr into subrs mainting a sort by usage"""
        ...
    
    def iterative_encode(self, glyph_set, fdselect=..., fdlen=...): # -> dict[str, dict[Any, list[tuple[Any, Any]]] | list[list[Any]] | list[Any]]:
        """
        Choose a subroutinization encoding for all charstrings in
        `glyph_set` using an iterative Dynamic Programming algorithm.
        Initially uses the results from SubstringFinder and then
        iteratively optimizes.

        Arguments:
        glyph_set -- the set of charstrings to encode (required)
        fdselect -- the FDSelect array of the source font, or None
        fdlen -- the number of FD's in the source font, or 1 if there are none

        Returns:
        A three-part dictionary with keys 'gsubrs', 'lsubrs', and
        'glyph_encodings'. The 'glyph_encodings' encoding dictionary
        specifies how to break up each charstring. Encoding[i]
        describes how to encode glyph i. Each entry is something
        like [(x_1, c_1), (x_2, c_2), ..., (x_k, c_k)], where x_* is an index
        into the charstring that indicates where a subr starts and c_*
        is a CandidateSubr. The 'gsubrs' entry contains an array of global
        subroutines (CandidateSubr objects) and 'lsubrs' is an array indexed
        by FDidx, where each entry is a list of local subroutines.
        """
        ...
    
    @staticmethod
    @timer("post-process subroutines")
    def process_subrs(glyph_set_keys, encodings, fdlen, fdselect, substrings, rev_keymap, subr_limit, nest_limit): # -> tuple[list[Any], list[list[Any]]]:
        ...
    
    @staticmethod
    def collect_lsubrs_called_from(gsubrs): # -> set[Any]:
        """
        Collect local subroutines called from any entries in `gsubrs`.
        This method returns them as a set for after flattening
        in order to avoid `callsubr` usage in global subroutines.
        """
        ...
    
    @staticmethod
    def calc_nesting(subrs): # -> None:
        """Update each entry of subrs with their call depth. This
        is stored in the '_max_call_depth' attribute of the subr"""
        ...
    
    @staticmethod
    def update_program(program, encoding, gbias, lbias_arr, fdidx):
        """
        Applies the provided `encoding` to the provided `program`. I.e., all
        specified subroutines are actually called in the program. This mutates
        the input program and also returns it.

        Arguments:
        program -- the program to update
        encoding -- the encoding to use. a list of (idx, cand_subr) tuples
        gbias -- bias into the global subrs INDEX
        lbias_arr -- bias into each of the lsubrs INDEXes
        fdidx -- the FD that this `program` belongs to, or None if global
        """
        ...
    
    @staticmethod
    def collapse_hintmask(program): # -> None:
        """Takes in a charstring and returns the same charstring
        with hintmasks combined into a single element"""
        ...
    
    @staticmethod
    def expand_hintmask(program): # -> None:
        """Expands collapsed hintmask tokens into two tokens"""
        ...
    


def optimize_charstring(charstring, cost_map, substr_dict, progress=...): # -> dict[str, int | list[Any]]:
    """Optimize a charstring (encoded using keymap) using
    the substrings in substr_dict. This is the Dynamic Programming portion
    of `iterative_encode`."""
    ...

def compreff(font, **options): # -> None:
    """ Main function that compresses `font`, a TTFont object, in place. """
    ...

def human_size(num): # -> str:
    """Return a number of bytes in human-readable units"""
    ...

