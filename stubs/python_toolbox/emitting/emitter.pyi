"""
This type stub file was generated by pyright.
"""

'''
Defines the `Emitter` class.

See its documentation for more info.
'''
class Emitter:
    '''
    An emitter you can `emit` from to call all its callable outputs.

    The emitter idea is a variation on the publisher-subscriber design pattern.

    Every emitter has a set of inputs and a set of outputs. The inputs, if
    there are any, must be emitters themselves. So when you `emit` on any of
    this emitter's inputs, it's as if you `emit`ted on this emitter as well.
    (Recursively, of course.)

    The outputs are a bit different. An emitter can have as outputs both (a)
    other emitters and (b) callable objects. (Which means, functions or
    function-like objects.)

    There's no need to explain (a): If `emitter_1` has as an output
    `emitter_2`, then `emitter_2` has as an input `emitter_1`, which works like
    how we explained above about inputs.

    But now (b): An emitter can have callables as outputs. (Without these, the
    emitter idea won't have much use.) These callables simply get called
    whenever the emitter or one of its inputs get `emit`ted.

    The callables that you register as outputs are functions that need to be
    called when the original event that caused the `emit` action happens.
    '''
    _is_atomically_pickleable = ...
    def __init__(self, inputs=..., outputs=..., name=...) -> None:
        '''
        Construct the emitter.

        `inputs` is an iterable of inputs, all of which must be emitters. (You
        can also pass in a single input without using an iterable.)

        `outputs` is an iterable of outputs, which may be either emitters or
        callables. (You can also pass in a single output without using an
        iterable.)

        `name` is a string name for the emitter. (Optional, helps with
        debugging.)
        '''
        ...
    
    def get_inputs(self): # -> set[Any]:
        '''Get the emitter's inputs.'''
        ...
    
    def get_outputs(self): # -> set[Any]:
        '''Get the emitter's outputs.'''
        ...
    
    def add_input(self, emitter): # -> None:
        '''
        Add an emitter as an input to this emitter.

        Every time that emitter will emit, it will cause this emitter to emit
        as well.
        '''
        ...
    
    def remove_input(self, emitter): # -> None:
        '''Remove an input from this emitter.'''
        ...
    
    def add_output(self, thing): # -> None:
        '''
        Add an emitter or a callable as an output to this emitter.

        If adding a callable, every time this emitter will emit the callable
        will be called.

        If adding an emitter, every time this emitter will emit the output
        emitter will emit as well.
        '''
        ...
    
    def remove_output(self, thing): # -> None:
        '''Remove an output from this emitter.'''
        ...
    
    def disconnect_from_all(self): # -> None:
        '''Disconnect the emitter from all its inputs and outputs.'''
        ...
    
    def get_total_callable_outputs(self): # -> set[Any | Callable[..., object]] | None:
        '''
        Get the total of callable outputs of this emitter.

        This means the direct callable outputs, and the callable outputs of
        emitter outputs.
        '''
        ...
    
    def emit(self): # -> None:
        '''
        Call all of the (direct or indirect) callable outputs of this emitter.

        This is the most important method of the emitter. When you `emit`, all
        the callable outputs get called in succession.
        '''
        ...
    
    def __repr__(self): # -> str:
        '''
        Get a string representation of the emitter.

        Example output:
        <python_toolbox.emitting.emitter.Emitter 'tree_modified' at
        0x1c013d0>
        '''
        ...
    


