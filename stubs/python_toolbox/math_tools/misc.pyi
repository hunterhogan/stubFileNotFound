"""
This type stub file was generated by pyright.
"""

import python_toolbox.cute_enum

infinity = ...
infinities = ...
def cute_floor_div(x, y):
    '''
    Get `x // y`, i.e. `x` divided by `y` floored down.

    This differs from Python's built-in `//` in that it handles infinite
    `x`s in a more mathematically correct way: `infinity // 7` would equal
    `infinity`. (Python's built-in `divmod` would make it `nan`.)
    '''
    ...

def cute_divmod(x, y): # -> tuple[Any, float] | tuple[Any, Any | float]:
    '''
    Get the division and modulo for `x` and `y` as a tuple: `(x // y, x % y)`

    This differs from Python's built-in `divmod` in that it handles infinite
    `x`s in a more mathematically correct way: `infinity // 7` would equal
    `infinity`. (Python's built-in `divmod` would make it `nan`.)
    '''
    ...

def get_sign(x): # -> Literal[1, 0, -1]:
    '''Get the sign of a number.'''
    ...

def round_to_int(x, up=...): # -> int:
    '''
    Round a number to an `int`.

    This is mostly used for floating points. By default, it will round the
    number down, unless the `up` argument is set to `True` and then it will
    round up.

    If you want to round a number to the closest `int`, just use
    `int(round(x))`.
    '''
    ...

def ceil_div(x, y):
    '''Divide `x` by `y`, rounding up if there's a remainder.'''
    ...

def convert_to_base_in_tuple(number, base): # -> tuple[Literal[0]] | tuple[Any, ...]:
    '''
    Convert a number to any base, returning result in tuple.

    For example, `convert_to_base_in_tuple(32, base=10)` will be `(3, 2)` while
    `convert_to_base_in_tuple(32, base=16)` will be `(2, 0)`.
    '''
    ...

def restrict_number_to_range(number, low_cutoff=..., high_cutoff=...): # -> float:
    '''
    If `number` is not in the range between cutoffs, return closest cutoff.

    If the number is in range, simply return it.
    '''
    ...

def binomial(big, small): # -> int:
    '''
    Get the binomial coefficient (big small).

    This is used in combinatorical calculations. More information:
    http://en.wikipedia.org/wiki/Binomial_coefficient
    '''
    ...

def product(numbers): # -> Any:
    '''Get the product of all the numbers in `numbers`.'''
    ...

def is_integer(x): # -> Literal[False]:
    '''
    Is `x` an integer?

    Does return `True` for things like 1.0 and `1+0j`.
    '''
    ...

class RoundMode(python_toolbox.cute_enum.CuteEnum):
    '''
    A mode that determines how `cute_round` will round.

    See documentation of `cute_round` for more info about each of the different
    round modes.
    '''
    CLOSEST_OR_DOWN = ...
    CLOSEST_OR_UP = ...
    ALWAYS_DOWN = ...
    ALWAYS_UP = ...
    PROBABILISTIC = ...


def cute_round(x, round_mode=..., *, step=...):
    '''
    Round a number, with lots of different options for rounding.

    Basic usage:

        >>> cute_round(7.456)
        7

    The optional `step=1` argument can be changed to change the definition of a
    round number. e.g., if you set `step=100`, then 1234 will be rounded to
    1200. `step` doesn't have to be an integer.

    There are different rounding modes:

        RoundMode.CLOSEST_OR_DOWN

            Default mode: Round to the closest round number. If we're smack in
            the middle, like 4.5, round down to 4.

        RoundMode.CLOSEST_OR_UP

            Round to the closest round number. If we're smack in the middle,
            like 4.5, round up to 5.

        RoundMode.ALWAYS_DOWN

            Always round down. Even 4.99 gets rounded down to 4.

        RoundMode.ALWAYS_UP

            Always round up. Even 4.01 gets rounded up to 5.

        RoundMode.PROBABILISTIC

            Probabilistic round, giving a random result depending on how close
            the number is to each of the two surrounding round numbers. For
            example, if you round 4.5 with this mode, you'll get either 4 or 5
            with an equal probability. If you'll round 4.1 with this mode,
            there's a 90% chance you'll get 4, and a 10% chance you'll get 5.


    '''
    ...

