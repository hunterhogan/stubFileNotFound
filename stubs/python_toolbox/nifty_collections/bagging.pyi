"""
This type stub file was generated by pyright.
"""

import collections
from python_toolbox import misc_tools
from .ordered_dict import OrderedDict
from .various_frozen_dicts import FrozenDict, FrozenOrderedDict
from .abstract import Ordered

class _NO_DEFAULT(misc_tools.NonInstantiable):
    '''Stand-in value used in `_BaseBagMixin.pop` when no default is wanted.'''
    ...


class _ZeroCountAttempted(Exception):
    '''
    An attempt was made to add a value with a count of zero to a bag.

    This exception is used only internally for flow control; it'll be caught
    internally and the zero item would be silently removed.
    '''
    ...


class _BootstrappedCachedProperty(misc_tools.OwnNameDiscoveringDescriptor):
    '''
    A property that is calculated only once for an object, and then cached.

    This is redefined here in `bagging.py`, in addition to having it defined in
    `python_toolbox.caching`, because we can't import the canonical
    `CachedProperty` from there because of an import loop.

    Usage:

        class MyObject:

            # ... Regular definitions here

            def _get_personality(self):
                print('Calculating personality...')
                time.sleep(5) # Time consuming process that creates personality
                return 'Nice person'

            personality = _BootstrappedCachedProperty(_get_personality)

    You can also put in a value as the first argument if you'd like to have it
    returned instead of using a getter. (It can be a tobag static value like
    `0`). If this value happens to be a callable but you'd still like it to be
    used as a static value, use `force_value_not_getter=True`.
    '''
    def __init__(self, getter_or_value, doc=..., name=..., force_value_not_getter=...) -> None:
        '''
        Construct the cached property.

        `getter_or_value` may be either a function that takes the parent object
        and returns the value of the property, or the value of the property
        itself, (as long as it's not a callable.)

        You may optionally pass in the name that this property has in the
        class; this will save a bit of processing later.
        '''
        ...
    
    def __get__(self, obj, our_type=...): # -> Self | object | Any | Callable[..., object]:
        ...
    
    def __call__(self, method_function):
        '''
        Decorate method to use value of `CachedProperty` as a context manager.
        '''
        ...
    
    def __repr__(self): # -> str:
        ...
    


class _BaseBagMixin:
    '''
    Mixin for `FrozenBag` and `FrozenOrderedBag`.

    Most of the bag functionality is implemented here, with a few finishing
    touches in the classes that inherit from this. This mixin is used both for
    ordered, unordered, frozen and mutable bags, so only the methods that are
    general to all of them are implemented here.
    '''
    def __init__(self, iterable=...) -> None:
        ...
    
    __getitem__ = ...
    def most_common(self, n=...): # -> tuple[Any, ...]:
        '''
        List the `n` most common elements and their counts, sorted.

        Results are sorted from the most common to the least. If `n is None`,
        then list all element counts.

            >>> Bag('abcdeabcdabcaba').most_common(3)
            (('a', 5), ('b', 4), ('c', 3))

        '''
        ...
    
    @property
    def elements(self): # -> chain[_T]:
        '''
        Iterate over elements repeating each as many times as its count.

            >>> c = Bag('ABCABC')
            >>> tuple(c.elements)
            ('A', 'B', 'A', 'B', 'C', 'C')

        '''
        ...
    
    def __contains__(self, item):
        ...
    
    n_elements = ...
    @property
    def frozen_bag_bag(self): # -> FrozenBagBag:
        '''
        A `FrozenBagBag` of this bag.

        This means, a bag where `3: 4` means "The original bag has 4 different
        keys with a value of 3."

        Example:

            >>> bag = Bag('abracadabra')
            >>> bag
            Bag({'b': 2, 'r': 2, 'a': 5, 'd': 1, 'c': 1})
            >>> bag.frozen_bag_bag
            FrozenBagBag({1: 2, 2: 2, 5: 1})

        '''
        ...
    
    def __or__(self, other): # -> _NotImplementedType | Self:
        '''
        Make a union bag of these two bags.

        The new bag will have, for each key, the higher of the two amounts for
        that key in the two original bags.

        Example:

            >>> Bag('abbb') | Bag('bcc')
            Bag({'b': 3, 'c': 2, 'a': 1})

        '''
        ...
    
    def __and__(self, other): # -> _NotImplementedType | Self:
        '''
        Make an intersection bag of these two bags.

        The new bag will have, for each key, the lower of the two amounts for
        that key in the two original bags.

        Example:

            >>> Bag('abbb') & Bag('bcc')
            Bag({'b': 1,})

        '''
        ...
    
    def __add__(self, other): # -> _NotImplementedType | Self:
        '''
        Make a sum bag of these two bags.

        The new bag will have, for each key, the sum of the two amounts for
        that key in each of the two original bags.

        Example:

            >>> Bag('abbb') + Bag('bcc')
            Bag({'b': 4, 'c': 2, 'a': 1})

        '''
        ...
    
    def __sub__(self, other): # -> _NotImplementedType | Self:
        '''
        Get the subtraction of one bag from another.

        This creates a new bag which has the items of the first bag minus the
        items of the second one. Negative counts are truncated to zero: If
        there are any items in the second bag that are more than the items in
        the first bag, the result for that key will simply be zero rather than
        a negative amount.
        '''
        ...
    
    def __mul__(self, other): # -> _NotImplementedType | Self:
        '''Get a new bag that has all counts multiplied by the integer `other`.'''
        ...
    
    __rmul__ = ...
    def __floordiv__(self, other): # -> Self | _NotImplementedType | Literal[0]:
        '''
        Do a floor-division `self // other`.

        `other` can be either an integer or a bag.

        If `other` is an integer, the result will be the biggest bag possible
        so that `result * other <= self`.

        If `other` is a bag, the result will be the maximum number of times you
        can put `other` inside of `self` without having it surpass `self` for
        any key. (Or in other words, the biggest integer possible so that
        `result * other <= self`.)
        '''
        ...
    
    def __mod__(self, other): # -> Self | _NotImplementedType:
        '''
        Do a modulo `self % other`.

        `other` can be either an integer or a bag.

        If `other` is an integer, the result will be a bag with `% other` done
        on the count of every item from `self`. Or you can also think of it as
        `self - (self // other)`, which happens to be the same bag.

        If `other` is a bag, the result will be the bag that's left when you
        subtract as many copies of `other` from this bag, until you can't
        subtract without truncating some keys. Or in other words, it's `self -
        (self // other)`.
        '''
        ...
    
    def __divmod__(self, other): # -> tuple[Self, Self] | tuple[Self | Any | _NotImplementedType | Literal[0], Self] | _NotImplementedType:
        '''
        Get `(self // other, self % other)`.

        If `other` is an integer, the first item of the result will be the
        biggest bag possible so that `result * other <= self`. The second item
        will be a bag with `% other` done on the count of every item from
        `self`, or you can also think of it as `self - (self // other)`, which
        happens to be the same bag.

        If `other` is a bag, the first item of the result will be the maximum
        number of times you can put `other` inside of `self` without having it
        surpass `self` for any key. (Or in other words, the biggest integer
        possible so that `result * other <= self`.) The second item will be the
        result of the first item subtracted from `self`.
        '''
        ...
    
    def __pow__(self, other, modulo=...): # -> _NotImplementedType | Self:
        '''Get a new bag with every item raised to the power of `other`.'''
        ...
    
    __bool__ = ...
    def __lt__(self, other) -> bool:
        '''
        `self` is a strictly smaller bag than `other`.

        That means that for every key in `self`, its count in `other` is bigger
        or equal than in `self`-- And there's at least one key for which the
        count in `other` is strictly bigger.

        Or in other words: `set(self.elements) < set(other.elements)`.
        '''
        ...
    
    def __gt__(self, other) -> bool:
        '''
        `self` is a strictly bigger bag than `other`.

        That means that for every key in `other`, its count in `other` is smaller
        or equal than in `self`-- And there's at least one key for which the
        count in `other` is strictly smaller.

        Or in other words: `set(self.elements) > set(other.elements)`.
        '''
        ...
    
    def __le__(self, other) -> bool:
        '''
        `self` is smaller or equal to `other`.

        That means that for every key in `self`, its count in `other` is bigger
        or equal than in `self`.

        Or in other words: `set(self.elements) <= set(other.elements)`.
        '''
        ...
    
    def __ge__(self, other) -> bool:
        '''
        `self` is bigger or equal to `other`.

        That means that for every key in `other`, its count in `other` is bigger
        or equal than in `self`.

        Or in other words: `set(self.elements) >= set(other.elements)`.
        '''
        ...
    
    def __repr__(self): # -> str:
        ...
    
    __deepcopy__ = ...
    def __reversed__(self):
        ...
    
    def get_contained_bags(self): # -> MapSpace:
        '''
        Get all bags that are subsets of this bag.

        This means all bags that have counts identical or smaller for each key.
        '''
        ...
    


class _MutableBagMixin(_BaseBagMixin):
    '''Mixin for a bag that's mutable. (i.e. not frozen.)'''
    def __setitem__(self, i, count): # -> None:
        ...
    
    def setdefault(self, key, default=...): # -> None:
        '''
        Get value of `key`, unless it's zero/missing, if so set to `default`.
        '''
        ...
    
    def __delitem__(self, key): # -> None:
        ...
    
    def pop(self, key, default=...): # -> type[_NO_DEFAULT] | Literal[0]:
        '''
        Remove `key` from the bag, returning its value.

        If `key` is missing and `default` is given, returns `default`.
        '''
        ...
    
    def __ior__(self, other): # -> _NotImplementedType | Self:
        '''
        Make this bag into a union bag of this bag and `other`.

        After the operation, this bag will have, for each key, the higher of
        the two amounts for that key in the two original bags.

            >>> bag = Bag('abbb')
            >>> bag |= Bag('bcc')
            >>> bag
            Bag({'b': 3, 'c': 2, 'a': 1})

        '''
        ...
    
    def __iand__(self, other): # -> _NotImplementedType | Self:
        '''
        Make this bag into an intersection bag of this bag and `other`.

        After the operation, this bag will have, for each key, the lower of the
        two amounts for that key in the two original bags.

            >>> bag = Bag('abbb')
            >>> bag &= Bag('bcc')
            >>> bag
            Bag({'b': 1,})

        '''
        ...
    
    def __iadd__(self, other): # -> _NotImplementedType | Self:
        '''
        Make this bag into a sum bag of this bag and `other`.

        After the operation, this bag will have, for each key, the sum of the
        two amounts for that key in each of the two original bags.

        Example:

            >>> bag = Bag('abbb')
            >>> bag += Bag('bcc')
            >>> bag
            Bag({'b': 4, 'c': 2, 'a': 1})

        '''
        ...
    
    def __isub__(self, other): # -> _NotImplementedType | Self:
        '''
        Subtract `other` from this bag.

        This reduces the count of each key in this bag by its count in `other`.
        Negative counts are truncated to zero: If there are any items in the
        second bag that are more than the items in the first bag, the result
        for that key will simply be zero rather than a negative amount.
        '''
        ...
    
    def __imul__(self, other): # -> _NotImplementedType | Self:
        '''Multiply all the counts in this bag by the integer `other`.'''
        ...
    
    def __ifloordiv__(self, other): # -> _NotImplementedType | Self:
        '''
        Make this bag into a floor-division `self // other`.

        `other` can be either an integer or a bag.

        If `other` is an integer, this bag will have all its counts
        floor-divided by `other`. (You can also think of it as: This bag will
        become the biggest bag possible so that if you multiply it by `other`,
        it'll still be smaller or equal to its old `self`.)

        If `other` is a bag, the result will be the maximum number of times you
        can put `other` inside of `self` without having it surpass `self` for
        any key. (Or in other words, the biggest integer possible so that
        `result * other <= self`.) Since this result is an integer rather than
        a bug, the result variable will be set to it but this bag wouldn't
        really be modified.
        '''
        ...
    
    def __imod__(self, other): # -> Self | _NotImplementedType:
        '''
        Make this bag int a modulo `self % other`.

        `other` can be either an integer or a bag.

        If `other` is an integer, the result will have all its counts modulo-ed
        by `other`. Or you can also think of it as becoming the bag `self -
        (self // other)`, which happens to be the same bag.

        If `other` is a bag, the result will be the bag that's left when you
        subtract as many copies of `other` from this bag, until you can't
        subtract without truncating some keys. Or in other words, it's `self -
        (self // other)`. Since this result is an integer rather than
        a bug, the result variable will be set to it but this bag wouldn't
        really be modified.
        '''
        ...
    
    def __ipow__(self, other, modulo=...): # -> _NotImplementedType | Self:
        '''Raise each count in this bag to the power of `other`.'''
        ...
    
    def popitem(self):
        '''
        Pop an item from this bag, returning `(key, count)` and removing it.
        '''
        ...
    
    def get_frozen(self):
        '''Get a frozen version of this bag.'''
        ...
    


class _OrderedBagMixin(Ordered):
    '''
    Mixin for a bag that's ordered.

    Items will be ordered according to insertion order. In every interface
    where items from this bag are iterated on, they will be returned by their
    order.
    '''
    __reversed__ = ...
    def __eq__(self, other) -> bool:
        '''
        Is this bag equal to `other`?

        Order *does* count, so if `other` has a different order, the result
        will be `False`.
        '''
        ...
    
    index = ...


class _FrozenBagMixin:
    '''Mixin for a bag that's frozen. (i.e. can't be changed, is hashable.)'''
    n_elements = ...
    @_BootstrappedCachedProperty
    def frozen_bag_bag(self): # -> FrozenBagBag:
        '''
        A `FrozenBagBag` of this bag.

        This means, a bag where `3: 4` means "The original bag has 4 different
        keys with a value of 3."

        Example:

            >>> bag = Bag('abracadabra')
            >>> bag
            Bag({'b': 2, 'r': 2, 'a': 5, 'd': 1, 'c': 1})
            >>> bag.frozen_bag_bag
            FrozenBagBag({1: 2, 2: 2, 5: 1})

        '''
        ...
    
    def get_mutable(self):
        '''Get a mutable version of this bag.'''
        ...
    
    _contained_bags = ...
    def get_contained_bags(self):
        '''
        Get all bags that are subsets of this bag.

        This means all bags that have counts identical or smaller for each key.
        '''
        ...
    


class _BaseDictDelegator(collections.abc.MutableMapping):
    '''
    Base class for a dict-like object.

    It has its `dict` functionality delegated to `self._dict` which actually
    implements the `dict` functionality. Subclasses override `_dict_type` to
    determine the type of `dict` to use. (Regular or ordered.)
    '''
    def __init__(self, dict=..., **kwargs) -> None:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __getitem__(self, key):
        ...
    
    def __setitem__(self, key, item): # -> None:
        ...
    
    def __delitem__(self, key): # -> None:
        ...
    
    def __iter__(self):
        ...
    
    def __contains__(self, key): # -> bool:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def copy(self): # -> _OrderedDictDelegator | Self:
        ...
    
    @classmethod
    def fromkeys(cls, iterable, value=...): # -> Self:
        ...
    


class _OrderedDictDelegator(Ordered, _BaseDictDelegator):
    '''
    An `OrderedDict`-like object.

    It has its `OrderedDict` functionality delegated to `self._dict` which is
    an actual `OrderedDict`.
    '''
    _dict_type = OrderedDict
    index = ...
    move_to_end = ...
    sort = ...


class _DictDelegator(_BaseDictDelegator):
    '''
    A `dict`-like object.

    It has its `dict` functionality delegated to `self._dict` which is an
    actual `dict`.
    '''
    _dict_type = dict


class Bag(_MutableBagMixin, _DictDelegator):
    '''
    A bag that counts items.

    This is a mapping between items and their count:

        >>> Bag('aaabcbc')
        Bag({'a': 3, 'b': 2, 'c': 2})

    It can be created from either an iterable like above, or from a `dict`.

    This class provides a lot of methods that `collections.Counter` doesn't;
    among them are a plethora of arithmetic operations (both between bags and
    bags and between bags and integers), comparison methods between bags, and
    more. This class is also more restricted than `collections.Counter`; only
    positive integers may be used as counts (zeros are weeded out), so we don't
    need to deal with all the complications of non-numerical counts.
    '''
    ...


class OrderedBag(_OrderedBagMixin, _MutableBagMixin, _OrderedDictDelegator):
    '''
    An ordered bag that counts items.

    This is a ordered mapping between items and their count:

        >>> OrderedBag('aaabcbc')
        OrderedBag((('a', 3), ('b', 2), ('c', 2)))

    It can be created from either an iterable like above, or from a `dict`.

    This class provides a lot of methods that `collections.Counter` doesn't;
    among them are a plethora of arithmetic operations (both between bags and
    bags and between bags and integers), comparison methods between bags, and
    more. This class is also more restricted than `collections.Counter`; only
    positive integers may be used as counts (zeros are weeded out), so we don't
    need to deal with all the complications of non-numerical counts.

    Also, unlike `collections.Counter`, items are ordered by insertion order.
    (Simliarly to `collections.OrderedDict`.)
    '''
    def popitem(self, last=...):
        '''
        Pop an item from this bag, returning `(key, count)` and removing it.

        By default, the item will be popped from the end. Pass `last=False` to
        pop from the start.
        '''
        ...
    
    move_to_end = ...
    sort = ...
    @property
    def reversed(self): # -> Self:
        '''Get a version of this `OrderedBag` with key order reversed.'''
        ...
    


class FrozenBag(_BaseBagMixin, _FrozenBagMixin, FrozenDict):
    '''
    An immutable bag that counts items.

    This is an immutable mapping between items and their count:

        >>> FrozenBag('aaabcbc')
        FrozenBag({'a': 3, 'b': 2, 'c': 2})

    It can be created from either an iterable like above, or from a `dict`.

    This class provides a lot of methods that `collections.Counter` doesn't;
    among them are a plethora of arithmetic operations (both between bags and
    bags and between bags and integers), comparison methods between bags, and
    more. This class is also more restricted than `collections.Counter`; only
    positive integers may be used as counts (zeros are weeded out), so we don't
    need to deal with all the complications of non-numerical counts.

    Also, unlike `collections.Counter`, it's immutable, therefore it's also
    hashable, and thus it can be used as a key in dicts and sets.
    '''
    def __hash__(self) -> int:
        ...
    


class FrozenOrderedBag(_OrderedBagMixin, _FrozenBagMixin, _BaseBagMixin, FrozenOrderedDict):
    '''
    An immutable, ordered bag that counts items.

    This is an ordered mapping between items and their count:

        >>> FrozenOrderedBag('aaabcbc')
        FrozenOrderedBag((('a', 3), ('b', 2), ('c', 2)))

    It can be created from either an iterable like above, or from a `dict`.

    This class provides a lot of methods that `collections.Counter` doesn't;
    among them are a plethora of arithmetic operations (both between bags and
    bags and between bags and integers), comparison methods between bags, and
    more. This class is also more restricted than `collections.Counter`; only
    positive integers may be used as counts (zeros are weeded out), so we don't
    need to deal with all the complications of non-numerical counts.

    Also, unlike `collections.Counter`:

     -  Items are ordered by insertion order. (Simliarly to
        `collections.OrderedDict`.)

     - It's immutable, therefore it's also hashable, and thus it can be used as
       a key in dicts and sets.

    '''
    def __hash__(self) -> int:
        ...
    
    @_BootstrappedCachedProperty
    def reversed(self): # -> Self:
        '''Get a version of this `FrozenOrderedBag` with key order reversed.'''
        ...
    


