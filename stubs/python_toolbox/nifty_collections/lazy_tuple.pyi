"""
This type stub file was generated by pyright.
"""

import functools
import collections
from python_toolbox import decorator_tools, misc_tools

infinity = ...
class _SENTINEL(misc_tools.NonInstantiable):
    '''Sentinel used to detect the end of an iterable.'''
    ...


@functools.total_ordering
class LazyTuple(collections.abc.Sequence):
    '''
    A lazy tuple which requests as few values as possible from its iterator.

    Wrap your iterators with `LazyTuple` and enjoy tuple-ish features like
    indexed access, comparisons, length measuring, element counting and more.

    Example:

        def my_generator():
            yield from ('hello', 'world', 'have', 'fun')

        lazy_tuple = LazyTuple(my_generator())

        assert lazy_tuple[2] == 'have'
        assert len(lazy_tuple) == 4

    `LazyTuple` holds the given iterable and pulls items out of it. It pulls as
    few items as it possibly can. For example, if you ask for the third
    element, it will pull exactly three elements and then return the third one.

    Some actions require exhausting the entire iterator. For example, checking
    the `LazyTuple` length, or doing indexex access with a negative index.
    (e.g. asking for the seventh-to-last element.)

    If you're passing in an iterator you definitely know to be infinite,
    specify `definitely_infinite=True`.
    '''
    def __init__(self, iterable, definitely_infinite=...) -> None:
        ...
    
    @classmethod
    @decorator_tools.helpful_decorator_builder
    def factory(cls, definitely_infinite=...):
        '''
        Decorator to make generators return a `LazyTuple`.

        Example:

            @LazyTuple.factory()
            def my_generator():
                yield from ['hello', 'world', 'have', 'fun']

        This works on any function that returns an iterator. todo: Make it work
        on iterator classes.
        '''
        ...
    
    @property
    def known_length(self): # -> int:
        '''
        The number of items which have been taken from the internal iterator.
        '''
        ...
    
    def exhaust(self, i=...): # -> None:
        '''
        Take items from the internal iterators and save them.

        This will take enough items so we will have `i` items in total,
        including the items we had before.
        '''
        ...
    
    def __getitem__(self, i): # -> tuple[Any, ...]:
        '''Get item by index, either an integer index or a slice.'''
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    
    def __bool__(self): # -> bool:
        ...
    
    def __lt__(self, other) -> bool:
        ...
    
    def __repr__(self): # -> str:
        '''
        Return a human-readeable representation of the `LazyTuple`.

        Example:

            <LazyTuple: (1, 2, 3, ...)>

        The '...' denotes a non-exhausted lazy tuple.
        '''
        ...
    
    def __add__(self, other): # -> tuple[Any, ...]:
        ...
    
    def __radd__(self, other): # -> tuple[Any, ...]:
        ...
    
    def __mul__(self, other): # -> tuple[Any, ...]:
        ...
    
    def __rmul__(self, other): # -> tuple[Any, ...]:
        ...
    
    def __hash__(self) -> int:
        '''
        Get the `LazyTuple`'s hash.

        Note: Hashing the `LazyTuple` will completely exhaust it.
        '''
        ...
    


