"""
This type stub file was generated by pyright.
"""

import functools
import abc
import collections
from python_toolbox import caching, sequence_tools

infinity = ...
class _BasePermView(metaclass=abc.ABCMeta):
    '''
    Abstract base class for viewers on Perm.
    '''
    def __init__(self, perm) -> None:
        ...
    
    __repr__ = ...
    @abc.abstractmethod
    def __getitem__(self, i): # -> None:
        ...
    


class PermItems(sequence_tools.CuteSequenceMixin, _BasePermView, collections.abc.Sequence):
    '''
    A viewer of a perm's items, similar to `dict.items()`.

    This is useful for dapplied perms; it lets you view the perm (both index
    access and iteration) as a sequence where each item is a 2-tuple, where the
    first item is from the domain and the second item is its corresponding item
    from the sequence.
    '''
    def __getitem__(self, i): # -> tuple[Any, Any]:
        ...
    


class PermAsDictoid(sequence_tools.CuteSequenceMixin, _BasePermView, collections.abc.Mapping):
    '''A dict-like interface to a `Perm`.'''
    def __getitem__(self, key):
        ...
    
    def __iter__(self):
        ...
    


class PermType(abc.ABCMeta):
    '''
    Metaclass for `Perm` and `Comb`.

    The functionality provided is: If someone tries to create a `Perm` with a
    `CombSpace`, we automatically use `Comb`.
    '''
    def __call__(cls, item, perm_space=...):
        ...
    


@functools.total_ordering
class Perm(sequence_tools.CuteSequenceMixin, collections.abc.Sequence, metaclass=PermType):
    '''
    A permutation of items from a `PermSpace`.

    In combinatorics, a permutation is a sequence of items taken from the
    original sequence.

    Example:

        >>> perm_space = PermSpace('abcd')
        >>> perm = Perm('dcba', perm_space)
        >>> perm
        <Perm: ('d', 'c', 'b', 'a')>
        >>> perm_space.index(perm)
        23

    '''
    @classmethod
    def coerce(cls, item, perm_space=...): # -> Perm | Self:
        '''Coerce item into a perm, optionally of a specified `PermSpace`.'''
        ...
    
    def __init__(self, perm_sequence, perm_space=...) -> None:
        '''
        Create the `Perm`.

        If `perm_space` is not supplied, we assume that this is a pure
        permutation, i.e. a permutation on `range(len(perm_sequence))`.
        '''
        ...
    
    _reduced = ...
    __iter__ = ...
    def __eq__(self, other) -> bool:
        ...
    
    __ne__ = ...
    __hash__ = ...
    __bool__ = ...
    def __contains__(self, item): # -> bool:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def index(self, member): # -> float | CuteRange | Any | int:
        '''
        Get the index number of `member` in the permutation.

        Example:

            >>> perm = PermSpace(5)[10]
            >>> perm
            <Perm: (0, 2, 4, 1, 3)>
            >>> perm.index(3)
            4

        '''
        ...
    
    @caching.CachedProperty
    def inverse(self): # -> Any | Self:
        '''
        The inverse of this permutation.

        i.e. the permutation that we need to multiply this permutation by to
        get the identity permutation.

        This is also accessible as `~perm`.

        Example:

            >>> perm = PermSpace(5)[10]
            >>> perm
            <Perm: (0, 2, 4, 1, 3)>
            >>> ~perm
            <Perm: (0, 3, 1, 4, 2)>
            >>> perm * ~perm
            <Perm: (0, 1, 2, 3, 4)>

        '''
        ...
    
    __invert__ = ...
    domain = ...
    @caching.CachedProperty
    def unrapplied(self): # -> Self:
        '''An unrapplied version of this permutation.'''
        ...
    
    undapplied = ...
    uncombinationed = ...
    def __getitem__(self, i):
        ...
    
    length = ...
    def apply(self, sequence, result_type=...): # -> LiteralString | Self | tuple[Any, ...]:
        '''
        Apply the perm to a sequence, choosing items from it.

        This can also be used as `sequence * perm`. Example:

            >>> perm = PermSpace(5)[10]
            >>> perm
            <Perm: (0, 2, 4, 1, 3)>
            >>> perm.apply('growl')
            'golrw'
            >>> 'growl' * perm
            'golrw'

        Specify `result_type` to determine the type of the result returned. If
        `result_type=None`, will use `tuple`, except when `other` is a `str` or
        `Perm`, in which case that same type would be used.
        '''
        ...
    
    __rmul__ = ...
    __mul__ = ...
    def __pow__(self, exponent): # -> PermSpace | Any:
        '''Raise the perm by the power of `exponent`.'''
        ...
    
    @caching.CachedProperty
    def degree(self): # -> _NotImplementedType:
        '''
        The permutation's degree.

        You can think of a permutation's degree like this: Imagine that you're
        starting with the identity permutation, and you want to make this
        permutation, by switching two items with each other over and over again
        until you get this permutation. The degree is the number of such
        switches you'll have to make.
        '''
        ...
    
    @caching.CachedProperty
    def n_cycles(self): # -> _NotImplementedType | Any | int:
        '''
        The number of cycles in this permutation.

        If item 1 points at item 7, and item 7 points at item 3, and item 3
        points at item 1 again, then that's one cycle. `n_cycles` is the total
        number of cycles in this permutation.
        '''
        ...
    
    def get_neighbors(self, *, degrees=..., perm_space=...): # -> MapSpace:
        '''
        Get the neighbor permutations of this permutation.

        This means, get the permutations that are close to this permutation. By
        default, this means permutations that are one transformation (switching
        a pair of items) away from this permutation. You can specify a custom
        sequence of integers to the `degrees` argument to get different degrees
        of relation. (e.g. specify `degrees=(1, 2)` to get both the closest
        neighbors and the second-closest neighbors.)
        '''
        ...
    
    def __lt__(self, other) -> bool:
        ...
    
    __reversed__ = ...
    items = ...
    as_dictoid = ...


class UnrecurrentedMixin:
    '''Mixin for a permutation in a space that's been unrecurrented.'''
    def __getitem__(self, i):
        ...
    
    def __iter__(self): # -> Iterator[Any]:
        ...
    
    index = ...


class UnrecurrentedPerm(UnrecurrentedMixin, Perm):
    '''A permutation in a space that's been unrecurrented.'''
    ...


