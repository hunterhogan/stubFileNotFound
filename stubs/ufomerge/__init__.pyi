"""
This type stub file was generated by pyright.
"""

import copy
import logging
import re
import fontTools.feaLib.ast as ast
from io import StringIO
from collections import defaultdict
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any, Iterable, Mapping, Optional, OrderedDict, Set, Tuple, Union
from fontTools.feaLib.parser import Parser
from ufoLib2 import Font
from ufoLib2.objects import Anchor, Glyph, Layer, LayerSet
from ufomerge.layout import LayoutClosureVisitor, LayoutSubsetter, LookupBlockGatherer
from ufomerge.scaler import scale_ufo

logger = ...
OBJECT_LIBS_KEY = ...
@dataclass
class UFOMerger:
    ufo1: Font
    ufo2: Font
    glyphs: Iterable[str] = ...
    exclude_glyphs: Iterable[str] = ...
    codepoints: Iterable[int] = ...
    layout_handling: str = ...
    existing_handling: Union[str, dict[str, str]] = ...
    kern_handling: str = ...
    duplicate_lookup_handling: str = ...
    include_dir: Path | None = ...
    merge_dotted_circle_anchors: bool = ...
    original_glyphlist: Iterable[str] | None = ...
    incoming_glyphset: dict[str, bool] = ...
    final_glyphset: Set[str] = ...
    blacklisted: Set[str] = ...
    ufo2_features: ast.FeatureFile = ...
    ufo2_languagesystems: list[Tuple[str, str]] = ...
    dotted_circle_anchors: list[Anchor] = ...
    def __post_init__(self): # -> None:
        ...
    
    def policy(self, glyph: str) -> str:
        """Return the policy for a given glyph"""
        ...
    
    def merge(self): # -> None:
        ...
    
    def close_components(self, glyph: str): # -> None:
        """Add any needed components, recursively"""
        ...
    
    def filter_glyphs_incoming(self, glyphs: Iterable[str]) -> list[str]:
        ...
    
    def add_language_systems(self, incoming_languagesystems): # -> None:
        ...
    
    def discover_hidden_classes(self) -> set:
        ...
    
    def merge_kerning(self): # -> None:
        ...
    
    def merged_dotted_circle_anchors(self): # -> list[Any] | list[Anchor]:
        ...
    
    def handle_dotted_circle(self): # -> None:
        ...
    
    def merge_set(self, name, glyph, create_if_not_in_ufo1=...): # -> None:
        ...
    
    def merge_dict(self, name, glyph, create_if_not_in_ufo1=...): # -> None:
        ...
    
    def find_dotted_circle(self, ufo) -> Optional[Glyph]:
        ...
    


def merge_ufos(ufo1: Font, ufo2: Font, glyphs: Iterable[str] = ..., exclude_glyphs: Iterable[str] = ..., codepoints: Iterable[int] = ..., layout_handling: str = ..., existing_handling: str = ..., duplicate_lookup_handling: str = ..., kern_handling: str = ..., include_dir: Path | None = ..., original_glyphlist: Iterable[str] | None = ..., merge_dotted_circle_anchors: bool = ...) -> None:
    """Merge two UFO files together

    Returns nothing but modifies ufo1.

    Args:
        ufo1: The destination UFO which will receive the new glyphs.
        ufo2: The "donor" UFO which will provide the new glyphs.
        glyphs: Optionally, a list of glyph names to be added. If not
            present and codepoints is also not present, all glyphs from
            the donor UFO will be added.
        exclude_glyphs: Optionally, a list of glyph names which should
            not be added.
        codepoints: A list of Unicode codepoints as integers. If present,
            the glyphs with these codepoints will be selected for merging.
        layout_handling: One of either "subset", "closure" or "ignore".
            "ignore" means that no layout rules are added from UFO2.
            "closure" means that the list of donor glyphs will be expanded
            such that any substitutions in UFO2 involving the selected
            glyphs will continue to work. "subset" means that the rules
            are slimmed down to only include the given glyphs. For example,
            if there is a rule "sub A B by C;", and glyphs==["A", "B"],
            then when layout_handling=="subset", this rule will be dropped;
            but if layout_handling=="closure", glyph C will also be merged
            so that the ligature still works. The default is "subset".
        duplicate_lookup_handling: One of either "first", "second", or "both".
            What to do if lookups in the donor font are already present in
            the target font. "first" will take the lookup from the
            target font. "second" will take the lookup from the donor
            font (this is not currently implemented). "both" will add the
            lookup regardless (this will probably not compile).
            The default is "first".
        existing_handling: One of either "replace" or "skip". What to do
            if the donor glyph already exists in UFO1: "replace" replaces
            it with the version in UFO2; "skip" keeps the existing glyph.
            The default is "replace". Alternatively, a dictionary
            mapping glyph names to "replace" or "skip" can be provided;
            the name "DEFAULT" can be used to set the default for any glyphs
            not in the dictionary.
        kern_handling: One of either "conservative" or "aggressive". How
            to handle kerning groups. "conservative" will remove any
            glyphs which are not being imported from the donor's kerning
            groups before merging. "aggressive" will merge the groups
            regardless of whether the glyphs are being imported or not.
            The default is "conservative".
        include_dir: The directory to look for include files in. If not
            present, probes the UFO2 object for directory information.
        original_glyphlist: The original glyph list for UFO2, for when you
            already have a UFO with subset glyphs, but still need to subset
            the features.
    """
    ...

def subset_ufo(ufo: Font, glyphs: Iterable[str] = ..., exclude_glyphs: Iterable[str] = ..., codepoints: Iterable[int] = ..., layout_handling: str = ..., include_dir: Path | None = ..., original_glyphlist: Iterable[str] | None = ...) -> Font:
    """Creates a new UFO with only the provided glyphs.

    Returns a new UFO object.

    Args:
        ufo: The UFO to subset.
        glyphs: A list of glyph names to be added. If not present and
            codepoints is also not present, all glyphs UFO will be added.
        exclude_glyphs: Optionally, a list of glyph names which should
            not be added.
        codepoints: A list of Unicode codepoints as integers. If present,
            the glyphs with these codepoints will be selected for merging.
        layout_handling: One of either "subset", "closure" or "ignore".
            "ignore" means that no layout rules are added from the font.
            "closure" means that the list of donor glyphs will be expanded
            such that any substitutions in the font involving the selected
            glyphs will continue to work. "subset" means that the rules
            are slimmed down to only include the given glyphs. For example,
            if there is a rule "sub A B by C;", and glyphs==["A", "B"],
            then when layout_handling=="subset", this rule will be dropped;
            but if layout_handling=="closure", glyph C will also be merged
            so that the ligature still works. The default is "subset".
        include_dir: The directory to look for include files in. If not
            present, probes the UFO2 object for directory information.
        original_glyphlist: The original glyph list for UFO, for when you
            already have a UFO with subset glyphs, but still need to subset
            the features.
    """
    ...

