"""
This type stub file was generated by pyright.
"""

from builtins import *
from numpy_indexed.funcs import *
from numpy_indexed.index import *

"""this is a rewrite and extension of numpy arraysetops module using the indexing class hierarchy.

the main purpose is to expand functionality to multidimensional arrays,
but it also is much more readable and DRY than numpy.arraysetops
"""
__author__ = ...
__license__ = ...
__email__ = ...
def unique(keys, axis=..., return_index=..., return_inverse=..., return_count=...): # -> ndarray[_Shape, dtype[Any]] | tuple[Any, ...] | ndarray[_Shape, dtype[intp]] | tuple[ndarray[_Shape, dtype[Any]] | tuple[Any, ...] | ndarray[_Shape, dtype[intp]] | Any, ...] | tuple[ndarray[_Shape, dtype[Any]] | tuple[Any, ...], ...] | tuple[ndarray[_Shape, dtype[Any]] | tuple[Any, ...], ndarray[_Shape, dtype[intp]] | Any]:
    """compute the set of unique keys

    Parameters
    ----------
    keys : indexable key object
        keys object to find unique keys within
    axis : int
        if keys is a multi-dimensional array, the axis to regard as the sequence of key objects
    return_index : bool
        if True, return indexes such that keys[index] == unique
    return_inverse : bool
        if True, return the indices such that unique[inverse] == keys
    return_count : bool
        if True, return the number of times each unique key occurs in the input

    Notes
    -----
    The kwargs are there to provide a backwards compatible interface to numpy.unique, but arguably,
    it is cleaner to call index and its properties directly, should more than unique values be desired as output
    """
    ...

def contains(this, that, axis=...): # -> ndarray[_Shape, dtype[Any]]:
    """Returns bool for each element of `that`, indicating if it is contained in `this`

    Parameters
    ----------
    this : indexable key sequence
        sequence of items to test against
    that : indexable key sequence
        sequence of items to test for

    Returns
    -------
    ndarray, [that.size], bool
        returns a bool for each element in `that`, indicating if it is contained in `this`

    Notes
    -----
    Reads as 'this contains that'
    Similar to 'that in this', but with different performance characteristics
    """
    ...

def in_(this, that, axis=...): # -> Any:
    """Returns bool for each element of `this`, indicating if it is present in `that`

    Parameters
    ----------
    this : indexable key sequence
        sequence of items to test for
    that : indexable key sequence
        sequence of items to test against

    Returns
    -------
    ndarray, [that.size], bool
        returns a bool for each element in `this`, indicating if it is present in `that`

    Notes
    -----
    Reads as 'this in that'
    Similar to 'that contains this', but with different performance characteristics
    """
    ...

def indices(this, that, axis=..., missing=...): # -> NDArray[intp] | masked_array:
    """Find indices such that this[indices] == that
    If multiple indices satisfy this condition, the first index found is returned

    Parameters
    ----------
    this : indexable object
        items to search in
    that : indexable object
        items to search for
    axis : int, optional
        axis to operate on
    missing : {'raise', 'ignore', 'mask' or int}
        if `missing` is 'raise', a KeyError is raised if not all elements of `that` are present in `this`
        if `missing` is 'mask', a masked array is returned,
        where items of `that` not present in `this` are masked out
        if `missing` is 'ignore', all elements of `that` are assumed to be present in `this`,
        and output is undefined otherwise
        if missing is an integer, this is used as a fill-value

    Returns
    -------
    indices : ndarray, [that.size], int
        indices such that this[indices] == that

    Notes
    -----
    May be regarded as a vectorized numpy equivalent of list.index
    """
    ...

def remap(input, keys, values, missing=..., inplace=...): # -> NDArray[Any]:
    """Given an input array, remap its entries corresponding to 'keys' to 'values'
    equivalent of output = [map.get(i, default=i) for i in input],
    if map were a dictionary of corresponding keys and values

    Parameters
    ----------
    input : ndarray, [...]
        values to perform replacements in
    keys : ndarray, [...]
        values to perform replacements in
    values : ndarray, [...]
        values to perform replacements in
    missing : {'raise', 'ignore'}
        if `missing` is 'raise', a KeyError is raised if 'values' contains elements not present in 'keys'
        if `missing` is 'ignore', only elements of 'values' persent in 'keys' are remapped
    inplace : bool, optional
        if True, input array is remapped in place
        if false, a copy is returned

    Returns
    -------
    output : ndarray, [...]
        like 'input', but with elements remapped according to the mapping defined by 'keys' and 'values'
    """
    ...

def union(*sets, **kwargs): # -> ndarray[_Shape, dtype[Any]] | tuple[Any, ...]:
    """all unique items which occur in any one of the sets

    Parameters
    ----------
    sets : tuple of indexable objects

    Returns
    -------
    union of all items in all sets
    """
    ...

def intersection(*sets, **kwargs): # -> ndarray[_Shape, dtype[Any]]:
    """perform intersection on an sequence of sets; items which are in all sets

    Parameters
    ----------
    sets : tuple of indexable objects

    Returns
    -------
    intersection of all items in all sets
    """
    ...

def exclusive(*sets, **kwargs): # -> ndarray[_Shape, dtype[Any]]:
    """return items which are exclusive to one of the sets;

    Parameters
    ----------
    sets : tuple of indexable objects

    Returns
    -------
    items which are exclusive to any one of the sets

    Notes
    -----
    this is a generalization of xor
    what to do with repeated items in original sets?
    assume_unique kwarg allows toggling
    """
    ...

def difference(*sets, **kwargs): # -> ndarray[_Shape, dtype[Any]]:
    """subtracts all tail sets from the head set

    Parameters
    ----------
    sets : tuple of indexable objects
        first set is the head, from which we subtract
        other items form the tail, which are subtracted from head

    Returns
    -------
    items which are in the head but not in any of the tail sets

    Notes
    -----
    alt implementation: compute union of tail, then union with head, then use set_count(1)
    """
    ...

__all__ = ['unique', 'contains', 'in_', 'indices', 'remap', 'union', 'intersection', 'exclusive', 'difference']
