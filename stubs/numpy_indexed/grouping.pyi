"""
This type stub file was generated by pyright.
"""

from builtins import *

"""grouping module"""
__author__ = ...
__license__ = ...
__email__ = ...
class GroupBy:
    """
    GroupBy class

    contains an index of keys, and extends the index functionality with grouping-specific functionality
    """
    def __init__(self, keys, axis=...) -> None:
        """
        Parameters
        ----------
        keys : indexable object
            sequence of keys to group by
        axis : int, optional
            axis to regard as the key-sequence, in case keys is multi-dimensional

        See Also
        --------
        numpy_indexed.as_index : for information regarding the casting rules to a valid Index object
        """
        ...
    
    @property
    def unique(self): # -> ndarray[_Shape, dtype[Any]] | tuple[Any, ...]:
        """unique keys"""
        ...
    
    @property
    def count(self): # -> NDArray[Any]:
        """count of each unique key"""
        ...
    
    @property
    def inverse(self): # -> _Array1D[Any]:
        """mapping such that unique[inverse]==keys"""
        ...
    
    @property
    def groups(self): # -> int:
        """int, number of groups formed by the keys"""
        ...
    
    def split_iterable_as_iterable(self, values): # -> Generator[Generator[Any, None, None], Any, None]:
        """Group iterable into iterables, in the order of the keys

        Parameters
        ----------
        values : iterable of length equal to keys
            iterable of values to be grouped

        Yields
        ------
        iterable of items in values

        Notes
        -----
        Memory consumption depends on the amount of sorting required
        Worst case, if index.sorter[-1] = 0, we need to consume the entire value iterable,
        before we can start yielding any output
        But to the extent that the keys are already sorted, the grouping is lazy
        """
        ...
    
    def split_iterable_as_unordered_iterable(self, values): # -> Generator[tuple[ndarray[_Shape, dtype[Any]] | tuple[Any, ...], list[Any]], Any, None]:
        """Group iterable into iterables, without regard for the ordering of self.index.unique
        key-group tuples are yielded as soon as they are complete

        Parameters
        ----------
        values : iterable of length equal to keys
            iterable of values to be grouped

        Yields
        ------
        tuple of key, and a list of corresponding items in values

        Notes
        -----
        This approach is lazy, insofar as grouped values are close in their iterable
        """
        ...
    
    def split_sequence_as_iterable(self, values): # -> Generator[Generator[Any, None, None], Any, None]:
        """Group sequence into iterables

        Parameters
        ----------
        values : iterable of length equal to keys
            iterable of values to be grouped

        Yields
        ------
        iterable of items in values

        Notes
        -----
        This is the preferred method if values has random access, but we dont want it completely in memory.
        Like a big memory mapped file, for instance
        """
        ...
    
    def split_array_as_array(self, values): # -> ndarray[_Shape, dtype[Any]]:
        """Group ndarray into ndarray by means of reshaping

        Parameters
        ----------
        values : ndarray_like, [index.size, ...]

        Returns
        -------
        ndarray, [groups, group_size, ...]
            values grouped by key

        Raises
        ------
        AssertionError
            This operation is only possible if index.uniform==True
        """
        ...
    
    def split_array_as_list(self, values): # -> list[NDArray[Any]]:
        """Group values as a list of arrays, or a jagged-array

        Parameters
        ----------
        values : ndarray, [keys, ...]

        Returns
        -------
        list of length self.groups of ndarray, [key_count, ...]
        """
        ...
    
    def split(self, values): # -> ndarray[_Shape, dtype[Any]] | list[NDArray[Any]]:
        """some sensible defaults"""
        ...
    
    def __call__(self, values): # -> tuple[ndarray[_Shape, dtype[Any]] | tuple[Any, ...], ndarray[_Shape, dtype[Any]] | list[NDArray[Any]]]:
        """not sure how i feel about this. explicit is better than implict?"""
        ...
    
    def reduce(self, values, operator=..., axis=..., dtype=...): # -> NDArray[Any]:
        """Reduce the values over identical key groups, using the given ufunc
        reduction is over the first axis, which should have elements corresponding to the keys
        all other axes are treated indepenently for the sake of this reduction

        Parameters
        ----------
        values : ndarray, [keys, ...]
            values to perform reduction over
        operator : numpy.ufunc
            a numpy ufunc, such as np.add or np.sum
        axis : int, optional
            the axis to reduce over
        dtype : output dtype

        Returns
        -------
        ndarray, [groups, ...]
        values reduced by operator over the key-groups
        """
        ...
    
    def sum(self, values, axis=..., dtype=...): # -> tuple[ndarray[_Shape, dtype[Any]] | tuple[Any, ...], NDArray[Any] | Any]:
        """compute the sum over each group

        Parameters
        ----------
        values : array_like, [keys, ...]
            values to sum per group
        axis : int, optional
            alternative reduction axis for values
        dtype : output dtype

        Returns
        -------
        unique: ndarray, [groups]
            unique keys
        reduced : ndarray, [groups, ...]
            value array, reduced over groups
        """
        ...
    
    def prod(self, values, axis=..., dtype=...): # -> tuple[ndarray[_Shape, dtype[Any]] | tuple[Any, ...], NDArray[Any] | Any]:
        """compute the product over each group

        Parameters
        ----------
        values : array_like, [keys, ...]
            values to multiply per group
        axis : int, optional
            alternative reduction axis for values
        dtype : output dtype

        Returns
        -------
        unique: ndarray, [groups]
            unique keys
        reduced : ndarray, [groups, ...]
            value array, reduced over groups
        """
        ...
    
    def mean(self, values, axis=..., weights=..., dtype=...): # -> tuple[ndarray[_Shape, dtype[Any]] | tuple[Any, ...], NDArray[float64] | Any]:
        """compute the mean over each group

        Parameters
        ----------
        values : array_like, [keys, ...]
            values to take average of per group
        axis : int, optional
            alternative reduction axis for values
        weights : ndarray, [keys, ...], optional
            weight to use for each value
        dtype : output dtype

        Returns
        -------
        unique: ndarray, [groups]
            unique keys
        reduced : ndarray, [groups, ...]
            value array, reduced over groups
        """
        ...
    
    def var(self, values, axis=..., weights=..., dtype=...): # -> tuple[ndarray[_Shape, dtype[Any]] | tuple[Any, ...], NDArray[float64] | Any]:
        """compute the variance over each group

        Parameters
        ----------
        values : array_like, [keys, ...]
            values to take variance of per group
        axis : int, optional
            alternative reduction axis for values

        Returns
        -------
        unique: ndarray, [groups]
            unique keys
        reduced : ndarray, [groups, ...]
            value array, reduced over groups
        """
        ...
    
    def std(self, values, axis=..., weights=..., dtype=...): # -> tuple[ndarray[_Shape, dtype[Any]] | tuple[Any, ...], NDArray[Any]]:
        """standard deviation over each group

        Parameters
        ----------
        values : array_like, [keys, ...]
            values to take standard deviation of per group
        axis : int, optional
            alternative reduction axis for values

        Returns
        -------
        unique: ndarray, [groups]
            unique keys
        reduced : ndarray, [groups, ...]
            value array, reduced over groups
        """
        ...
    
    def median(self, values, axis=..., average=...): # -> tuple[ndarray[_Shape, dtype[Any]] | tuple[Any, ...], NDArray[Any] | NDArray[float64]]:
        """compute the median value over each group.

        Parameters
        ----------
        values : array_like, [keys, ...]
            values to compute the median of per group
        axis : int, optional
            alternative reduction axis for values
        average : bool, optional
            when average is true, the average of the two central values is taken for groups with an even key-count

        Returns
        -------
        unique: ndarray, [groups]
            unique keys
        reduced : ndarray, [groups, ...]
            value array, reduced over groups
        """
        ...
    
    def mode(self, values, weights=...): # -> tuple[ndarray[_Shape, dtype[Any]] | tuple[Any, ...] | Any, Any]:
        """compute the mode within each group.

        Parameters
        ----------
        values : array_like, [keys, ...]
            values to compute the mode of per group
        weights : array_like, [keys], float, optional
            optional weight associated with each entry in values

        Returns
        -------
        unique: ndarray, [groups]
            unique keys
        reduced : ndarray, [groups, ...]
            value array, reduced over groups
        """
        ...
    
    def min(self, values, axis=...): # -> tuple[ndarray[_Shape, dtype[Any]] | tuple[Any, ...], NDArray[Any] | Any]:
        """return the minimum within each group

        Parameters
        ----------
        values : array_like, [keys, ...]
            values to take minimum of per group
        axis : int, optional
            alternative reduction axis for values

        Returns
        -------
        unique: ndarray, [groups]
            unique keys
        reduced : ndarray, [groups, ...]
            value array, reduced over groups
        """
        ...
    
    def max(self, values, axis=...): # -> tuple[ndarray[_Shape, dtype[Any]] | tuple[Any, ...], NDArray[Any] | Any]:
        """return the maximum within each group

        Parameters
        ----------
        values : array_like, [keys, ...]
            values to take maximum of per group
        axis : int, optional
            alternative reduction axis for values

        Returns
        -------
        unique: ndarray, [groups]
            unique keys
        reduced : ndarray, [groups, ...]
            value array, reduced over groups
        """
        ...
    
    def first(self, values, axis=...): # -> tuple[ndarray[_Shape, dtype[Any]] | tuple[Any, ...], NDArray[Any]]:
        """return values at first occurance of its associated key

        Parameters
        ----------
        values : array_like, [keys, ...]
            values to pick the first value of per group
        axis : int, optional
            alternative reduction axis for values

        Returns
        -------
        unique: ndarray, [groups]
            unique keys
        reduced : ndarray, [groups, ...]
            value array, reduced over groups
        """
        ...
    
    def last(self, values, axis=...): # -> tuple[ndarray[_Shape, dtype[Any]] | tuple[Any, ...], NDArray[Any]]:
        """return values at last occurance of its associated key

        Parameters
        ----------
        values : array_like, [keys, ...]
            values to pick the last value of per group
        axis : int, optional
            alternative reduction axis for values

        Returns
        -------
        unique: ndarray, [groups]
            unique keys
        reduced : ndarray, [groups, ...]
            value array, reduced over groups
        """
        ...
    
    def any(self, values, axis=...): # -> tuple[ndarray[_Shape, dtype[Any]] | tuple[Any, ...], NDArray[numpy.bool[builtins.bool]] | Any]:
        """compute if any item evaluates to true in each group

        Parameters
        ----------
        values : array_like, [keys, ...]
            values to take boolean predicate over per group
        axis : int, optional
            alternative reduction axis for values

        Returns
        -------
        unique: ndarray, [groups]
            unique keys
        reduced : ndarray, [groups, ...], bool
            value array, reduced over groups
        """
        ...
    
    def all(self, values, axis=...): # -> tuple[ndarray[_Shape, dtype[Any]] | tuple[Any, ...], Any]:
        """compute if all items evaluates to true in each group

        Parameters
        ----------
        values : array_like, [keys, ...]
            values to take boolean predicate over per group
        axis : int, optional
            alternative reduction axis for values

        Returns
        -------
        unique: ndarray, [groups]
            unique keys
        reduced : ndarray, [groups, ...], bool
            value array, reduced over groups
        """
        ...
    
    def argmin(self, values): # -> tuple[ndarray[_Shape, dtype[Any]] | tuple[Any, ...], ndarray[_Shape, dtype[intp]] | Any]:
        """return the index into values corresponding to the minimum value of the group

        Parameters
        ----------
        values : array_like, [keys]
            values to pick the argmin of per group

        Returns
        -------
        unique: ndarray, [groups]
            unique keys
        argmin : ndarray, [groups]
            index into value array, representing the argmin per group
        """
        ...
    
    def argmax(self, values): # -> tuple[ndarray[_Shape, dtype[Any]] | tuple[Any, ...], ndarray[_Shape, dtype[intp]] | Any]:
        """return the index into values corresponding to the maximum value of the group

        Parameters
        ----------
        values : array_like, [keys]
            values to pick the argmax of per group

        Returns
        -------
        unique: ndarray, [groups]
            unique keys
        argmax : ndarray, [groups]
            index into value array, representing the argmax per group
        """
        ...
    


def group_by(keys, values=..., reduction=..., axis=...): # -> GroupBy | tuple[ndarray[_Shape, dtype[Any]] | tuple[Any, ...], ndarray[_Shape, dtype[Any]] | list[NDArray[Any]]] | list[tuple[Any, Any]]:
    """construct a grouping object on the given keys, optionally performing the given reduction on the given values

    Parameters
    ----------
    keys : indexable object
        keys to group by
    values : array_like, optional
        sequence of values, of the same length as keys
        if a reduction function is provided, the given values are reduced by key
        if no reduction is provided, the given values are grouped and split by key
    reduction : lambda, optional
        reduction function to apply to the values in each group
    axis : int, optional
        axis to regard as the key-sequence, in case keys is multi-dimensional

    Returns
    -------
    iterable
        if values is None, a GroupBy object of the given keys object
        if reduction is None, an tuple of a sequence of unique keys and a sequence of grouped values
        else, a sequence of tuples of unique keys and reductions of values over that key-group

    See Also
    --------
    numpy_indexed.as_index : for information regarding the casting rules to a valid Index object
    """
    ...

__all__ = ['group_by']
