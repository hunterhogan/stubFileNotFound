"""
This type stub file was generated by pyright.
"""

from builtins import *
from numpy_indexed.utility import *

"""class hierarchy for indexing a set of keys

A note on naming: 'Index' here refers to the fact that the goal of these classes is to
perform and store precomputations on a set of keys, such as to accelerate subsequent operations involving these keys.
They are not 'logical' indexes as in pandas; they are not permanently associated with any other data objects

Note that these classes are not primarily intended to be used directly from the numpy_indexed namespace,
but rather are intended for code reuse within a family of higher level operations.

That said, these classes can also be very useful by themselves, in those places where the standard operations
do not quite cover your needs, saving your from completely reinventing the wheel.

notes:
    do we need to work more with cached properties here?
    generally, what is necessary and significant to precompute is pretty obvious
    but sometimes, even the sorting might not be required

    do we need to give index a stable flag?
    for grouping, stable sort is generally desirable,
    whereas for set operations, we are better off using the fastest sort
"""
__author__ = ...
__license__ = ...
__email__ = ...
class BaseIndex:
    """
    minimal indexing functionality
    only provides unique and counts, but with optimal performance
    no grouping, or lex-keys are supported,
    or anything that would require an indirect sort
    """
    def __init__(self, keys) -> None:
        """
        keys is a flat array of possibly composite type
        """
        ...
    
    @property
    def keys(self): # -> ndarray[tuple[int], dtype[Any]]:
        ...
    
    @property
    def sorted_keys(self): # -> NDArray[Any]:
        ...
    
    @property
    def size(self): # -> int:
        """number of keys"""
        ...
    
    @property
    def start(self): # -> ndarray[_Shape, dtype[Any]]:
        """start index of all bins"""
        ...
    
    @property
    def stop(self): # -> ndarray[_Shape, dtype[Any]]:
        """stop index of all bins"""
        ...
    
    @property
    def unique(self): # -> ndarray[_Shape, dtype[Any]]:
        """all unique keys"""
        ...
    
    @property
    def groups(self): # -> int:
        """number of unique keys"""
        ...
    
    @property
    def count(self): # -> NDArray[Any]:
        """number of times each key occurs"""
        ...
    
    @property
    def uniform(self): # -> bool:
        """returns true if each key occurs an equal number of times"""
        ...
    


class Index(BaseIndex):
    """
    index object over a set of keys
    adds support for more extensive functionality, notably grouping
    relies on indirect sorting
    maybe it should be called argindex?
    """
    def __init__(self, keys, stable) -> None:
        """
        keys is a flat array of possibly composite type

        if stable is true, stable sorting of the keys is used. stable sorting is required
        uf first and last properties are required
        """
        ...
    
    @property
    def sorted_group_rank_per_key(self): # -> NDArray[Any]:
        """find a better name for this? enumeration of sorted keys. also used in median implementation"""
        ...
    
    @property
    def inverse(self): # -> _Array1D[Any]:
        """return index array that maps unique values back to original space. unique[inverse]==keys"""
        ...
    
    @property
    def rank(self): # -> _Array1D[Any]:
        """how high in sorted list each key is. inverse permutation of sorter, such that sorted[rank]==keys"""
        ...
    
    @property
    def index(self): # -> ndarray[_Shape, dtype[intp]]:
        """returns indices such that keys[index]==unique
        not sure of the use case, but included for backwards compatibility with np.unique"""
        ...
    


class ObjectIndex(Index):
    """
    given axis enumerates the keys
    all other axes form the keys
    groups will be formed on the basis of bitwise equality between void objects

    should we retire objectindex?
    this can be integrated with regular index ala lexsort, no?
    not sure what is more readable though
    """
    def __init__(self, keys, axis, stable) -> None:
        ...
    
    @property
    def keys(self): # -> NDArray[Any]:
        ...
    
    @property
    def sorted_keys(self): # -> NDArray[Any]:
        ...
    
    @property
    def unique(self): # -> ndarray[_Shape, dtype[Any]]:
        """the first entry of each bin is a unique key"""
        ...
    


class LexIndex(Index):
    """
    index object based on lexographic ordering of a tuple of key-arrays
    key arrays can be any type, including multi-dimensional, structed or voidobjects
    however, passing such fancy keys to lexindex may not be ideal from a performance perspective,
    as lexsort does not accept them as arguments directly, so we have to index and invert them first

    should you find yourself with such complex keys, it may be more efficient
    to place them into a structured array first

    note that multidimensional columns are indexed by their first column,
    and no per-column axis keyword is supplied,
    customization of column layout will have to be done at the call site
    """
    def __init__(self, keys, stable) -> None:
        ...
    
    @property
    def unique(self): # -> tuple[Any, ...]:
        """returns a tuple of unique key columns"""
        ...
    
    @property
    def size(self): # -> Any:
        ...
    
    def take(self, keys, indices): # -> tuple[Any, ...]:
        ...
    
    def concatenate(self, *others): # -> None:
        ...
    


class LexIndexSimple(Index):
    """
    simplified LexIndex, which only accepts 1-d arrays of simple dtypes
    the more expressive LexIndex only has some logic overhead,
    in case all columns are indeed simple. not sure this is worth the extra code
    """
    def __init__(self, keys) -> None:
        ...
    
    @property
    def unique(self): # -> tuple[ndarray[_Shape, dtype[Any]], ...]:
        """the first entry of each bin is a unique key"""
        ...
    
    @property
    def size(self): # -> Any:
        ...
    


def as_index(keys, axis=..., base=..., stable=..., lex_as_struct=...): # -> Index | LexIndex | BaseIndex | ObjectIndex:
    """
    casting rules for a keys object to an index object

    the preferred semantics is that keys is a sequence of key objects,
    except when keys is an instance of tuple,
    in which case the zipped elements of the tuple are the key objects

    the axis keyword specifies the axis which enumerates the keys
    if axis is None, the keys array is flattened
    if axis is 0, the first axis enumerates the keys
    which of these two is the default depends on whether backwards_compatible == True

    if base==True, the most basic index possible is constructed.
    this avoids an indirect sort; if it isnt required, this has better performance
    """
    ...

__all__ = ['as_index']
