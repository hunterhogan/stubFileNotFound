"""
This type stub file was generated by pyright.
"""

__all__ = ['Mutator', 'buildMutator']
_EPSILON = ...
def noBend(loc):
    ...

def buildMutator(items, axes=..., bias=...): # -> tuple[Any | Location, Mutator]:
    """
        Build a mutator with the (location, obj) pairs in items.
        Determine the bias based on the given locations.
    """
    ...

class Mutator(dict):
    """
        Calculator for multi dimensional interpolations.

    ::

        # The mutator needs one neutral object.
        m = Mutator(myNeutralMathObject)

        # The mutator needs one or more deltas.
        m.addDelta(Location(pop=1), myMasterMathObject-myNeutralMathObject)

        # The mutator calculates instances at other locations. Remember to inflate.
        m.getInstance(Location(pop=0.5)) + myNeutralMathObject

    """
    def __init__(self, neutral=...) -> None:
        ...
    
    def setBender(self, bender): # -> None:
        ...
    
    def setBias(self, bias): # -> None:
        ...
    
    def getBias(self): # -> Location:
        ...
    
    def setNeutral(self, aMathObject, deltaName=...): # -> None:
        """Set the neutral object."""
        ...
    
    def getNeutral(self): # -> None:
        """Get the neutral object."""
        ...
    
    def addDelta(self, location, aMathObject, deltaName=..., punch=..., axisOnly=...): # -> None:
        """ Add a delta at this location.
            *   location:   a Location object
            *   mathObject: a math-sensitive object
            *   deltaName: optional string/token
            *   punch:
                *   True: add the difference with the instance value at that location and the delta
                *   False: just add the delta.
        """
        ...
    
    def getAxisNames(self): # -> set[Any]:
        """
            Collect a set of axis names from all deltas.
        """
        ...
    
    def collectLocations(self): # -> list[Any]:
        """
            Return a dictionary with all objects.
        """
        ...
    
    def getInstance(self, aLocation, axisOnly=..., getFactors=...): # -> tuple[Any, list[Any]]:
        """ Calculate the delta at aLocation.
            *   aLocation:  a Location object, expected to be in bent space
            *   axisOnly:
                *   True: calculate an instance only with the on-axis masters.
                *   False: calculate an instance with on-axis and off-axis masters.
            *   getFactors:
                *   True: return a list of the calculated factors.
        """
        ...
    
    def makeLocation(self, aLocation): # -> Location:
        ...
    
    def makeInstance(self, aLocation, bend=...):
        """
            Calculate an instance with the right bias and add the neutral.
            aLocation: expected to be in input space
        """
        ...
    
    def getFactors(self, aLocation, axisOnly=..., allFactors=...): # -> list[Any]:
        """
            Return a list of all factors and math items at aLocation.
            factor, mathItem, deltaName
            all = True: include factors that are zero or near-zero
        """
        ...
    


def getLimits(locations, current, sortResults=..., verbose=...): # -> dict[Any, Any]:
    """
        Find the projections for each delta in the list of locations, relative to the current location.
        Return only the dimensions that are relevant for current.
    """
    ...

if __name__ == "__main__":
    ...
