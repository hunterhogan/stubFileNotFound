"""
This type stub file was generated by pyright.
"""

from defcon.objects.base import BaseObject

logger = ...
class Font(BaseObject):
    r"""
    If loading from an existing UFO, **path** should be the path to the UFO.

    If you subclass one of the sub objects, such as :class:`Glyph`,
    the class must be registered when the font is created for defcon
    to know about it. The **\*Class** arguments allow for individual
    ovverrides. If None is provided for an argument, the defcon
    appropriate class will be used.

    **This object posts the following notifications:**

    - Font.Changed
    - Font.ReloadedGlyphs
    - Font.GlyphOrderChanged
    - Font.GuidelinesChanged
    - Font.GuidelineWillBeDeleted
    - Font.GuidelineWillBeAdded

    The Font object has some dict like behavior. For example, to get a glyph::

        glyph = font["aGlyphName"]

    To iterate over all glyphs::

        for glyph in font:

    To get the number of glyphs::

        glyphCount = len(font)

    To find out if a font contains a particular glyph::

        exists = "aGlyphName" in font

    To remove a glyph::

        del font["aGlyphName"]
    """
    changeNotificationName = ...
    representationFactories = ...
    def __init__(self, path=..., kerningClass=..., infoClass=..., groupsClass=..., featuresClass=..., libClass=..., unicodeDataClass=..., layerSetClass=..., layerClass=..., imageSetClass=..., dataSetClass=..., guidelineClass=..., glyphClass=..., glyphContourClass=..., glyphPointClass=..., glyphComponentClass=..., glyphAnchorClass=..., glyphImageClass=...) -> None:
        ...
    
    def close(self): # -> None:
        ...
    
    def __enter__(self): # -> Self:
        ...
    
    def __exit__(self, exc_type, exc_value, exc_tb): # -> None:
        ...
    
    dispatcher = ...
    _glyphSet = ...
    def newGlyph(self, name): # -> Any:
        """
        Create a new glyph with **name** in the font's main layer.
        If a glyph with that name already exists, the existing
        glyph will be replaced with the new glyph.
        """
        ...
    
    def insertGlyph(self, glyph, name=...): # -> Any:
        """
        Insert **glyph** into the font's main layer.
        Optionally, the glyph can be renamed at the same time by
        providing **name**. If a glyph with the glyph name, or
        the name provided as **name**, already exists, the existing
        glyph will be replaced with the new glyph.
        """
        ...
    
    def __iter__(self): # -> Generator[Any, Any, None]:
        ...
    
    def __getitem__(self, name): # -> Any:
        ...
    
    def __delitem__(self, name): # -> None:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __contains__(self, name): # -> bool:
        ...
    
    def keys(self): # -> Any:
        ...
    
    def newLayer(self, name): # -> Layer:
        """
        Create a new :class:`Layer` and add it to
        the top of the layer order.

        This posts *LayerSet.LayerAdded* and *LayerSet.Changed* notifications.
        """
        ...
    
    path = ...
    ufoFormatVersion = ...
    ufoFormatVersionTuple = ...
    ufoFileStructure = ...
    kerningGroupConversionRenameMaps = ...
    glyphsWithOutlines = ...
    componentReferences = ...
    bounds = ...
    controlPointBounds = ...
    def instantiateLayerSet(self): # -> LayerSet:
        ...
    
    def beginSelfLayerSetNotificationObservation(self): # -> None:
        ...
    
    def endSelfLayerSetNotificationObservation(self): # -> None:
        ...
    
    layers = ...
    def instantiateInfo(self): # -> Info:
        ...
    
    def beginSelfInfoSetNotificationObservation(self): # -> None:
        ...
    
    def endSelfInfoSetNotificationObservation(self): # -> None:
        ...
    
    info = ...
    def instantiateKerning(self): # -> Kerning:
        ...
    
    def beginSelfKerningNotificationObservation(self): # -> None:
        ...
    
    def endSelfKerningNotificationObservation(self): # -> None:
        ...
    
    kerning = ...
    def instantiateGroups(self): # -> Groups:
        ...
    
    def beginSelfGroupsNotificationObservation(self): # -> None:
        ...
    
    def endSelfGroupsNotificationObservation(self): # -> None:
        ...
    
    groups = ...
    def instantiateFeatures(self): # -> Features:
        ...
    
    def beginSelfFeaturesNotificationObservation(self): # -> None:
        ...
    
    def endSelfFeaturesNotificationObservation(self): # -> None:
        ...
    
    features = ...
    def instantiateLib(self): # -> Lib:
        ...
    
    def beginSelfLibNotificationObservation(self): # -> None:
        ...
    
    def endSelfLibNotificationObservation(self): # -> None:
        ...
    
    lib = ...
    tempLib = ...
    def instantiateImageSet(self): # -> ImageSet:
        ...
    
    def beginSelfImageSetNotificationObservation(self): # -> None:
        ...
    
    def endSelfImageSetNotificationObservation(self): # -> None:
        ...
    
    images = ...
    def instantiateDataSet(self): # -> DataSet:
        ...
    
    def beginSelfDataSetNotificationObservation(self): # -> None:
        ...
    
    def endSelfDataSetNotificationObservation(self): # -> None:
        ...
    
    data = ...
    unicodeData = ...
    glyphOrder = ...
    def updateGlyphOrder(self, addedGlyph=..., removedGlyph=...): # -> None:
        """
        This method tries to keep the glyph order in sync.
        This should not be called externally. It may be overriden
        by subclasses as needed.
        """
        ...
    
    def getSaveProgressBarTickCount(self, formatVersion=...): # -> Any:
        """
        Get the number of ticks that will be used by a progress bar
        in the save method. Subclasses may override this method to
        implement custom saving behavior.
        """
        ...
    
    def save(self, path=..., formatVersion=..., removeUnreferencedImages=..., progressBar=..., structure=...):
        """
        Save the font to **path**. If path is None, the path
        from the last save or when the font was first opened
        will be used.

        The UFO will be saved using the format found at ``ufoFormatVersion``.
        This value is either the format version from the exising UFO or
        the format version specified in a previous save. If neither of
        these is available, the UFO will be written as format version 3.
        If you wish to specifiy the format version for saving, pass
        the desired number as the **formatVersion** argument.

        Optionally, the UFO can be purged of unreferenced images
        during this operation. To do this, pass ``True`` as the
        value for the removeUnreferencedImages argument.

        'structure' can be either None, "zip" or "package". If it's None,
        the destination UFO will use the same structure as original, provided
        that is compatible with any previous UFO at the output path.
        If 'structure' is "zip" the UFO will be saved as compressed archive,
        else it is saved as a regular folder or "package".
        """
        ...
    
    def saveInfo(self, writer): # -> None:
        """
        Save info. This method should not be called externally.
        Subclasses may override this method to implement custom saving behavior.
        """
        ...
    
    def saveGroups(self, writer): # -> None:
        """
        Save groups. This method should not be called externally.
        Subclasses may override this method to implement custom saving behavior.
        """
        ...
    
    def saveKerning(self, writer): # -> None:
        """
        Save kerning. This method should not be called externally.
        Subclasses may override this method to implement custom saving behavior.
        """
        ...
    
    def saveFeatures(self, writer): # -> None:
        """
        Save features. This method should not be called externally.
        Subclasses may override this method to implement custom saving behavior.
        """
        ...
    
    def saveLib(self, writer, saveAs=..., progressBar=...): # -> None:
        """
        Save lib. This method should not be called externally.
        Subclasses may override this method to implement custom saving behavior.
        """
        ...
    
    def saveImages(self, writer, removeUnreferencedImages=..., saveAs=..., progressBar=...): # -> None:
        """
        Save images. This method should not be called externally.
        Subclasses may override this method to implement custom saving behavior.
        """
        ...
    
    def saveData(self, writer, saveAs=..., progressBar=...): # -> None:
        """
        Save data. This method should not be called externally.
        Subclasses may override this method to implement custom saving behavior.
        """
        ...
    
    identifiers = ...
    guidelines = ...
    def instantiateGuideline(self, guidelineDict=...): # -> Guideline:
        ...
    
    def beginSelfGuidelineNotificationObservation(self, guideline): # -> None:
        ...
    
    def endSelfGuidelineNotificationObservation(self, guideline): # -> None:
        ...
    
    def appendGuideline(self, guideline): # -> None:
        """
        Append **guideline** to the font. The guideline must be a defcon
        :class:`Guideline` object or a subclass of that object. An error
        will be raised if the guideline's identifier conflicts with any of
        the identifiers within the font.

        This will post *Font.GuidelinesChanged* and *Font.Changed* notifications.
        """
        ...
    
    def insertGuideline(self, index, guideline): # -> None:
        """
        Insert **guideline** into the font at index. The guideline
        must be a defcon :class:`Guideline` object or a subclass
        of that object. An error will be raised if the guideline's
        identifier conflicts with any of the identifiers within
        the font.

        This will post *Font.GuidelinesChanged* and *Font.Changed* notifications.
        """
        ...
    
    def removeGuideline(self, guideline): # -> None:
        """
        Remove **guideline** from the font.

        This will post *Font.GuidelineWillBeDeleted*, *Font.GuidelinesChanged* and *Font.Changed* notifications.
        """
        ...
    
    def guidelineIndex(self, guideline): # -> int:
        """
        Get the index for **guideline**.
        """
        ...
    
    def clearGuidelines(self): # -> None:
        """
        Clear all guidelines from the font.

        This posts a *Font.Changed* notification.
        """
        ...
    
    def endSelfNotificationObservation(self): # -> None:
        ...
    
    def beginSelfLayersNotificationObservation(self): # -> None:
        ...
    
    def endSelfLayersNotificationObservation(self): # -> None:
        ...
    
    def testForExternalChanges(self): # -> dict[str, Any]:
        """
        Test the UFO for changes that occured outside of this font's
        tree of objects. This returns a dictionary describing the changes::

            {
                "info"     : bool, # True if changed, False if not changed
                "kerning"  : bool, # True if changed, False if not changed
                "groups"   : bool, # True if changed, False if not changed
                "features" : bool, # True if changed, False if not changed
                "lib"      : bool, # True if changed, False if not changed
                "layers"   : {
                    "defaultLayer" : bool, # True if changed, False if not changed
                    "order"        : bool, # True if changed, False if not changed
                    "added"        : ["layer name 1", "layer name 2"],
                    "deleted"      : ["layer name 1", "layer name 2"],
                    "modified"     : {
                        "info"     : bool, # True if changed, False if not changed
                        "modified" : ["glyph name 1", "glyph name 2"],
                        "added"    : ["glyph name 1", "glyph name 2"],
                        "deleted"  : ["glyph name 1", "glyph name 2"]
                    }
                },
                "images"   : {
                    "modified" : ["image name 1", "image name 2"],
                    "added"    : ["image name 1", "image name 2"],
                    "deleted"  : ["image name 1", "image name 2"],
                },
                "data"     : {
                    "modified" : ["file name 1", "file name 2"],
                    "added"    : ["file name 1", "file name 2"],
                    "deleted"  : ["file name 1", "file name 2"],
                }
            }

        It is important to keep in mind that the user could have created
        conflicting data outside of the font's tree of objects. For example,
        say the user has set ``font.info.unitsPerEm = 1000`` inside of the
        font's :class:`Info` object and the user has not saved this change.
        In the the font's fontinfo.plist file, the user sets the unitsPerEm value
        to 2000. Which value is current? Which value is right? defcon leaves
        this decision up to you.
        """
        ...
    
    def reloadInfo(self): # -> None:
        """
        Reload the data in the :class:`Info` object from the
        fontinfo.plist file in the UFO.
        """
        ...
    
    def reloadKerning(self): # -> None:
        """
        Reload the data in the :class:`Kerning` object from the
        kerning.plist file in the UFO.

        This validates the kerning against the groups loaded into the
        font. If groups are being reloaded in the same pass, the groups
        should always be reloaded before reloading the kerning.
        """
        ...
    
    def reloadGroups(self): # -> None:
        """
        Reload the data in the :class:`Groups` object from the
        groups.plist file in the UFO.
        """
        ...
    
    def reloadFeatures(self): # -> None:
        """
        Reload the data in the :class:`Features` object from the
        features.fea file in the UFO.
        """
        ...
    
    def reloadLib(self): # -> None:
        """
        Reload the data in the :class:`Lib` object from the
        lib.plist file in the UFO.
        """
        ...
    
    def reloadImages(self, fileNames): # -> None:
        """
        Reload the images listed in **fileNames** from the
        appropriate files within the UFO. When all of the
        loading is complete, a *Font.ReloadedImages* notification
        will be posted.
        """
        ...
    
    def reloadData(self, fileNames): # -> None:
        """
        Reload the data files listed in **fileNames** from the
        appropriate files within the UFO. When all of the
        loading is complete, a *Font.ReloadedData* notification
        will be posted.
        """
        ...
    
    def reloadGlyphs(self, glyphNames): # -> None:
        """
        Deprecated! Use reloadLayers!

        Reload the glyphs listed in **glyphNames** from the
        appropriate files within the UFO. When all of the
        loading is complete, a *Font.ReloadedGlyphs* notification
        will be posted.
        """
        ...
    
    def reloadLayers(self, layerData): # -> None:
        """
        Reload the data in the layers specfied in **layerData**.
        When all of the loading is complete, *Font.ReloadedLayers*
        and *Font.ReloadedGlyphs* notifications will be posted.
        The **layerData** must be a dictionary following this format::

            {
                "order"   : bool, # True if you want the order releaded
                "default" : bool, # True if you want the default layer reset
                "layers"  : {
                    "layer name" : {
                        "glyphNames" : ["glyph name 1", "glyph name 2"], # list of glyph names you want to reload
                        "info"       : bool, # True if you want the layer info reloaded
                    }
                }
            }
        """
        ...
    
    featureRE = ...
    def getDataForSerialization(self, **kwargs): # -> dict[Any, Any]:
        ...
    
    def setDataFromSerialization(self, data): # -> None:
        ...
    


def samepath(p1, p2):
    """Return True if p1 and p2 refer to the same path. That is, when both
    are strings or os.PathLike objects, compare their absolute, case
    insensitive representation.
    """
    ...

if __name__ == "__main__":
    ...
