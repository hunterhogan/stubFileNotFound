"""
This type stub file was generated by pyright.
"""

class BaseObject:
    """
    The base object in defcon from which all other objects should be derived.

    **This object posts the following notifications:**

    - BaseObject.Changed
    - BaseObject.BeginUndo
    - BaseObject.EndUndo
    - BaseObject.BeginRedo
    - BaseObject.EndRedo

    Keep in mind that subclasses will not post these same notifications.

    Subclasses must override the following attributes:

    +-------------------------+--------------------------------------------------+
    | Name                    | Notes                                            |
    +=========================+==================================================+
    | changeNotificationName  | This must be a string unique to the class        |
    |                         | indicating the name of the notification          |
    |                         | to be posted when the dirty attribute is set.    |
    +-------------------------+--------------------------------------------------+
    | representationFactories | This must be a dictionary that is shared across  |
    |                         | *all* instances of the class.                    |
    +-------------------------+--------------------------------------------------+
    """
    changeNotificationName = ...
    beginUndoNotificationName = ...
    endUndoNotificationName = ...
    beginRedoNotificationName = ...
    endRedoNotificationName = ...
    representationFactories = ...
    def __init__(self) -> None:
        ...
    
    def __del__(self): # -> None:
        ...
    
    def getParent(self):
        ...
    
    dispatcher = ...
    def addObserver(self, observer, methodName, notification, identifier=...): # -> None:
        """
        Add an observer to this object's notification dispatcher.

        * **observer** An object that can be referenced with weakref.
        * **methodName** A string representing the method to be called
          when the notification is posted.
        * **notification** The notification that the observer should
          be notified of.
        * **identifier** None or a string identifying the observation.
          There is no requirement that the string be unique. A reverse
          domain naming scheme is recommended, but there are no
          requirements for the structure of the string.

        The method that will be called as a result of the action
        must accept a single *notification* argument. This will
        be a :class:`defcon.tools.notifications.Notification` object.

        This is a convenience method that does the same thing as::

            dispatcher = anObject.dispatcher
            dispatcher.addObserver(observer=observer, methodName=methodName,
                notification=notification, observable=anObject, identifier=identifier)
        """
        ...
    
    def removeObserver(self, observer, notification): # -> None:
        """
        Remove an observer from this object's notification dispatcher.

        * **observer** A registered object.
        * **notification** The notification that the observer was registered
          to be notified of.

        This is a convenience method that does the same thing as::

            dispatcher = anObject.dispatcher
            dispatcher.removeObserver(observer=observer,
                notification=notification, observable=anObject)
        """
        ...
    
    def hasObserver(self, observer, notification): # -> Any | Literal[False]:
        """
        Returns a boolean indicating is the **observer** is registered for **notification**.

        This is a convenience method that does the same thing as::

            dispatcher = anObject.dispatcher
            dispatcher.hasObserver(observer=observer,
                notification=notification, observable=anObject)
        """
        ...
    
    def holdNotifications(self, notification=..., note=...): # -> None:
        """
        Hold this object's notifications until told to release them.

        * **notification** The specific notification to hold. This is optional.
          If no *notification* is given, all notifications will be held.
        * **note** An arbitrary string containing information about why the hold
          has been requested, the requester, etc. This is used for reference only.

        This is a convenience method that does the same thing as::

            dispatcher = anObject.dispatcher
            dispatcher.holdNotifications(
                observable=anObject, notification=notification, note=note)
        """
        ...
    
    def releaseHeldNotifications(self, notification=...): # -> None:
        """
        Release this object's held notifications.

        * **notification** The specific notification to hold. This is optional.

        This is a convenience method that does the same thing as::

            dispatcher = anObject.dispatcher
            dispatcher.releaseHeldNotifications(
                observable=anObject, notification=notification)
        """
        ...
    
    def disableNotifications(self, notification=..., observer=...): # -> None:
        """
        Disable this object's notifications until told to resume them.

        * **notification** The specific notification to disable. This is optional.
          If no *notification* is given, all notifications will be disabled.

        This is a convenience method that does the same thing as::

            dispatcher = anObject.dispatcher
            dispatcher.disableNotifications(
                observable=anObject, notification=notification, observer=observer)
        """
        ...
    
    def enableNotifications(self, notification=..., observer=...): # -> None:
        """
        Enable this object's notifications.

        * **notification** The specific notification to enable. This is optional.

        This is a convenience method that does the same thing as::

            dispatcher = anObject.dispatcher
            dispatcher.enableNotifications(
                observable=anObject, notification=notification, observer=observer)
        """
        ...
    
    def postNotification(self, notification, data=...): # -> None:
        """
        Post a **notification** through this object's notification dispatcher.

            * **notification** The name of the notification.
            * **data** Arbitrary data that will be stored in the :class:`Notification` object.

        This is a convenience method that does the same thing as::

            dispatcher = anObject.dispatcher
            dispatcher.postNotification(
                notification=notification, observable=anObject, data=data)
        """
        ...
    
    def findObservations(self, observer=..., notification=..., observable=..., identifier=...): # -> Any | None:
        """
        Find observations of this object matching the given
        arguments based on the values that were passed during
        addObserver. A value of None for any of these indicates
        that all should be considered to match the value.
        In the case of identifier, strings will be matched
        using fnmatch.fnmatchcase. The returned value will be
        a list of dictionaries with this format:

            [
                {
                    observer=<...>
                    observable=<...>
                    methodName="..."
                    notification="..."
                    identifier="..."
                }
            ]

        This is a convenience method that does the same thing as::

            dispatcher = anObject.dispatcher
            dispatcher.findObservations(
                observer=observer, observable=anObject,
                notification=notification, identifier=identifier
            )
        """
        ...
    
    def beginSelfNotificationObservation(self): # -> None:
        ...
    
    def endSelfNotificationObservation(self): # -> None:
        ...
    
    def selfNotificationCallback(self, notification): # -> None:
        ...
    
    undoManager = ...
    def canUndo(self): # -> Any:
        """
        Returns a boolean indicating whether the undo manager is able to
        perform an undo.
        """
        ...
    
    def undo(self): # -> None:
        """
        Perform an undo if possible, or return.
        If undo is performed, this will post *BaseObject.BeginUndo* and *BaseObject.EndUndo* notifications.
        """
        ...
    
    def canRedo(self): # -> Any:
        """
        Returns a boolean indicating whether the undo manager is able to
        perform a redo.
        """
        ...
    
    def redo(self): # -> None:
        """
        Perform a redo if possible, or return.
        If redo is performed, this will post *BaseObject.BeginRedo* and *BaseObject.EndRedo* notifications.
        """
        ...
    
    def getRepresentation(self, name, **kwargs):
        r"""
        Get a representation. **name** must be a registered
        representation name. **\*\*kwargs** will be passed
        to the appropriate representation factory.
        """
        ...
    
    def destroyRepresentation(self, name, **kwargs): # -> None:
        r"""
        Destroy the stored representation for **name**
        and **\*\*kwargs**. If no **kwargs** are given,
        any representation with **name** will be destroyed
        regardless of the **kwargs** passed when the
        representation was created.
        """
        ...
    
    def destroyAllRepresentations(self, notification=...): # -> None:
        """
        Destroy all representations.
        """
        ...
    
    def representationKeys(self): # -> list[Any]:
        """
        Get a list of all representation keys that are
        currently cached.
        """
        ...
    
    def hasCachedRepresentation(self, name, **kwargs): # -> bool:
        r"""
        Returns a boolean indicating if a representation for
        **name** and **\*\*kwargs** is cached in the object.
        """
        ...
    
    dirty = ...
    def serialize(self, dumpFunc=..., whitelist=..., blacklist=...): # -> bytes:
        ...
    
    def deserialize(self, data, loadFunc=...): # -> None:
        ...
    
    def getDataForSerialization(self, **kwargs): # -> dict[Any, Any]:
        """
        Return a dict of data that can be pickled.
        """
        ...
    
    def setDataFromSerialization(self, data): # -> None:
        """
        Restore state from the provided data-dict.
        """
        ...
    
    ufoLibReadValidate = ...
    ufoLibWriteValidate = ...


class BaseDictObject(dict, BaseObject):
    """
    A subclass of BaseObject that implements a dict API. Any changes
    to the contents of the object will cause the dirty attribute
    to be set to True.
    """
    setItemNotificationName = ...
    deleteItemNotificationName = ...
    clearNotificationName = ...
    updateNotificationName = ...
    def __init__(self) -> None:
        ...
    
    _dict = ...
    def __hash__(self) -> int:
        ...
    
    def __setitem__(self, key, value): # -> None:
        ...
    
    def __delitem__(self, key): # -> None:
        ...
    
    def __deepcopy__(self, memo=...): # -> Self:
        ...
    
    def clear(self): # -> None:
        ...
    
    def update(self, other): # -> None:
        ...
    
    def getDataForSerialization(self, **kwargs): # -> dict[Any, Any]:
        ...
    
    def setDataFromSerialization(self, data): # -> None:
        ...
    


class BaseDictCompareObject(BaseDictObject):
    def __hash__(self) -> int:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    


def setUfoLibReadValidate(value): # -> None:
    """
    Set the default read validation.
    """
    ...

def setUfoLibWriteValidate(value): # -> None:
    """
    Set the default write validation.
    """
    ...

if __name__ == "__main__":
    ...
