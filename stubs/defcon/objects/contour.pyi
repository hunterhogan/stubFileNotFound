"""
This type stub file was generated by pyright.
"""

from defcon.objects.base import BaseObject

class Contour(BaseObject):
    """
    This object represents a contour and it contains a list of points.

    **This object posts the following notifications:**

    - Contour.Changed
    - Contour.WindingDirectionChanged
    - Contour.PointsChanged
    - Contour.IdentifierChanged

    The Contour object has list like behavior. This behavior allows you to interact
    with point data directly. For example, to get a particular point::

        point = contour[0]

    To iterate over all points::

        for point in contour:

    To get the number of points::

        pointCount = len(contour)

    To interact with components or anchors in a similar way,
    use the ``components`` and ``anchors`` attributes.
    """
    changeNotificationName = ...
    representationFactories = ...
    def __init__(self, glyph=..., pointClass=...) -> None:
        ...
    
    def __del__(self): # -> None:
        ...
    
    def getParent(self): # -> Any | None:
        ...
    
    font = ...
    layerSet = ...
    layer = ...
    glyph = ...
    pointClass = ...
    onCurvePoints = ...
    def appendPoint(self, point): # -> None:
        """
        Append **point** to the glyph. The point must be a defcon
        :class:`Point` object or a subclass of that object. An error
        will be raised if the point's identifier conflicts with any of
        the identifiers within the glyph.

        This will post *Contour.PointsChanged* and *Contour.Changed* notifications.
        """
        ...
    
    def insertPoint(self, index, point): # -> None:
        """
        Insert **point** into the contour at index. The point
        must be a defcon :class:`Point` object or a subclass
        of that object. An error will be raised if the points's
        identifier conflicts with any of the identifiers within
        the glyph.

        This will post *Contour.PointsChanged* and *Contour.Changed* notifications.
        """
        ...
    
    def removePoint(self, point): # -> None:
        """
        Remove **point** from the contour.

        This will post *Contour.PointsChanged* and *Contour.Changed* notifications.
        """
        ...
    
    def setStartPoint(self, index): # -> None:
        """
        Set the point at **index** as the first point in the contour.
        This point must be an on-curve point.

        This will post *Contour.PointsChanged* and *Contour.Changed* notifications.
        """
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __getitem__(self, index):
        ...
    
    def __iter__(self):
        ...
    
    def clear(self): # -> None:
        """
        Clear the contents of the contour.

        This posts *Contour.PointsChanged* and *Contour.Changed* notifications.
        """
        ...
    
    def index(self, point): # -> int:
        """
        Get the index for **point**.
        """
        ...
    
    def reverse(self): # -> None:
        """
        Reverse the direction of the contour. It's important to note
        that the actual points stored in this object will be completely
        replaced by new points.

        This will post *Contour.WindingDirectionChanged*,
        *Contour.PointsChanged* and *Contour.Changed* notifications.
        """
        ...
    
    segments = ...
    def removeSegment(self, segmentIndex, preserveCurve=...): # -> None:
        """
        Remove the segment at **segmentIndex**. If
        **preserveCurve** is True, the contour will
        try to preserve the overall curve shape.
        """
        ...
    
    clockwise = ...
    open = ...
    bounds = ...
    controlPointBounds = ...
    area = ...
    def move(self, values): # -> None:
        """
        Move all points in the contour by **(x, y)**.

        This will post *Contour.PointsChanged* and *Contour.Changed* notifications.
        """
        ...
    
    def pointInside(self, coordinates, evenOdd=...):
        """
        Returns a boolean indicating if **(x, y)** is in the
        "black" area of the contour.
        """
        ...
    
    def contourInside(self, other, segmentLength=...): # -> bool:
        """
        Returns a boolean indicating if **other** is in the
        "black" area of the contour. This uses a flattened
        version of other's curves to calculate the location
        of the curves within this contour. **segmentLength**
        defines the desired length for the flattening process.
        A lower value will yeild higher accuracy but will require
        more computation time.
        """
        ...
    
    def positionForProspectivePointInsertionAtSegmentAndT(self, segmentIndex, t): # -> tuple[tuple[Any, Any] | tuple[Any, ...], bool]:
        """
        Get the precise coordinates and a boolean indicating
        if the point will be smooth for the given **segmentIndex**
        and **t**.
        """
        ...
    
    def splitAndInsertPointAtSegmentAndT(self, segmentIndex, t): # -> None:
        """
        Insert a point into the contour for the given
        **segmentIndex** and **t**.

        This posts a *Contour.Changed* notification.
        """
        ...
    
    def beginPath(self, identifier=...): # -> None:
        """
        Standard point pen *beginPath* method.
        This should not be used externally.
        """
        ...
    
    def endPath(self): # -> None:
        """
        Standard point pen *endPath* method.
        This should not be used externally.
        """
        ...
    
    def addPoint(self, values, segmentType=..., smooth=..., name=..., identifier=..., **kwargs): # -> None:
        """
        Standard point pen *addPoint* method.
        This should not be used externally.
        """
        ...
    
    def draw(self, pen): # -> None:
        """
        Draw the contour with **pen**.
        """
        ...
    
    def drawPoints(self, pointPen): # -> None:
        """
        Draw the contour with **pointPen**.
        """
        ...
    
    identifiers = ...
    identifier = ...
    def generateIdentifier(self): # -> LiteralString | Any | str:
        """
        Create a new, unique identifier for and assign it to the contour.
        This will post *Contour.IdentifierChanged* and *Contour.Changed* notifications.
        """
        ...
    
    def generateIdentifierForPoint(self, point): # -> LiteralString:
        """
        Create a new, unique identifier for and assign it to the point.
        This will post *Contour.Changed* notification.
        """
        ...
    
    def endSelfNotificationObservation(self): # -> None:
        ...
    
    def getDataForSerialization(self, **kwargs): # -> dict[Any, Any]:
        ...
    
    def setDataFromSerialization(self, data): # -> None:
        ...
    


class Recorder:
    """
    Records all method calls it receives in a list of tuples in the form of
    [(:str:command, :list:args, :dict: kwargs)]

    Method calls to be recorded must not start with an underscore.

    This class creates a callable object which can be used like a
    function: "recorder(target)" because that way calls to all methods
    that don't start with underscores can be recorded.

    This is useful to record the commands of both pen protocols
    and it may become useful for other things as well, like recording
    undo commands.

    Example Session PointPen:

    data_glyphA = []
    recorderPointPen = Recorder(data_glyphA)
    glyphA.drawPoints(recorderPointPen)

    # The point data of the glyph is now stored within data
    # we can either replay it immediately or take it away and use it
    # to replay it later

    stored_data = pickle.dumps(data_glyphA)
    restored_data_glyphA = pickle.loads(stored_data)

    player = Recorder(restored_data_glyphA)
    # The recorder behaves like glyphA.drawPoints
    player(glyphB)

    Example Session SegmentPen:

    data_glyphA = []
    recorderPen = Recorder(data_glyphA)
    glyphA.draw(recorderPen)

    # reuse it immediately
    # The recorder behaves like glyphA.draw
    recorderPen(glyphB)
    """
    def __init__(self, data=...) -> None:
        ...
    
    def __call__(self, target): # -> None:
        """
        Public API.
        Replay all method calls to this Recorder to target.
        """
        ...
    
    def __setattr__(self, name, value):
        ...
    
    def __getattr__(self, name): # -> Callable[..., None]:
        ...
    


if __name__ == "__main__":
    ...
