"""
This type stub file was generated by pyright.
"""

from defcon.objects.base import BaseDictObject

class UnicodeData(BaseDictObject):
    """
    This object serves Unicode data for the font.

    **This object posts the following notifications:**

    - UnicodeData.Changed

    This object behaves like a dict. The keys are Unicode values and the
    values are lists of glyph names associated with that unicode value::

        {
            65 : ["A"],
            66 : ["B"],
        }

    To get the list of glyph names associated with a particular Unicode
    value, do this::

        glyphList = unicodeData[65]

    The object defines many more convenient ways of interacting
    with this data.

    .. warning::

        Setting data into this object manually is *highly* discouraged.
        The object automatically keeps itself in sync with the font and the
        glyphs contained in the font. No manual intervention is required.
    """
    changeNotificationName = ...
    representationFactories = ...
    def __init__(self, layer=...) -> None:
        ...
    
    def getParent(self): # -> Any:
        ...
    
    font = ...
    layerSet = ...
    layer = ...
    def removeGlyphData(self, glyphName, values): # -> None:
        """
        Remove the data for the glyph with **glyphName** and
        the Unicode values **values**.

        This should never be called directly.
        """
        ...
    
    def addGlyphData(self, glyphName, values): # -> None:
        """
        Add the data for the glyph with **glyphName** and
        the Unicode values **values**.

        This should never be called directly.
        """
        ...
    
    def __delitem__(self, value): # -> None:
        ...
    
    def __setitem__(self, value, glyphList): # -> None:
        ...
    
    def clear(self): # -> None:
        """
        Completely remove all stored data.

        This should never be called directly.
        """
        ...
    
    def update(self, other): # -> None:
        """
        Update the data int this object with the data from **other**.

        This should never be called directly.
        """
        ...
    
    def unicodeForGlyphName(self, glyphName): # -> Any | None:
        """
        Get the Unicode value for **glyphName**. Returns *None*
        if no value is found.
        """
        ...
    
    def glyphNameForUnicode(self, value): # -> None:
        """
        Get the first glyph assigned to the Unicode specified
        as **value**. This will return *None* if no glyph is found.
        """
        ...
    
    def pseudoUnicodeForGlyphName(self, glyphName): # -> Any | None:
        """
        Get the pseudo-Unicode value for **glyphName**.
        This will return *None* if nothing is found.
        """
        ...
    
    def forcedUnicodeForGlyphName(self, glyphName): # -> Any:
        """
        Get the forced-Unicode value for **glyphName**.
        """
        ...
    
    def glyphNameForForcedUnicode(self, value): # -> None:
        """
        Get the glyph name assigned to the forced-Unicode
        specified by **value**.
        """
        ...
    
    def scriptForGlyphName(self, glyphName, allowPseudoUnicode=...): # -> Literal['Unknown']:
        """
        Get the script for **glyphName**. If **allowPseudoUnicode** is
        True, a pseudo-Unicode value will be used if needed. This will
        return *None* if nothing can be found.
        """
        ...
    
    def blockForGlyphName(self, glyphName, allowPseudoUnicode=...): # -> Literal['No_Block']:
        """
        Get the block for **glyphName**. If **allowPseudoUnicode** is
        True, a pseudo-Unicode value will be used if needed. This will
        return *None* if nothing can be found.
        """
        ...
    
    def categoryForGlyphName(self, glyphName, allowPseudoUnicode=...): # -> str:
        """
        Get the category for **glyphName**. If **allowPseudoUnicode** is
        True, a pseudo-Unicode value will be used if needed. This will
        return *None* if nothing can be found.
        """
        ...
    
    def decompositionBaseForGlyphName(self, glyphName, allowPseudoUnicode=...): # -> Any:
        """
        Get the decomposition base for **glyphName**. If **allowPseudoUnicode**
        is True, a pseudo-Unicode value will be used if needed. This will
        return *glyphName* if nothing can be found.
        """
        ...
    
    def closeRelativeForGlyphName(self, glyphName, allowPseudoUnicode=...): # -> None:
        """
        Get the close relative for **glyphName**. For example, if you
        request the close relative of the glyph name for the character (,
        you will be given the glyph name for the character ) if it exists
        in the font. If **allowPseudoUnicode** is True, a pseudo-Unicode
        value will be used if needed. This will return *None* if nothing
        can be found.
        """
        ...
    
    def openRelativeForGlyphName(self, glyphName, allowPseudoUnicode=...): # -> None:
        """
        Get the open relative for **glyphName**. For example, if you
        request the open relative of the glyph name for the character ),
        you will be given the glyph name for the character ( if it exists
        in the font. If **allowPseudoUnicode** is True, a pseudo-Unicode
        value will be used if needed. This will return *None* if nothing
        can be found.
        """
        ...
    
    def sortGlyphNames(self, glyphNames, sortDescriptors=...): # -> list[Any]:
        """
        This sorts the list of **glyphNames** following the sort descriptors
        provided in the **sortDescriptors** list. This works by iterating over
        the sort descriptors and subdividing. For example, if the first
        sort descriptor is a suffix type, internally, the result of the
        sort will look something like this::

            [
                [glyphsWithNoSuffix],
                [glyphsWith.suffix1],
                [glyphsWith.suffix2]
            ]

        When the second sort descriptor is processed, the results of previous
        sorts are subdivided even further. For example, if the second
        sort type is script::

            [[
                [glyphsWithNoSuffix, script1], [glyphsWithNoSuffix, script2],
                [glyphsWith.suffix1, script1], [glyphsWith.suffix1, script2],
                [glyphsWith.suffix2, script1], [glyphsWith.suffix2, script2]
            ]]

        And so on. The returned list will be flattened into a list of glyph names.

        Each item in **sortDescriptors** should be a dict of the following form:

        ==================  ===========
        Key                 Description
        ==================  ===========
        type                The type of sort to perform. See below for options.
        ascending           Boolean representing if the glyphs should be in
                            ascending or descending order. Optional. The default is True.
        allowPseudoUnicode  Boolean representing if pseudo-Unicode
                            values are used. If not, real Unicode values will be used
                            if necessary. Optional. The default is False.
        function            A function. Used only for **custom** sort types. See details below.
        ==================  ===========

        *Available Sort Types:*

        There are four types of sort types: simple, complex, canned and custom.
        Simple sorts are based on sorting non-magical values, such as Unicode values.
        Complex sorts are heuristic based sorts based on common glyph name practices,
        aesthetic preferences and other hard to quantify ideas. Custom sorts are just
        that, custom sorts. Canned sorts are combinations of simple, complex and custom
        sorts that give optimized ordering results. Complex and canned sorts may change
        with further updates, so they should not be relied on for persistent ordering.

        ==================   ==============================================================
        Simple Sort Types    Description
        ==================   ==============================================================
        alphabetical         Self-explanatory.
        unicode              Sort based on Unicode value.
        script               Sort based on Unicode script.
        category             Sort based on Unicode category.
        block                Sort based on Unicode block.
        suffix               Sort based on glyph name suffix.
        decompositionBase    Sort based on the base glyph defined in the decomposition rules.
        ==================   ==============================================================

        ==================   ==============================================================
        Complex Sort Types   Description
        ==================   ==============================================================
        weightedSuffix       Sort based on glyph names suffix. The ordering of the
                             suffixes is based on the calculated "weight" of the suffix.
                             This value is calculated by noting what type of glyphs have
                             the same suffix. The more glyph types, the more important the
                             suffix. Additionally, glyphs with suffixes that have only
                             numerical differences are grouped together. For example,
                             a.alt, a.alt1 and a.alt319 will be grouped together.
        ligature             Sort into to groups: non-ligatures and ligatures.
                             The determination of whether a glyph is a ligature or
                             not is based on the Unicode value, common glyph names
                             or the use of an underscore in the name.
        ==================   ==============================================================

        ==================   ==============================================================
        Canned Sort Types    Description
        ==================   ==============================================================
        cannedDesign         Sort glyphs into a design process friendly order.
        ==================   ==============================================================

        ==================   ==============================================================
        Custom Sort Type     Description
        ==================   ==============================================================
        custom               Sort using a custom function. See details below.
        ==================   ==============================================================

        *Sorting with a custom function:*
        If the builtin sort types don't do exactly what you need, you can use a **custom** sort type
        that contains an arbitrary function that handles sorting externally. This follows the same
        sorting logic as detailed above. The custom sort type can be used in conjunction with the
        builtin sort types.

        The function should follow this form::

            mySortFunction(font, glyphNames, ascending=True, allowPseudoUnicode=False)

        The **ascending** and **allowPseudoUnicode** arguments will be the values defined
        in the sort descriptors.

        The function should return a list of lists of glyph names.

        An example::

            def sortByE(font, glyphNames, ascending=True, allowsPseudoUnicodes=False):
                startsWithE = []
                doesNotStartWithE = []
                for glyphName in glyphNames:
                    if glyphName.startswith("startsWithE"):
                        startsWithE.append(glyphName)
                    else:
                        doesNotStartWithE.append(glyphName)
                return [startsWithE, doesNotStartWithE]
        """
        ...
    
    def endSelfNotificationObservation(self): # -> None:
        ...
    


_privateUse1Min = ...
_privateUse1Max = ...
_privateUse2Min = ...
_privateUse2Max = ...
_privateUse3Min = ...
_privateUse3Max = ...
_viablePUACount = ...
_notReallyLigatures = ...
_ligatureUniValues = ...
_manualSortGroups = ...
_currentGroup = ...
_parsed = ...
_manualSortGroups = ...
if __name__ == "__main__":
    ...
