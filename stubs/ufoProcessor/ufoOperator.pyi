"""
This type stub file was generated by pyright.
"""

from fontMath.mathGlyph import MathGlyph
from fontMath.mathInfo import MathInfo
from fontMath.mathKerning import MathKerning

_memoizeCache = ...
_memoizeStats = ...
def ip(a, b, f):
    ...

def immutify(obj): # -> tuple[Any, ...]:
    ...

class MemoizeDict(dict):
    """
    An immutable dictionary.

    >>> d = MemoizeDict(name="a", test="b")
    >>> d["name"]
    'a'
    >>> d["name"] = "c"
    Traceback (most recent call last):
        ...
    RuntimeError: Cannot modify ImmutableDict
    """
    def __readonly__(self, *args, **kwargs):
        ...
    
    __setitem__ = ...
    __delitem__ = ...
    pop = ...
    popitem = ...
    clear = ...
    update = ...
    setdefault = ...
    _hash = ...
    def __hash__(self) -> int:
        ...
    


def memoize(function): # -> _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any]:
    ...

def inspectMemoizeCache(): # -> tuple[list[tuple[Any, Any]], list[Any]]:
    ...

def getDefaultLayerName(f): # -> ... | None:
    ...

def getLayer(f, layerName): # -> None:
    ...

class UFOOperator:
    fontClass = ...
    layerClass = ...
    glyphClass = ...
    libClass = ...
    glyphContourClass = ...
    glyphPointClass = ...
    glyphComponentClass = ...
    glyphAnchorClass = ...
    kerningClass = ...
    groupsClass = ...
    infoClass = ...
    featuresClass = ...
    mathInfoClass = MathInfo
    mathGlyphClass = MathGlyph
    mathKerningClass = MathKerning
    italicSlantOffsetLibKey = ...
    skipExportGlyphLibKey = ...
    excludeGlyphFromInstanceLibKey = ...
    mutedDesignLocationsLibKey = ...
    def __init__(self, pathOrObject=..., ufoVersion=..., useVarlib=..., extrapolate=..., strict=..., debug=...) -> None:
        ...
    
    def startLog(self): # -> None:
        ...
    
    def read(self, path): # -> None:
        """Wrap a DesignSpaceDocument"""
        ...
    
    def write(self, path): # -> None:
        """Write the wrapped DesignSpaceDocument"""
        ...
    
    def addAxis(self, axisDescriptor): # -> None:
        ...
    
    def addAxisDescriptor(self, **kwargs):
        ...
    
    def addLocationLabel(self, locationLabelDescriptor): # -> None:
        ...
    
    def addLocationLabelDescriptor(self, **kwargs):
        ...
    
    def addRule(self, ruleDescriptor): # -> None:
        ...
    
    def addRuleDescriptor(self, **kwargs):
        ...
    
    def addSource(self, sourceDescriptor): # -> None:
        ...
    
    def addSourceDescriptor(self, **kwargs):
        ...
    
    def addInstance(self, instanceDescriptor): # -> None:
        ...
    
    def addInstanceDescriptor(self, **kwargs):
        ...
    
    def addVariableFont(self, variableFontDescriptor): # -> None:
        ...
    
    def addVariableFontDescriptor(self, **kwargs):
        ...
    
    def getVariableFonts(self):
        ...
    
    def getInterpolableUFOOperators(self, useVariableFonts=...): # -> Generator[tuple[Any | str, Self], Any, None]:
        ...
    
    @property
    def path(self):
        ...
    
    @path.setter
    def path(self, value): # -> None:
        ...
    
    @property
    def lib(self):
        ...
    
    @property
    def axes(self):
        ...
    
    @property
    def sources(self):
        ...
    
    @property
    def instances(self):
        ...
    
    @property
    def formatVersion(self):
        ...
    
    @property
    def rules(self):
        ...
    
    @property
    def rulesProcessingLast(self):
        ...
    
    @property
    def map_backward(self):
        ...
    
    @property
    def labelForUserLocation(self):
        ...
    
    @property
    def locationLabels(self):
        ...
    
    @locationLabels.setter
    def locationLabels(self, locationLabels): # -> None:
        ...
    
    @property
    def variableFonts(self):
        ...
    
    @property
    def elidedFallbackName(self):
        ...
    
    @elidedFallbackName.setter
    def elidedFallbackName(self, name): # -> None:
        ...
    
    @property
    def writerClass(self):
        ...
    
    def nameLocation(self, loc): # -> str:
        ...
    
    @formatVersion.setter
    def formatVersion(self, value): # -> None:
        ...
    
    def getAxis(self, axisName):
        ...
    
    def loadFonts(self, reload=...): # -> None:
        ...
    
    def updateFonts(self, fontObjects): # -> None:
        ...
    
    def getFonts(self): # -> list[Any]:
        ...
    
    def usesFont(self, fontObj=...): # -> bool:
        ...
    
    def getCharacterMapping(self, discreteLocation=...): # -> dict[Any, Any]:
        ...
    
    def __del__(self): # -> None:
        ...
    
    def changed(self): # -> None:
        ...
    
    _cachedCallbacksWithGlyphNames = ...
    def glyphChanged(self, glyphName, includeDependencies=...): # -> None:
        """Clears this one specific glyph from the memoize cache
        includeDependencies = True: check where glyphName is used as a component
            and remove those as well.
            Note: this must be check in each discreteLocation separately
            because they can have different constructions."""
        ...
    
    def getGlyphDependencies(self, glyphName): # -> set[Any] | None:
        ...
    
    def glyphsInCache(self): # -> list[Any]:
        """report which glyphs are in the cache at the moment"""
        ...
    
    def findAllDefaults(self): # -> list[Any]:
        ...
    
    def findDefault(self, discreteLocation=...): # -> None:
        ...
    
    def findDefaultFont(self, discreteLocation=...): # -> None:
        ...
    
    getNeutralFont = ...
    def splitLocation(self, location): # -> tuple[dict[Any, Any], None] | tuple[dict[Any, Any], dict[Any, Any]]:
        ...
    
    def getSerializedAxes(self, discreteLocation=...): # -> list[Any]:
        ...
    
    def getContinuousAxesForMutator(self): # -> OrderedDict[Any, Any]:
        ...
    
    axisOrder = ...
    def getFullDesignLocation(self, location):
        ...
    
    def getDiscreteLocations(self): # -> list[Any]:
        ...
    
    def getOrderedDiscreteAxes(self): # -> list[Any]:
        ...
    
    def getOrderedContinuousAxes(self): # -> list[Any]:
        ...
    
    def checkDiscreteAxisValues(self, location): # -> bool:
        ...
    
    def collectBaseGlyphs(self, glyphName, location): # -> list[Any]:
        ...
    
    def sourceNameGenerator(self, prefix=..., count=...): # -> str:
        ...
    
    def findSourceDescriptorsForDiscreteLocation(self, discreteLocDict=...): # -> list[Any]:
        ...
    
    def getVariationModel(self, items, axes, bias=...): # -> tuple[dict[Any, Any], VariationModelMutator] | tuple[dict[Any, Any], None]:
        ...
    
    def newDefaultLocation(self, bend=..., discreteLocation=...): # -> OrderedDict[Any, Any]:
        ...
    
    def isAnisotropic(self, location): # -> bool:
        ...
    
    def splitAnisotropic(self, location): # -> tuple[Location, Location]:
        ...
    
    def collectForegroundLayerNames(self): # -> list[str | None]:
        """Return list of names of the default layers of all the fonts in this system.
            Include None and foreground. XX Why
        """
        ...
    
    def getReverseComponentMapping(self, discreteLocation=...): # -> dict[Any, Any]:
        """Return a dict with reverse component mappings.
            Check if we're using fontParts or defcon
            Check which part of the designspace we're in.
        """
        ...
    
    def generateUFOs(self, useVarlib=...): # -> list[Any]:
        ...
    
    generateUFO = ...
    @memoize
    def getInfoMutator(self, discreteLocation=...): # -> VariationModelMutator | None:
        """ Returns a info mutator for this discrete location """
        ...
    
    @memoize
    def getLibEntryMutator(self, discreteLocation=...): # -> VariationModelMutator | None:
        """ Returns a mutator for selected lib keys store in self.libKeysForProcessing
            If there is no entry in the lib, it will ignore the source
            If there are no libkeys, it will return None.
        """
        ...
    
    @memoize
    def getKerningMutator(self, pairs=..., discreteLocation=...): # -> VariationModelMutator | None:
        """ Return a kerning mutator, collect the sources, build mathGlyphs.
            If no pairs are given: calculate the whole table.
            If pairs are given then query the sources for a value and make a mutator only with those values.
        """
        ...
    
    @memoize
    def getGlyphMutator(self, glyphName, decomposeComponents=..., **discreteLocation): # -> tuple[VariationModelMutator | Any | None, set[Any]]:
        """make a mutator / varlib object for glyphName, with the sources for the given discrete location"""
        ...
    
    def isLocalDefault(self, location): # -> bool:
        ...
    
    def axesByName(self): # -> dict[Any, Any]:
        ...
    
    def locationWillClip(self, location): # -> bool:
        ...
    
    def getAxisExtremes(self, axisRecord): # -> tuple[Any, Any, Any]:
        ...
    
    def clipDesignLocation(self, location): # -> dict[Any, Any]:
        ...
    
    def filterThisLocation(self, location, mutedAxes=...): # -> tuple[Literal[False], Any] | tuple[bool, dict[Any, Any]]:
        ...
    
    def muteDesignLocation(self, mutedLocation): # -> bool:
        ...
    
    def clearMutedDesignLocations(self): # -> None:
        ...
    
    @memoize
    def collectSourcesForGlyph(self, glyphName, decomposeComponents=..., discreteLocation=..., asMathGlyph=...): # -> tuple[list[Any], set[Any]]:
        """ Return all source glyph objects.
                + either as mathglyphs (for use in mutators)
                + or source glyphs straight from the fonts
            decomposeComponents = True causes the source glyphs to be decomposed first
            before building the mutator. That gives you instances that do not depend
            on a complete font. If you're calculating previews for instance.

            findSourceDescriptorsForDiscreteLocation returns sources from layers as well

            will check with self.tempLib[self.mutedDesignLocationsLibKey] if the source location
            is muted or not.
        """
        ...
    
    def collectMastersForGlyph(self, glyphName, decomposeComponents=..., discreteLocation=...): # -> list[Any]:
        ...
    
    def getLocationType(self, location): # -> tuple[bool, dict[Any, Any], dict[Any, Any] | None, Location, Location]:
        """Determine the type of the location:
        continuous / discrete
        anisotropic / normal.
        """
        ...
    
    def excludeGlyph(self, glyphNameOrList): # -> None:
        ...
    
    def includeGlyph(self, glyphNameOrList): # -> None:
        ...
    
    def reportExcludedGlyphs(self): # -> LiteralString:
        ...
    
    def collectExcludedGlyphs(self): # -> list[Any]:
        ...
    
    def makeInstance(self, instanceDescriptor, doRules=..., glyphNames=..., decomposeComponents=..., pairs=..., bend=...):
        """ Generate a font object for this instance """
        ...
    
    def locationToDescriptiveString(self, loc): # -> LiteralString:
        ...
    
    def pathForInstance(self, instanceDescriptor): # -> None:
        ...
    
    def makeOneInstance(self, location, doRules=..., glyphNames=..., decomposeComponents=..., pairs=..., bend=...):
        ...
    
    def randomLocation(self, extrapolate=..., anisotropic=..., roundValues=..., discreteLocation=...): # -> dict[Any, Any]:
        """A good random location, for quick testing and entertainment
        extrapolate: is a factor of the (max-min) distance. 0 = nothing, 0.1 = 0.1 * (max - min)
        anisotropic= True: *all* continuous axes get separate x, y values
        for discrete axes: random choice from the defined values
        for continuous axes: interpolated value between axis.minimum and axis.maximum
        if discreteLocation is given, make a random location for the continuous part.

        assuming we want this location for testing the ufoOperator machine:
        we will eventually need a designspace location, not a userspace location.

        """
        ...
    
    def getLocationsForFont(self, fontObj): # -> tuple[list[Any], list[Any]]:
        ...
    
    def makeFontProportions(self, location, bend=..., roundGeometry=...): # -> dict[str, int] | dict[str, Any]:
        """Calculate the basic font proportions for this location, to map out expectations for drawing"""
        ...
    
    @memoize
    def makeOneGlyph(self, glyphName, location, decomposeComponents=..., useVarlib=..., roundGeometry=..., clip=...): # -> None:
        """
        glyphName:
        location: location including discrete axes, in **designspace** coordinates.
        decomposeComponents: decompose all components so we get a proper representation of the shape
        useVarlib: use varlib as mathmodel. Otherwise it is mutatorMath
        roundGeometry: round all geometry to integers
        clip: restrict axis values to the defined minimum and maximum

        + Supports extrapolation for varlib and mutatormath: though the results can be different
        + Supports anisotropic locations for varlib and mutatormath. Obviously this will not be present in any Variable font exports.

        Returns: a mathglyph, results are cached
        """
        ...
    
    def makeOneInfo(self, location, roundGeometry=..., clip=...): # -> None:
        """ Make the fontMath.mathInfo object for this location.
            You need to extract this to an instance font.
            location: location including discrete axes, in **designspace** coordinates.
        """
        ...
    
    def makeOneKerning(self, location, pairs=...): # -> None:
        """
        Make the fontMath.mathKerning for this location.
        location: location including discrete axes, in **designspace** coordinates.
        pairs: a list of pairs, if you want to get a subset
        """
        ...
    


if __name__ == "__main__":
    ds5Path = ...
    dumpCacheLog = ...
    makeUFOs = ...
    debug = ...
    startTime = ...
    testLibMathKey = ...
    randomLocation = ...
    randomGlyphName = ...
    res = ...
    endTime = ...
    duration = ...
    defaultLocation = ...
    glyph_names = ...
    instanceCounter = ...
    glyphName = ...
    dependencies = ...
    randomLocation = ...
    kerns = ...
    instanceFontObj = ...
    instanceFontName = ...
    testInstanceSavePath = ...
    randomLocation = ...
    info = ...
    outFont = ...
    newFontObj = ...
