"""
This type stub file was generated by pyright.
"""

import os
import logging
import traceback
import collections
import defcon
import fontParts.fontshell.font
import defcon.objects.font
from fontTools.designspaceLib import AxisDescriptor, DesignSpaceDocument, InstanceDescriptor, RuleDescriptor, SourceDescriptor, processRules
from fontTools.misc import plistlib
from fontTools.ufoLib import fontInfoAttributesVersion1, fontInfoAttributesVersion2, fontInfoAttributesVersion3
from fontTools.varLib.models import VariationModel, normalizeLocation
from defcon.objects.font import Font
from defcon.pens.transformPointPen import TransformPointPen
from defcon.objects.component import _defaultTransformation
from fontMath.mathGlyph import MathGlyph
from fontMath.mathInfo import MathInfo
from fontMath.mathKerning import MathKerning
from mutatorMath.objects.mutator import buildMutator
from mutatorMath.objects.location import Location
from ufoProcessor.varModels import VariationModelMutator
from ufoProcessor.emptyPen import DecomposePointPen, checkGlyphIsEmpty
from ._version import version as __version__

class UFOProcessorError(Exception):
    def __init__(self, msg, obj=...) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    


def getDefaultLayerName(f): # -> None:
    ...

def getLayer(f, layerName): # -> None:
    ...

def build(documentPath, outputUFOFormatVersion=..., roundGeometry=..., verbose=..., logPath=..., progressFunc=..., processRules=..., logger=..., useVarlib=...): # -> list[Any]:
    """
        Simple builder for UFO designspaces.
    """
    ...

def getUFOVersion(ufoPath): # -> Any:
    ...

def swapGlyphNames(font, oldName, newName, swapNameExtension=...): # -> None:
    ...

class DesignSpaceProcessor(DesignSpaceDocument):
    """
        A subclassed DesignSpaceDocument that can
            - process the document and generate finished UFOs with MutatorMath or varLib.model.
            - read and write documents
            - Replacement for the mutatorMath.ufo generator.
    """
    fontClass = ...
    layerClass = ...
    glyphClass = ...
    libClass = ...
    glyphContourClass = ...
    glyphPointClass = ...
    glyphComponentClass = ...
    glyphAnchorClass = ...
    kerningClass = ...
    groupsClass = ...
    infoClass = ...
    featuresClass = ...
    mathInfoClass = MathInfo
    mathGlyphClass = MathGlyph
    mathKerningClass = MathKerning
    def __init__(self, readerClass=..., writerClass=..., fontClass=..., ufoVersion=..., useVarlib=...) -> None:
        ...
    
    def generateUFO(self, processRules=..., glyphNames=..., pairs=..., bend=...): # -> Literal[True]:
        ...
    
    def getSerializedAxes(self): # -> list[Any]:
        ...
    
    def getMutatorAxes(self): # -> OrderedDict[Any, Any]:
        ...
    
    axisOrder = ...
    serializedAxes = ...
    def getVariationModel(self, items, axes, bias=...): # -> tuple[dict[Any, Any], VariationModelMutator] | tuple[dict[Any, Any], None]:
        ...
    
    def getInfoMutator(self): # -> VariationModelMutator | None:
        """ Returns a info mutator """
        ...
    
    def getKerningMutator(self, pairs=...): # -> VariationModelMutator | None:
        """ Return a kerning mutator, collect the sources, build mathGlyphs.
            If no pairs are given: calculate the whole table.
            If pairs are given then query the sources for a value and make a mutator only with those values.
        """
        ...
    
    def filterThisLocation(self, location, mutedAxes): # -> tuple[Literal[False], Any] | tuple[bool, dict[Any, Any]]:
        ...
    
    def getGlyphMutator(self, glyphName, decomposeComponents=..., fromCache=...): # -> VariationModelMutator | None:
        ...
    
    def collectMastersForGlyph(self, glyphName, decomposeComponents=...): # -> list[Any]:
        """ Return a glyph mutator.defaultLoc
            decomposeComponents = True causes the source glyphs to be decomposed first
            before building the mutator. That gives you instances that do not depend
            on a complete font. If you're calculating previews for instance.

            XXX check glyphs in layers
        """
        ...
    
    def getNeutralFont(self): # -> None:
        ...
    
    def findDefault(self): # -> None:
        """Set and return SourceDescriptor at the default location or None.

        The default location is the set of all `default` values in user space of all axes.
        """
        ...
    
    def newDefaultLocation(self, bend=...): # -> OrderedDict[Any, Any]:
        ...
    
    def loadFonts(self, reload=...): # -> None:
        ...
    
    def getFonts(self): # -> list[Any]:
        ...
    
    def makeInstance(self, instanceDescriptor, doRules=..., glyphNames=..., pairs=..., bend=...):
        """ Generate a font object for this instance """
        ...
    
    def isAnisotropic(self, location): # -> bool:
        ...
    
    def splitAnisotropic(self, location): # -> tuple[Location, Location]:
        ...
    


