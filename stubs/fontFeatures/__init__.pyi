"""
This type stub file was generated by pyright.
"""

from collections import OrderedDict
from fontTools.feaLib.ast import ValueRecord as feaLibValueRecord
from fontTools.feaLib.variableScalar import VariableScalar
from itertools import chain
from copy import copy

"""
The FontFeatures class is a way of representing the transformations -
substitutions and positionings - going on inside a font at a semantically
high level. It aims to be independent of and unconstrained by the OpenType
representation, with the assumption that these high-level objects can be
either "compiled down" into AFDKO feature code or directly written to the
GSUB/GPOS tables of a font.

FontFeatures aims to marshal data between OTF binary representations,
AFDKO feature code, FontDame, and can power other representations such as the
FEZ language (see the 'fez' library).

A FontFeatures representation of a font will make use of two other top-level
concepts: Features and Routines. Routines are collections of rules; they play
a similar function to the AFDKO concept of a lookup, but unlike lookups,
Routines do not need to be comprised of rules of the same type. You can think
of them as functions that are called on a glyph string.

Here is an example of constructing a simple feature file using fontFeatures::

    ff = FontFeatures()

    liga_ffi = Substitution( [ ["f"], ["f"], ["i"] ], replacement=[["f_f_i"]] )
    liga_ffl = Substitution( [ ["f"], ["f"], ["l"] ], replacement=[["f_f_l"]] )
    liga_fi = Substitution( [ ["f"], ["i"] ], replacement=[["fi"]] )
    liga_ff = Substitution( [ ["f"], ["f"] ], replacement=[["f_f"]] )
    liga_routine = Routine(rules=[liga_ffi, liga_ffl, liga_fi, liga_ff])

    ff.addFeature("liga", [liga_routine])

    # Export Adobe syntax
    print(ff.asFea())

    font = TTFont("Test.ttf")
    ff.buildBinaryFeatures(font)
    font.save("Test-liga.ttf")
"""
class FontFeatures:
    """An object representing the layout rules in a font.

    The initializer has no parameters."""
    def __init__(self) -> None:
        ...
    
    def __add__(self, other): # -> FontFeatures:
        """Combine two FontFeatures objects together."""
        ...
    
    def gensym(self, category): # -> str:
        """Generate a new unique symbol (used for labeling unlabeled data).

        Args:
            category (str): The category for this symbol

        Returns: a string representing a unique label."""
        ...
    
    def routineNamed(self, name):
        """Finds a routine with the given name.

        Args:
            name (str): The name to find

        Returns: a :py:class:`Routine` object if the named routine was found
          in the features object. Raises a ``ValueError`` if not."""
        ...
    
    def referenceRoutine(self, r, do_usecount=...): # -> RoutineReference:
        """Store a routine and return a reference to it.

        Args:
            r: A :py:class:`Routine` object.
        """
        ...
    
    def getNamedClassFor(self, glyphs, name):
        """Find and optionally stores a named class of glyphs

        Args:
            glyphs: A sequence of glyph names.
            name: A name for this glyph class if it does not exist.

        Returns:
            The name of a glyph class. If the exact same set of glyphs
            was already stored as a glyph class, then the name of that
            class will be returned. If not, then the class will be stored
            and the name provided as the ``name`` argument will be returned.
        """
        ...
    
    def addFeature(self, name, rs): # -> None:
        """Add Routines to a named feature.

        Args:
            name: The feature name.
            rs: A sequence of :py:class:`Routine` or :py:class:`RoutineReference` objects.
        """
        ...
    
    def allRules(self, ruletype=...): # -> filter[Any] | list[Any]:
        """Return all rules in the font, optionally filtered by type

        Args:
            ruletype: A class (``Positioning``, ``Substitution`` etc)
                to filter the results.

        Returns:
            Routines stored in the preamble and within features.
        """
        ...
    
    def markRoutineUseInChains(self): # -> None:
        """Annotate routines which are used in chaining rules.

        Generally used when converting the fontFeatures object to another
        format; allows routines to know where they are being used by annotating
        them with the ``.usedin`` property for optimization purposes.
        """
        ...
    
    def hoist_languages(self): # -> None:
        """Sort routines into scripts and languages and resolve wildcards."""
        ...
    
    def hasScriptSupport(self, script): # -> bool:
        """Check if the features object has support for a particular script.

        Args:
            script (str): A four-character OpenType script code.

        Returns: boolean
        """
        ...
    
    def resolveAllRoutines(self): # -> None:
        """Resolve reference use in chains.

        Checks that all routines referenced in chain rules can actually
        be found within the object, and adds pointers to match named routine
        references with the relevant :py:class:`Routine` object.
        """
        ...
    
    def ensureLookupsAreReferences(self, lookuplist): # -> list[Any] | None:
        """Ensures that all references are lookups.

        Naughty people might put :py:class:`Routine` objects directly into
        :py:class:`Chain` lookups. This tidies them up."""
        ...
    
    def setGlyphClassesFromFont(self, font): # -> None:
        """Loads glyph classes from the font."""
        ...
    
    def partitionRoutine(self, routine, factor): # -> None:
        """Splits a routine based on a predicate.

        This method applies a function to each rule in the routine and creates
        distinct routines, each containing rules with the same return value
        from the function. This is useful, for example, when exporting to
        OpenType, to ensure that all rules in a routine must have the same type,
        same flags, etc.

        Args:
            routine: A :py:class:`Routine` object.
            factor: A function applied to each of the :py:class:`Rule` objects.

        Returns: A list of :py:class:`Routine` objects. Additionally, modifies
        the ``.routines`` list of the FontFeatures object."""
        ...
    
    def replaceRoutineWithSplitList(self, routine, allroutines):
        ...
    


class Routine:
    """Represent a Routine (similar to OT Lookup).

    A routine is a set of rules, sometimes but not always with an explicit name.
    It can apply to a set of language/script pairs.
    """
    def __init__(self, name=..., rules=..., address=..., inlined=..., languages=..., parent=..., flags=..., markFilteringSet=..., markAttachmentSet=...) -> None:
        ...
    
    def addRule(self, rule): # -> None:
        """Adds a rule to a Routine.

        Args:
            rule: A ``Substitution``, ``Positioning``, etc. object.
        """
        ...
    
    def addComment(self, comment): # -> None:
        """Adds a comment to a Routine.

        Comments are emitted when the Routine is converted to text formats
        such as AFDKO.

        Args:
            comment: A string comment.
        """
        ...
    
    @property
    def involved_glyphs(self): # -> set[Any]:
        """Returns the names of all of the glyphs involved in this Routine."""
        ...
    
    @property
    def stage(self): # -> Literal['sub', 'pos'] | None:
        """Returns which shaping stage this routine is used in.

        Returns: ``sub`` for substitution stage, ``pos`` for positioning stage."""
        ...
    
    @property
    def dependencies(self): # -> list[Any]:
        """Returns a list of :py:class:`Routine` objects called as lookups in
        this Routine."""
        ...
    


class ExtensionRoutine(Routine):
    """OpenType-specific concept: A routine which contains other routines."""
    def __init__(self, **kwargs) -> None:
        ...
    
    def apply_to_buffer(self, buf, stage=..., feature=...): # -> None:
        """Applies shaping rules from this routine to a buffer.

        Args:
            buf: A :py:class:`fontFeatures.shaperLib.Buffer` object.
            stage (str): Shaping stage - ``sub`` or ``pos``.
            feature (str): The feature being processed. (For debugging.)

        Modifies the ``buf`` object.
        """
        ...
    
    def asFeaAST(self): # -> Block:
        """Returns this extension routine as ``fontTools.feaLib.ast`` objects."""
        ...
    
    @property
    def stage(self):
        """Returns which shaping stage this routine is used in.

        Returns: ``sub`` for substitution stage, ``pos`` for positioning stage."""
        ...
    
    @property
    def rules(self): # -> list[Any]:
        """All rules under this extension.

        Returns: A flattened list of :py:class:`Rule` objects."""
        ...
    
    @rules.setter
    def rules(self, foo): # -> None:
        """Does nothing. Don't set rules here."""
        ...
    


class RoutineReference:
    """A reference to a Routine object, used in a lookup.

    Routines can be referenced either by name (for example, when loaded from a
    textual representation), in which case they will be resolved at a later time,
    or by providing a pointer to the :py:class:`Routine` object."""
    def __init__(self, name=..., routine=...) -> None:
        ...
    
    def resolve(self, ff): # -> None:
        """Resolves the reference in the context of a :py:class:`FontFeatures`
        object.

        Raises a ``ValueError`` if a named routine cannot be found.
        """
        ...
    
    @property
    def stage(self):
        """Returns which shaping stage this routine is used in.

        Returns: ``sub`` for substitution stage, ``pos`` for positioning stage."""
        ...
    
    def asFea(self):
        """Returns this Rule as a string of AFDKO feature text."""
        ...
    


class Rule:
    """A base class for all rules."""
    def asFea(self):
        """Returns this Rule as a string of AFDKO feature text."""
        ...
    
    def feaPreamble(self, ff): # -> list[Any]:
        """Computes any text that needs to go in the feature file header."""
        ...
    
    @property
    def has_context(self): # -> int:
        """Does this rule have any pre- or post-context defined?"""
        ...
    
    @property
    def dependencies(self): # -> list[Any]:
        """Returns a list of :py:class:`Routine` objects called as lookups in
        this Routine."""
        ...
    


class Substitution(Rule):
    """Represents a Substitution rule.

    A substitution represents any kind of exchange of one set of glyphs for
    another: single substitutions, multiple substitutions and ligatures are all
    substitutions. Optionally, substitutions may be followed by precontext and
    postcontext.

    Args:
        input_: A list of lists. The outer list represents the positions in
            the glyph stream to substitute, with the inner list representing
            the glyph names at each position.
        replacement: A list of glyph names.
        precontext: A list of list of glyphs which must appear before the input
            sequence.
        postcontext: A list of list of glyphs which must appear before the input
            sequence.
        lookups: A list of list of lookups to be applied to the glyph sequence.
            The outer list represents the positions in the input sequence, with
            the inner list containing Routines to apply.
        reverse: Boolean representing if the substitutions should take place from
            the end of the string.
        force_alt: Force this substitution to be interpreted as an alternate
            substitution.

    Examples::

        lig = Substitution(
            [ ["f"], ["i"] ],
            ["f_i"]
        ) # sub f i by f_i;

        contextual = Substitution(
            [ ["dotbelow"] ],
            [ ["dotbelow.post"] ],
            precontext = [["ra-myanmar", "ra-myanmar.bt1", "ra-myanmar.bt2"]]
        ) # sub [ra-myanmar ra-myanmar.bt1 ra-myanmar.bt2] dotbelow-myanmar'
          # by dotbelow-myanmar.post;
    """
    def __init__(self, input_, replacement, precontext=..., postcontext=..., address=..., languages=..., lookups=..., reverse=..., flags=..., force_alt=...) -> None:
        ...
    
    @property
    def involved_glyphs(self): # -> set[Any]:
        """Returns a set of all glyphs involved in this rule."""
        ...
    


class Chaining(Rule):
    """Represents a Chain rule.

    A Chain rule represents the operation of calling another Routine when
    a particular input context is met.

    Args:
        input_: A list of lists. The outer list represents the positions in
            the glyph stream to substitute, with the inner list representing
            the glyph names at each position.
        precontext: A list of list of glyphs which must appear before the input
            sequence.
        postcontext: A list of list of glyphs which must appear before the input
            sequence.
        lookups: A list of list of lookups to be applied to the glyph sequence.
            The outer list represents the positions in the input sequence, with
            the inner list containing Routines to apply.

    Example::

        sub_Qu = Routine(rules=[
            Substitute([["Q"]], [["Q.beforeu"]])
        ])

        chain = Chain(
            [["Q"]],
            postcontext = [ ["u", "v", "u.sc", "v.sc"] ],
            lookups = [ [sub_Qu] ]
        ) # sub Q' lookup sub_Qu [u v u.sc v.sc];
    """
    def __init__(self, input_, precontext=..., postcontext=..., address=..., languages=..., lookups=..., flags=...) -> None:
        ...
    
    @property
    def stage(self): # -> None:
        """Returns which shaping stage this routine is used in.

        Returns: ``sub`` for substitution stage, ``pos`` for positioning stage."""
        ...
    
    @property
    def involved_glyphs(self): # -> set[Any]:
        """Returns a set of all glyphs involved in this rule."""
        ...
    
    @property
    def dependencies(self): # -> list[Any]:
        """Returns a list of :py:class:`Routine` objects called as lookups in
        this Routine."""
        ...
    


class ValueRecord(feaLibValueRecord):
    """A value record for representing positional changes in advance and placement.

    See :py:class:`fontTools.feaLib.ValueRecord`, from which this inherits.
    """
    @property
    def is_variable(self): # -> bool:
        """Returns true if any of the elements of the value record are a
        :py:class:`fontTools.feaLib.VariableScalar`."""
        ...
    


class Positioning(Rule):
    """Represents a Positioning rule.

    Args:
        input_: A list of lists. The outer list represents the positions in
            the glyph stream to position, with the inner list representing
            the glyph names at each glyph stream position.
        valuerecords: A list of ``ValueRecord`` objects to be applied at each
            glyph stream position.
        precontext: A list of list of glyphs which must appear before the input
            sequence.
        postcontext: A list of list of glyphs which must appear before the input
            sequence.

    Example::

        open_up_behs = Positioning(
            [
                ["BEi1", "BEi2"],
                ["sda", "sdb", "dda", "ddb"]
            ],
            [
                ValueRecord(xAdvance=200),
                ValueRecord(xPlacement=50),
            ]
            postcontext = [ medis_finas ]
        )
        # pos [BEi1 BEi2]' <0 0 200 0> [sda sdb dda ddb]' <0 50 0 0> @medis_finas;
    """
    def __init__(self, glyphs, valuerecords, precontext=..., postcontext=..., address=..., languages=..., flags=...) -> None:
        ...
    
    @property
    def involved_glyphs(self): # -> set[Any]:
        """Returns a set of all glyphs involved in this rule."""
        ...
    


class Attachment(Rule):
    """Represents an Attachment rule.

    Args:
        base_name: Name of the base class.
        mark_name: Name of the mark class.
        bases: Dictionary. They keys are names of glyphs to act as bases to
            the attachment (this may be categorized as mark glyphs if the
            attachment is a mark-to-mark operation); the associated values are
            a two-element tuple with the coordinates of the anchor.
        marks: Dictionary. They keys are names of glyphs to act as marks;
            the associated values are a two-element tuple with the coordinates
            of the anchor.
        force_markmark: boolean. If true, force this to be interpreted as a
            mark-to-mark operation

    Whether this is a mark-to-base or mark-to-mark operation will be determined
    by the glyph category of the glyphs involved in the `bases` dictionary and
    the value of the `force_markmark` argument.

    Examples::

        ff.anchors = {
            "a": { "top": (250, 603) },
            "acutecomb": { "_top": (56, 0) }
        }

        top_bases = {}
        top_marks = {}
        for glyphname, anchors in ff.anchors.items():
            for anchorname, position in anchors.items():
                if anchorname == "top":
                    top_bases[glyphname] = position
                if anchorname == "_top":
                    top_marks[glyphname] = position

        # top_bases = { "a": (260,603) }
        # top_marks = { "acutecomb": (56,0) }

        tops = Attachment("top", "_top", top_bases, top_marks)
    """
    def __init__(self, base_name, mark_name, bases=..., marks=..., fullname=..., flags=..., address=..., font=..., languages=..., force_markmark=...) -> None:
        ...
    
    @property
    def is_cursive(self):
        """Returns true if this is a cursive attachment rule."""
        ...
    
    @property
    def involved_glyphs(self): # -> set[Any]:
        """Returns a set of all glyphs involved in this rule."""
        ...
    


