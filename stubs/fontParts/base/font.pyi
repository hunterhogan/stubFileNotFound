"""
This type stub file was generated by pyright.
"""

from fontParts.base.base import InterpolationMixin
from fontParts.base.layer import _BaseGlyphVendor
from fontParts.base.compatibility import FontCompatibilityReporter
from fontParts.base.deprecated import DeprecatedFont, RemovedFont

class BaseFont(_BaseGlyphVendor, InterpolationMixin, DeprecatedFont, RemovedFont):
    """
    A font object. This object is almost always
    created with one of the font functions in
    :ref:`fontparts-world`.
    """
    def __init__(self, pathOrObject=..., showInterface=...) -> None:
        """
        When constructing a font, the object can be created
        in a new file, from an existing file or from a native
        object. This is defined with the **pathOrObjectArgument**.
        If **pathOrObject** is a string, the string must represent
        an existing file. If **pathOrObject** is an instance of the
        environment's unwrapped native font object, wrap it with
        FontParts. If **pathOrObject** is None, create a new,
        empty font. If **showInterface** is ``False``, the font
        should be created without graphical interface. The default
        for **showInterface** is ``True``.
        """
        ...
    
    copyAttributes = ...
    def copy(self): # -> Self:
        """
        Copy the font into a new font. ::

            >>> copiedFont = font.copy()

        This will copy:

        * info
        * groups
        * kerning
        * features
        * lib
        * layers
        * layerOrder
        * defaultLayerName
        * glyphOrder
        * guidelines
        """
        ...
    
    def copyData(self, source): # -> None:
        """
        Copy data from **source** into this font.
        Refer to :meth:`BaseFont.copy` for a list
        of values that will be copied.
        """
        ...
    
    path = ...
    def save(self, path=..., showProgress=..., formatVersion=..., fileStructure=...): # -> None:
        """
        Save the font to **path**.

            >>> font.save()
            >>> font.save("/path/to/my/font-2.ufo")

        If **path** is None, use the font's original location.
        The file type must be inferred from the file extension
        of the given path. If no file extension is given, the
        environment may fall back to the format of its choice.
        **showProgress** indicates if a progress indicator should
        be displayed during the operation. Environments may or may
        not implement this behavior. **formatVersion** indicates
        the format version that should be used for writing the given
        file type. For example, if 2 is given for formatVersion
        and the file type being written if UFO, the file is to
        be written in UFO 2 format. This value is not limited
        to UFO format versions. If no format version is given,
        the original format version of the file should be preserved.
        If there is no original format version it is implied that
        the format version is the latest version for the file
        type as supported by the environment. **fileStructure** indicates
        the file structure of the written ufo. The **fileStructure** can
        either be None, 'zip' or 'package', None will use the existing file
        strucure or the default one for unsaved font. 'package' is the default
        file structure and 'zip' will save the font to .ufoz.

        .. note::

           Environments may define their own rules governing when
           a file should be saved into its original location and
           when it should not. For example, a font opened from a
           compiled OpenType font may not be written back into
           the original OpenType font.
        """
        ...
    
    def close(self, save=...): # -> None:
        """
        Close the font.

            >>> font.close()

        **save** is a boolean indicating if the font
        should be saved prior to closing. If **save**
        is ``True``, the :meth:`BaseFont.save` method
        will be called. The default is ``False``.
        """
        ...
    
    @staticmethod
    def generateFormatToExtension(format, fallbackFormat): # -> str | None:
        """
        +--------------+--------------------------------------------------------------------+
        | mactype1     | Mac Type 1 font (generates suitcase  and LWFN file)                |
        +--------------+--------------------------------------------------------------------+
        | macttf       | Mac TrueType font (generates suitcase)                             |
        +--------------+--------------------------------------------------------------------+
        | macttdfont   | Mac TrueType font (generates suitcase with resources in data fork) |
        +--------------+--------------------------------------------------------------------+
        | otfcff       | PS OpenType (CFF-based) font (OTF)                                 |
        +--------------+--------------------------------------------------------------------+
        | otfttf       | PC TrueType/TT OpenType font (TTF)                                 |
        +--------------+--------------------------------------------------------------------+
        | pctype1      | PC Type 1 font (binary/PFB)                                        |
        +--------------+--------------------------------------------------------------------+
        | pcmm         | PC MultipleMaster font (PFB)                                       |
        +--------------+--------------------------------------------------------------------+
        | pctype1ascii | PC Type 1 font (ASCII/PFA)                                         |
        +--------------+--------------------------------------------------------------------+
        | pcmmascii    | PC MultipleMaster font (ASCII/PFA)                                 |
        +--------------+--------------------------------------------------------------------+
        | ufo1         | UFO format version 1                                               |
        +--------------+--------------------------------------------------------------------+
        | ufo2         | UFO format version 2                                               |
        +--------------+--------------------------------------------------------------------+
        | ufo3         | UFO format version 3                                               |
        +--------------+--------------------------------------------------------------------+
        | unixascii    | UNIX ASCII font (ASCII/PFA)                                        |
        +--------------+--------------------------------------------------------------------+
        """
        ...
    
    def generate(self, format, path=..., **environmentOptions): # -> None:
        """
        Generate the font to another format.

            >>> font.generate("otfcff")
            >>> font.generate("otfcff", "/path/to/my/font.otf")

        **format** defines the file format to output.
        Standard format identifiers can be found in :attr:`BaseFont.generateFormatToExtension`:


        Environments are not required to support all of these
        and environments may define their own format types.
        **path** defines the location where the new file should
        be created. If a file already exists at that location,
        it will be overwritten by the new file. If **path** defines
        a directory, the file will be output as the current
        file name, with the appropriate suffix for the format,
        into the given directory. If no **path** is given, the
        file will be output into the same directory as the source
        font with the file named with the current file name,
        with the appropriate suffix for the format.

        Environments may allow unique keyword arguments in this
        method. For example, if a tool allows decomposing components
        during a generate routine it may allow this:

            >>> font.generate("otfcff", "/p/f.otf", decompose=True)
        """
        ...
    
    info = ...
    groups = ...
    kerning = ...
    def getFlatKerning(self): # -> dict[Any, Any]:
        """
        Get the font's kerning as a flat dictionary.
        """
        ...
    
    features = ...
    lib = ...
    tempLib = ...
    layers = ...
    layerOrder = ...
    defaultLayerName = ...
    defaultLayer = ...
    def getLayer(self, name): # -> None:
        """
        Get the :class:`BaseLayer` with **name**.

            >>> layer = font.getLayer("My Layer 2")
        """
        ...
    
    def newLayer(self, name, color=...): # -> None:
        """
        Make a new layer with **name** and **color**.
        **name** must be a :ref:`type-string` and
        **color** must be a :ref:`type-color` or ``None``.

            >>> layer = font.newLayer("My Layer 3")

        The will return the newly created
        :class:`BaseLayer`.
        """
        ...
    
    def removeLayer(self, name): # -> None:
        """
        Remove the layer with **name** from the font.

            >>> font.removeLayer("My Layer 3")
        """
        ...
    
    def insertLayer(self, layer, name=...): # -> None:
        """
        Insert **layer** into the font. ::

            >>> layer = font.insertLayer(otherLayer, name="layer 2")

        This will not insert the layer directly.
        Rather, a new layer will be created and the data from
        **layer** will be copied to to the new layer. **name**
        indicates the name that should be assigned to the layer
        after insertion. If **name** is not given, the layer's
        original name must be used. If the layer does not have
        a name, an error must be raised. The data that will be
        inserted from **layer** is the same data as documented
        in :meth:`BaseLayer.copy`.
        """
        ...
    
    def duplicateLayer(self, layerName, newLayerName): # -> BaseLayer:
        """
        Duplicate the layer with **layerName**, assign
        **newLayerName** to the new layer and insert the
        new layer into the font. ::

            >>> layer = font.duplicateLayer("layer 1", "layer 2")
        """
        ...
    
    def swapLayerNames(self, layerName, otherLayerName): # -> None:
        """
        Assign **layerName** to the layer currently named
        **otherLayerName** and assign the name **otherLayerName**
        to the layer currently named **layerName**.

            >>> font.swapLayerNames("before drawing revisions", "after drawing revisions")
        """
        ...
    
    def __setitem__(self, name, glyph): # -> None:
        """
        Insert **glyph** into the font. ::

            >>> glyph = font["A"] = otherGlyph

        This will not insert the glyph directly. Rather, a
        new glyph will be created and the data from **glyph**
        will be copied to the new glyph. **name** indicates
        the name that should be assigned to the glyph after
        insertion. The data that will be inserted
        from **glyph** is the same data as documented in
        :meth:`BaseGlyph.copy`.

        On a font level **font.glyphOrder** will be preserved
        if the **name** is already present.
        """
        ...
    
    glyphOrder = ...
    def round(self): # -> None:
        """
        Round all approriate data to integers.

            >>> font.round()

        This is the equivalent of calling the round method on:

        * info
        * kerning
        * the default layer
        * font-level guidelines

        This applies only to the default layer.
        """
        ...
    
    def autoUnicodes(self): # -> None:
        """
        Use heuristics to set Unicode values in all glyphs.

            >>> font.autoUnicodes()

        Environments will define their own heuristics for
        automatically determining values.

        This applies only to the default layer.
        """
        ...
    
    guidelines = ...
    def appendGuideline(self, position=..., angle=..., name=..., color=..., guideline=...): # -> None:
        """
        Append a new guideline to the font.

            >>> guideline = font.appendGuideline((50, 0), 90)
            >>> guideline = font.appendGuideline((0, 540), 0, name="overshoot",
            >>> color=(0, 0, 0, 0.2))

        **position** must be a :ref:`type-coordinate`
        indicating the position of the guideline.
        **angle** indicates the :ref:`type-angle` of
        the guideline. **name** indicates the name
        for the guideline. This must be a :ref:`type-string`
        or ``None``. **color** indicates the color for
        the guideline. This must be a :ref:`type-color`
        or ``None``. This will return the newly created
        :class:`BaseGuidline` object.

        ``guideline`` may be a :class:`BaseGuideline` object from which
        attribute values will be copied. If ``position``, ``angle``, ``name``
        or ``color`` are specified as arguments, those values will be used
        instead of the values in the given guideline object.
        """
        ...
    
    def removeGuideline(self, guideline): # -> None:
        """
        Remove **guideline** from the font.

            >>> font.removeGuideline(guideline)
            >>> font.removeGuideline(2)

        **guideline** can be a guideline object or
        an integer representing the guideline index.
        """
        ...
    
    def clearGuidelines(self): # -> None:
        """
        Clear all guidelines.

            >>> font.clearGuidelines()
        """
        ...
    
    def interpolate(self, factor, minFont, maxFont, round=..., suppressError=...): # -> None:
        """
        Interpolate all possible data in the font.

            >>> font.interpolate(0.5, otherFont1, otherFont2)
            >>> font.interpolate((0.5, 2.0), otherFont1, otherFont2, round=False)

        The interpolation occurs on a 0 to 1.0 range where **minFont**
        is located at 0 and **maxFont** is located at 1.0. **factor**
        is the interpolation value. It may be less than 0 and greater
        than 1.0. It may be a :ref:`type-int-float` or a tuple of
        two :ref:`type-int-float`. If it is a tuple, the first
        number indicates the x factor and the second number indicates
        the y factor. **round** indicates if the result should be
        rounded to integers. **suppressError** indicates if incompatible
        data should be ignored or if an error should be raised when
        such incompatibilities are found.
        """
        ...
    
    compatibilityReporterClass = FontCompatibilityReporter
    def isCompatible(self, other): # -> tuple[bool, Any]:
        """
        Evaluate interpolation compatibility with **other**.

            >>> compatible, report = self.isCompatible(otherFont)
            >>> compatible
            False
            >>> report
            [Fatal] Glyph: "test1" + "test2"
            [Fatal] Glyph: "test1" contains 1 contours | "test2" contains 2 contours

        This will return a ``bool`` indicating if the font is
        compatible for interpolation with **other** and a
        :ref:`type-string` of compatibility notes.
        """
        ...
    
    def getReverseComponentMapping(self): # -> Any:
        """
        Get a reversed map of component references in the font.
        {
        'A' : ['Aacute', 'Aring']
        'acute' : ['Aacute']
        'ring' : ['Aring']
        etc.
        }
        """
        ...
    
    def getCharacterMapping(self): # -> Any:
        """
        Create a dictionary of unicode -> [glyphname, ...] mappings.
        All glyphs are loaded. Note that one glyph can have multiple unicode values,
        and a unicode value can have multiple glyphs pointing to it.
        """
        ...
    
    selectedLayers = ...
    selectedLayerNames = ...
    selectedGuidelines = ...


