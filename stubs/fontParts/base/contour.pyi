"""
This type stub file was generated by pyright.
"""

from fontParts.base.base import BaseObject, IdentifierMixin, InterpolationMixin, SelectionMixin, TransformationMixin
from fontParts.base.compatibility import ContourCompatibilityReporter
from fontParts.base.deprecated import DeprecatedContour, RemovedContour

class BaseContour(BaseObject, TransformationMixin, InterpolationMixin, SelectionMixin, IdentifierMixin, DeprecatedContour, RemovedContour):
    segmentClass = ...
    bPointClass = ...
    def copyData(self, source): # -> None:
        ...
    
    _glyph = ...
    glyph = ...
    font = ...
    layer = ...
    index = ...
    def getIdentifierForPoint(self, point): # -> None:
        """
        Create a unique identifier for and assign it to ``point``.
        If the point already has an identifier, the existing
        identifier will be returned.

            >>> contour.getIdentifierForPoint(point)
            'ILHGJlygfds'

        ``point`` must be a :class:`BasePoint`. The returned value
        will be a :ref:`type-identifier`.
        """
        ...
    
    def draw(self, pen): # -> None:
        """
        Draw the contour's outline data to the given :ref:`type-pen`.

            >>> contour.draw(pen)
        """
        ...
    
    def drawPoints(self, pen): # -> None:
        """
        Draw the contour's outline data to the given :ref:`type-point-pen`.

            >>> contour.drawPoints(pointPen)
        """
        ...
    
    def autoStartSegment(self): # -> None:
        """
        Automatically calculate and set the first segment
        in this contour.

        The behavior of this may vary accross environments.
        """
        ...
    
    def round(self): # -> None:
        """
        Round coordinates in all points to integers.
        """
        ...
    
    compatibilityReporterClass = ContourCompatibilityReporter
    def isCompatible(self, other): # -> tuple[bool, Any]:
        """
        Evaluate interpolation compatibility with **other**. ::

            >>> compatible, report = self.isCompatible(otherContour)
            >>> compatible
            False
            >>> compatible
            [Fatal] Contour: [0] + [0]
            [Fatal] Contour: [0] contains 4 segments | [0] contains 3 segments
            [Fatal] Contour: [0] is closed | [0] is open

        This will return a ``bool`` indicating if the contour is
        compatible for interpolation with **other** and a
        :ref:`type-string` of compatibility notes.
        """
        ...
    
    open = ...
    clockwise = ...
    def reverse(self): # -> None:
        """
        Reverse the direction of the contour.
        """
        ...
    
    def pointInside(self, point):
        """
        Determine if ``point`` is in the black or white of the contour.

            >>> contour.pointInside((40, 65))
            True

        ``point`` must be a :ref:`type-coordinate`.
        """
        ...
    
    def contourInside(self, otherContour): # -> None:
        """
        Determine if ``otherContour`` is in the black or white of this contour.

            >>> contour.contourInside(otherContour)
            True

        ``contour`` must be a :class:`BaseContour`.
        """
        ...
    
    bounds = ...
    area = ...
    segments = ...
    def __getitem__(self, index): # -> Any:
        ...
    
    def __iter__(self): # -> Generator[Any, Any, None]:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def appendSegment(self, type=..., points=..., smooth=..., segment=...): # -> None:
        """
        Append a segment to the contour.
        """
        ...
    
    def insertSegment(self, index, type=..., points=..., smooth=..., segment=...): # -> None:
        """
        Insert a segment into the contour.
        """
        ...
    
    def removeSegment(self, segment, preserveCurve=...): # -> None:
        """
        Remove segment from the contour.
        If ``preserveCurve`` is set to ``True`` an attempt
        will be made to preserve the shape of the curve
        if the environment supports that functionality.
        """
        ...
    
    def setStartSegment(self, segment): # -> None:
        """
        Set the first segment on the contour.
        segment can be a segment object or an index.
        """
        ...
    
    bPoints = ...
    def appendBPoint(self, type=..., anchor=..., bcpIn=..., bcpOut=..., bPoint=...): # -> None:
        """
        Append a bPoint to the contour.
        """
        ...
    
    def insertBPoint(self, index, type=..., anchor=..., bcpIn=..., bcpOut=..., bPoint=...): # -> None:
        """
        Insert a bPoint at index in the contour.
        """
        ...
    
    def removeBPoint(self, bPoint): # -> None:
        """
        Remove the bpoint from the contour.
        bpoint can be a point object or an index.
        """
        ...
    
    points = ...
    def appendPoint(self, position=..., type=..., smooth=..., name=..., identifier=..., point=...): # -> None:
        """
        Append a point to the contour.
        """
        ...
    
    def insertPoint(self, index, position=..., type=..., smooth=..., name=..., identifier=..., point=...): # -> None:
        """
        Insert a point into the contour.
        """
        ...
    
    def removePoint(self, point, preserveCurve=...): # -> None:
        """
        Remove the point from the contour.
        point can be a point object or an index.
        If ``preserveCurve`` is set to ``True`` an attempt
        will be made to preserve the shape of the curve
        if the environment supports that functionality.
        """
        ...
    
    def setStartPoint(self, point): # -> None:
        """
        Set the first point on the contour.
        point can be a point object or an index.
        """
        ...
    
    selectedSegments = ...
    selectedPoints = ...
    selectedBPoints = ...


