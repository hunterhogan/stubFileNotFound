"""
This type stub file was generated by pyright.
"""

from fontParts.base.base import BaseObject, InterpolationMixin, SelectionMixin, TransformationMixin
from fontParts.base.compatibility import GlyphCompatibilityReporter
from fontParts.base.deprecated import DeprecatedGlyph, RemovedGlyph

class BaseGlyph(BaseObject, TransformationMixin, InterpolationMixin, SelectionMixin, DeprecatedGlyph, RemovedGlyph):
    """
    A glyph object. This object will almost always
    be created by retrieving it from a font object.
    """
    copyAttributes = ...
    def copy(self): # -> Self:
        """
        Copy this glyph's data into a new glyph object.
        This new glyph object will not belong to a font.

            >>> copiedGlyph = glyph.copy()

        This will copy:

        - name
        - unicodes
        - width
        - height
        - note
        - markColor
        - lib
        - contours
        - components
        - anchors
        - guidelines
        - image
        """
        ...
    
    def copyData(self, source): # -> None:
        ...
    
    _layer = ...
    layer = ...
    font = ...
    name = ...
    unicodes = ...
    unicode = ...
    def autoUnicodes(self): # -> None:
        """
        Use heuristics to set the Unicode values in the glyph.

            >>> glyph.autoUnicodes()

        Environments will define their own heuristics for
        automatically determining values.
        """
        ...
    
    width = ...
    leftMargin = ...
    rightMargin = ...
    height = ...
    bottomMargin = ...
    topMargin = ...
    def getPen(self): # -> None:
        """
        Return a :ref:`type-pen` object for adding outline data
        to the glyph.

            >>> pen = glyph.getPen()
        """
        ...
    
    def getPointPen(self): # -> None:
        """
        Return a :ref:`type-pointpen` object for adding outline data
        to the glyph.

            >>> pointPen = glyph.getPointPen()
        """
        ...
    
    def draw(self, pen, contours=..., components=...): # -> None:
        """
        Draw the glyph's outline data (contours and components) to
        the given :ref:`type-pen`.

            >>> glyph.draw(pen)

        If ``contours`` is set to ``False``, the glyph's
        contours will not be drawn.

            >>> glyph.draw(pen, contours=False)

        If ``components`` is set to ``False``, the glyph's
        components will not be drawn.

            >>> glyph.draw(pen, components=False)
        """
        ...
    
    def drawPoints(self, pen, contours=..., components=...): # -> None:
        """
        Draw the glyph's outline data (contours and components) to
        the given :ref:`type-pointpen`.

            >>> glyph.drawPoints(pointPen)

        If ``contours`` is set to ``False``, the glyph's
        contours will not be drawn.

            >>> glyph.drawPoints(pointPen, contours=False)

        If ``components`` is set to ``False``, the glyph's
        components will not be drawn.

            >>> glyph.drawPoints(pointPen, components=False)
        """
        ...
    
    def clear(self, contours=..., components=..., anchors=..., guidelines=..., image=...): # -> None:
        """
        Clear the glyph.

            >>> glyph.clear()

        This clears:

        - contours
        - components
        - anchors
        - guidelines
        - image

        It's possible to turn off the clearing of portions of
        the glyph with the listed arguments.

            >>> glyph.clear(guidelines=False)
        """
        ...
    
    def appendGlyph(self, other, offset=...): # -> None:
        """
        Append the data from ``other`` to new objects in this glyph.

            >>> glyph.appendGlyph(otherGlyph)

        This will append:

        - contours
        - components
        - anchors
        - guidelines

        ``offset`` indicates the x and y shift values that should
        be applied to the appended data. It must be a :ref:`type-coordinate`
        value or ``None``. If ``None`` is given, the offset will be ``(0, 0)``.

            >>> glyph.appendGlyph(otherGlyph, (100, 0))
        """
        ...
    
    contours = ...
    def __len__(self): # -> None:
        """
        The number of contours in the glyph.

            >>> len(glyph)
            2
        """
        ...
    
    def __iter__(self): # -> Generator[None, Any, None]:
        """
        Iterate through all contours in the glyph.

            >>> for contour in glyph:
            ...     contour.reverse()
        """
        ...
    
    def __getitem__(self, index): # -> None:
        """
        Get the contour located at ``index`` from the glyph.

            >>> contour = glyph[0]

        The returned value will be a :class:`BaseContour` object.
        """
        ...
    
    def appendContour(self, contour, offset=...): # -> None:
        """
        Append a contour containing the same data as ``contour``
        to this glyph.

            >>> contour = glyph.appendContour(contour)

        This will return a :class:`BaseContour` object representing
        the new contour in the glyph. ``offset`` indicates the x and
        y shift values that should be applied to the appended data.
        It must be a :ref:`type-coordinate` value or ``None``. If
        ``None`` is given, the offset will be ``(0, 0)``.

            >>> contour = glyph.appendContour(contour, (100, 0))
        """
        ...
    
    def removeContour(self, contour): # -> None:
        """
        Remove ``contour`` from the glyph.

            >>> glyph.removeContour(contour)

        ``contour`` may be a :ref:`BaseContour` or an :ref:`type-int`
        representing a contour index.
        """
        ...
    
    def clearContours(self): # -> None:
        """
        Clear all contours in the glyph.

            >>> glyph.clearContours()
        """
        ...
    
    def removeOverlap(self): # -> None:
        """
        Perform a remove overlap operation on the contours.

            >>> glyph.removeOverlap()

        The behavior of this may vary across environments.
        """
        ...
    
    components = ...
    def appendComponent(self, baseGlyph=..., offset=..., scale=..., component=...): # -> Any:
        """
        Append a component to this glyph.

            >>> component = glyph.appendComponent("A")

        This will return a :class:`BaseComponent` object representing
        the new component in the glyph. ``offset`` indicates the x and
        y shift values that should be applied to the appended component.
        It must be a :ref:`type-coordinate` value or ``None``. If
        ``None`` is given, the offset will be ``(0, 0)``.

            >>> component = glyph.appendComponent("A", offset=(10, 20))

        ``scale`` indicates the x and y scale values that should be
        applied to the appended component. It must be a
        :ref:`type-scale` value or ``None``. If ``None`` is given,
        the scale will be ``(1.0, 1.0)``.

            >>> component = glyph.appendComponent("A", scale=(1.0, 2.0))

        ``component`` may be a :class:`BaseComponent` object from which
        attribute values will be copied. If ``baseGlyph``, ``offset``
        or ``scale`` are specified as arguments, those values will be used
        instead of the values in the given component object.
        """
        ...
    
    def removeComponent(self, component): # -> None:
        """
        Remove ``component`` from the glyph.

            >>> glyph.removeComponent(component)

        ``component`` may be a :ref:`BaseComponent` or an
        :ref:`type-int` representing a component index.
        """
        ...
    
    def clearComponents(self): # -> None:
        """
        Clear all components in the glyph.

            >>> glyph.clearComponents()
        """
        ...
    
    def decompose(self): # -> None:
        """
        Decompose all components in the glyph to contours.

            >>> glyph.decompose()
        """
        ...
    
    anchors = ...
    def appendAnchor(self, name=..., position=..., color=..., anchor=...): # -> None:
        """
        Append an anchor to this glyph.

            >>> anchor = glyph.appendAnchor("top", (10, 20))

        This will return a :class:`BaseAnchor` object representing
        the new anchor in the glyph. ``name`` indicated the name to
        be assigned to the anchor. It must be a :ref:`type-string`
        or ``None``. ``position`` indicates the x and y location
        to be applied to the anchor. It must be a
        :ref:`type-coordinate` value. ``color`` indicates the color
        to be applied to the anchor. It must be a :ref:`type-color`
        or ``None``.

            >>> anchor = glyph.appendAnchor("top", (10, 20), color=(1, 0, 0, 1))

        ``anchor`` may be a :class:`BaseAnchor` object from which
        attribute values will be copied. If ``name``, ``position``
        or ``color`` are specified as arguments, those values will
        be used instead of the values in the given anchor object.
        """
        ...
    
    def removeAnchor(self, anchor): # -> None:
        """
        Remove ``anchor`` from the glyph.

            >>> glyph.removeAnchor(anchor)

        ``anchor`` may be an :ref:`BaseAnchor` or an
        :ref:`type-int` representing an anchor index.
        """
        ...
    
    def clearAnchors(self): # -> None:
        """
        Clear all anchors in the glyph.

            >>> glyph.clearAnchors()
        """
        ...
    
    guidelines = ...
    def appendGuideline(self, position=..., angle=..., name=..., color=..., guideline=...): # -> None:
        """
        Append a guideline to this glyph.

            >>> guideline = glyph.appendGuideline((100, 0), 90)

        This will return a :class:`BaseGuideline` object representing
        the new guideline in the glyph. ``position`` indicates the
        x and y location to be used as the center point of the anchor.
        It must be a :ref:`type-coordinate` value. ``angle`` indicates
        the angle of the guideline, in degrees. This must be a
        :ref:`type-int-float` between 0 and 360. ``name`` indicates
        an name to be assigned to the guideline. It must be a
        :ref:`type-string` or ``None``.

            >>> guideline = glyph.appendGuideline((100, 0), 90, name="left")

        ``color`` indicates the color to be applied to the guideline.
        It must be a :ref:`type-color` or ``None``.

            >>> guideline = glyph.appendGuideline((100, 0), 90, color=(1, 0, 0, 1))

        ``guideline`` may be a :class:`BaseGuideline` object from which
        attribute values will be copied. If ``position``, ``angle``, ``name``
        or ``color`` are specified as arguments, those values will be used
        instead of the values in the given guideline object.
        """
        ...
    
    def removeGuideline(self, guideline): # -> None:
        """
        Remove ``guideline`` from the glyph.

            >>> glyph.removeGuideline(guideline)

        ``guideline`` may be a :ref:`BaseGuideline` or an
        :ref:`type-int` representing an guideline index.
        """
        ...
    
    def clearGuidelines(self): # -> None:
        """
        Clear all guidelines in the glyph.

            >>> glyph.clearGuidelines()
        """
        ...
    
    def round(self): # -> None:
        """
        Round coordinates to the nearest integer.

            >>> glyph.round()

        This applies to the following:

        - width
        - height
        - contours
        - components
        - anchors
        - guidelines
        - image
        """
        ...
    
    def correctDirection(self, trueType=...): # -> None:
        """
        Correct the winding direction of the contours following
        the PostScript recommendations.

            >>> glyph.correctDirection()

        If ``trueType`` is ``True`` the TrueType recommendations
        will be followed.
        """
        ...
    
    def autoContourOrder(self): # -> None:
        """
        Automatically order the contours based on heuristics.

            >>> glyph.autoContourOrder()

        The results of this may vary across environments.
        """
        ...
    
    def scaleBy(self, value, origin=..., width=..., height=...): # -> None:
        """
        %s
        **width** indicates if the glyph's width should be scaled.
        **height** indicates if the glyph's height should be scaled.

        The origin must not be specified when scaling the width or height.
        """
        ...
    
    def toMathGlyph(self, scaleComponentTransform=..., strict=...):
        """
        Returns the glyph as an object that follows the
        `MathGlyph protocol <https://github.com/typesupply/fontMath>`_.

            >>> mg = glyph.toMathGlyph()

        **scaleComponentTransform** Enables the MathGlyph
          `scaleComponentTransform` option.
        **strict**  Enables the MathGlyph `strict` option.
        """
        ...
    
    def fromMathGlyph(self, mathGlyph, filterRedundantPoints=...): # -> Self:
        """
        Replaces the contents of this glyph with the contents of ``mathGlyph``.

            >>> glyph.fromMathGlyph(mg)

        ``mathGlyph`` must be an object following the
        `MathGlyph protocol <https://github.com/typesupply/fontMath>`_.

        **filterRedundantPoints** enables the MathGlyph `drawPoints`
          `filterRedundantPoints` option.
        """
        ...
    
    def __mul__(self, factor): # -> Self:
        """
        Subclasses may override this method.
        """
        ...
    
    __rmul__ = ...
    def __truediv__(self, factor): # -> Self:
        """
        Subclasses may override this method.
        """
        ...
    
    __div__ = ...
    def __add__(self, other): # -> Self:
        """
        Subclasses may override this method.
        """
        ...
    
    def __sub__(self, other): # -> Self:
        """
        Subclasses may override this method.
        """
        ...
    
    def interpolate(self, factor, minGlyph, maxGlyph, round=..., suppressError=...): # -> None:
        """
        Interpolate the contents of this glyph at location ``factor``
        in a linear interpolation between ``minGlyph`` and ``maxGlyph``.

            >>> glyph.interpolate(0.5, otherGlyph1, otherGlyph2)

        ``factor`` may be a :ref:`type-int-float` or a tuple containing
        two :ref:`type-int-float` values representing x and y factors.

            >>> glyph.interpolate((0.5, 1.0), otherGlyph1, otherGlyph2)

        ``minGlyph`` must be a :class:`BaseGlyph` and will be located at 0.0
        in the interpolation range. ``maxGlyph`` must be a :class:`BaseGlyph`
        and will be located at 1.0 in the interpolation range. If ``round``
        is ``True``, the contents of the glyph will be rounded to integers
        after the interpolation is performed.

            >>> glyph.interpolate(0.5, otherGlyph1, otherGlyph2, round=True)

        This method assumes that ``minGlyph`` and ``maxGlyph`` are completely
        compatible with each other for interpolation. If not, any errors
        encountered will raise a :class:`FontPartsError`. If ``suppressError``
        is ``True``, no exception will be raised and errors will be silently
        ignored.
        """
        ...
    
    compatibilityReporterClass = GlyphCompatibilityReporter
    def isCompatible(self, other): # -> tuple[bool, Any]:
        """
        Evaluate the interpolation compatibility of this glyph
        and ``other``.

            >>> compatible, report = self.isCompatible(otherGlyph)
            >>> compatible
            False

        This will return a :ref:`type-bool` indicating if this glyph is
        compatible with ``other`` and a :class:`GlyphCompatibilityReporter`
        containing a detailed report about compatibility errors.
        """
        ...
    
    def pointInside(self, point):
        """
        Determine if ``point`` is in the black or white of the glyph.

            >>> glyph.pointInside((40, 65))
            True

        ``point`` must be a :ref:`type-coordinate`.
        """
        ...
    
    bounds = ...
    area = ...
    layers = ...
    def getLayer(self, name):
        """
        Get the :ref:`type-glyph-layer` with ``name`` in this glyph.

            >>> glyphLayer = glyph.getLayer("foreground")
        """
        ...
    
    def newLayer(self, name): # -> None:
        """
        Make a new layer with ``name`` in this glyph.

            >>> glyphLayer = glyph.newLayer("background")

        This will return the new :ref:`type-glyph-layer`.
        If the layer already exists in this glyph, it
        will be cleared.
        """
        ...
    
    def removeLayer(self, layer): # -> None:
        """
        Remove ``layer`` from this glyph.

            >>> glyph.removeLayer("background")

        Layer can be a :ref:`type-glyph-layer` or a :ref:`type-string`
        representing a layer name.
        """
        ...
    
    image = ...
    def addImage(self, path=..., data=..., scale=..., position=..., color=...): # -> Any | dynamicProperty:
        """
        Set the image in the glyph. This will return the
        assigned :class:`BaseImage`. The image data can be
        defined via ``path`` to an image file:

            >>> image = glyph.addImage(path="/path/to/my/image.png")

        The image data can be defined with raw image data
        via ``data``.

            >>> image = glyph.addImage(data=someImageData)

        If ``path`` and ``data`` are both provided, a
        :class:`FontPartsError` will be raised. The supported
        image formats will vary across environments. Refer
        to :class:`BaseImage` for complete details.

        ``scale`` indicates the x and y scale values that should be
        applied to the image. It must be a :ref:`type-scale` value
        or ``None``.

            >>> image = glyph.addImage(path="/p/t/image.png", scale=(0.5, 1.0))

        ``position`` indicates the x and y location of the lower left
        point of the image.

            >>> image = glyph.addImage(path="/p/t/image.png", position=(10, 20))

        ``color`` indicates the color to be applied to the image. It must
        be a :ref:`type-color` or ``None``.

            >>> image = glyph.addImage(path="/p/t/image.png", color=(1, 0, 0, 0.5))
        """
        ...
    
    def clearImage(self): # -> None:
        """
        Remove the image from the glyph.

            >>> glyph.clearImage()
        """
        ...
    
    markColor = ...
    note = ...
    lib = ...
    tempLib = ...
    def isEmpty(self): # -> bool:
        """
        This will return :ref:`type-bool` indicating if there are contours and/or
        components in the glyph.

            >>> glyph.isEmpty()

        Note: This method only checks for the presence of contours and components.
        Other attributes (guidelines, anchors, a lib, etc.) will not affect what
        this method returns.
        """
        ...
    
    def loadFromGLIF(self, glifData): # -> None:
        """
        Reads ``glifData``, in
        `GLIF format <http://unifiedfontobject.org/versions/ufo3/glyphs/glif/>`_,
        into this glyph.

            >>> glyph.readGlyphFromString(xmlData)
        """
        ...
    
    def dumpToGLIF(self, glyphFormatVersion=...): # -> None:
        """
        This will return the glyph's contents as a string in
        `GLIF format <http://unifiedfontobject.org/versions/ufo3/glyphs/glif/>`_.

            >>> xml = glyph.writeGlyphToString()

        ``glyphFormatVersion`` must be a :ref:`type-int` that defines
        the preferred GLIF format version.
        """
        ...
    
    selectedContours = ...
    selectedComponents = ...
    selectedAnchors = ...
    selectedGuidelines = ...


