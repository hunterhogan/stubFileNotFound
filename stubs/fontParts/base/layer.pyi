"""
This type stub file was generated by pyright.
"""

from fontParts.base.base import BaseObject, InterpolationMixin, SelectionMixin
from fontParts.base.compatibility import LayerCompatibilityReporter
from fontParts.base.deprecated import DeprecatedLayer, RemovedLayer

class _BaseGlyphVendor(BaseObject, SelectionMixin):
    """
    This class exists to provide common glyph
    interaction code to BaseFont and BaseLayer.
    It should not be directly subclassed.
    """
    def __len__(self): # -> int:
        """
        An ``int`` representing number of glyphs in the layer. ::

            >>> len(layer)
            256
        """
        ...
    
    def __iter__(self): # -> Generator[None, Any, None]:
        """
        Iterate through the :class:`BaseGlyph` objects in the layer. ::

            >>> for glyph in layer:
            ...     glyph.name
            "A"
            "B"
            "C"
        """
        ...
    
    def __getitem__(self, name): # -> None:
        """
        Get the :class:`BaseGlyph` with name from the layer. ::

            >>> glyph = layer["A"]
        """
        ...
    
    def __setitem__(self, name, glyph): # -> None:
        """
        Insert **glyph** into the layer. ::

            >>> glyph = layer["A"] = otherGlyph

        This will not insert the glyph directly. Rather, a
        new glyph will be created and the data from **glyph**
        will be copied to the new glyph. **name** indicates
        the name that should be assigned to the glyph after
        insertion. If **name** is not given, the glyph's original
        name must be used. If the glyph does not have a name,
        an error must be raised. The data that will be inserted
        from **glyph** is the same data as documented in
        :meth:`BaseGlyph.copy`.
        """
        ...
    
    def __delitem__(self, name): # -> None:
        """
        Remove the glyph with name from the layer. ::

            >>> del layer["A"]
        """
        ...
    
    def keys(self): # -> None:
        """
        Get a list of all glyphs in the layer. ::

            >>> layer.keys()
            ["B", "C", "A"]

        The order of the glyphs is undefined.
        """
        ...
    
    def __contains__(self, name): # -> bool:
        """
        Test if the layer contains a glyph with **name**. ::

            >>> "A" in layer
            True
        """
        ...
    
    def newGlyph(self, name, clear=...): # -> None:
        """
        Make a new glyph with **name** in the layer. ::

            >>> glyph = layer.newGlyph("A")

        The newly created :class:`BaseGlyph` will be returned.

        If the glyph exists in the layer and clear is set to ``False``,
        the existing glyph will be returned, otherwise the default
        behavior is to clear the exisiting glyph.
        """
        ...
    
    def removeGlyph(self, name): # -> None:
        """
        Remove the glyph with name from the layer. ::

            >>> layer.removeGlyph("A")

        This method is deprecated. :meth:`BaseFont.__delitem__` instead.
        """
        ...
    
    def insertGlyph(self, glyph, name=...):
        """
        Insert **glyph** into the layer. ::

            >>> glyph = layer.insertGlyph(otherGlyph, name="A")

        This will return the inserted **glyph**.
        This method is deprecated. :meth:`BaseFont.__setitem__` instead.
        """
        ...
    
    selectedGlyphs = ...
    selectedGlyphNames = ...
    has_key = ...


class BaseLayer(_BaseGlyphVendor, InterpolationMixin, DeprecatedLayer, RemovedLayer):
    copyAttributes = ...
    def copy(self): # -> Self:
        """
        Copy the layer into a new layer that does not
        belong to a font. ::

            >>> copiedLayer = layer.copy()

        This will copy:

        * name
        * color
        * lib
        * glyphs
        """
        ...
    
    def copyData(self, source): # -> None:
        """
        Copy data from **source** into this layer.
        Refer to :meth:`BaseLayer.copy` for a list
        of values that will be copied.
        """
        ...
    
    _font = ...
    font = ...
    name = ...
    color = ...
    lib = ...
    tempLib = ...
    def round(self): # -> None:
        """
        Round all approriate data to integers. ::

            >>> layer.round()

        This is the equivalent of calling the round method on:

        * all glyphs in the layer
        """
        ...
    
    def autoUnicodes(self): # -> None:
        """
        Use heuristics to set Unicode values in all glyphs. ::

            >>> layer.autoUnicodes()

        Environments will define their own heuristics for
        automatically determining values.
        """
        ...
    
    def interpolate(self, factor, minLayer, maxLayer, round=..., suppressError=...): # -> None:
        """
        Interpolate all possible data in the layer. ::

            >>> layer.interpolate(0.5, otherLayer1, otherLayer2)
            >>> layer.interpolate((0.5, 2.0), otherLayer1, otherLayer2, round=False)

        The interpolation occurs on a 0 to 1.0 range where **minLayer**
        is located at 0 and **maxLayer** is located at 1.0. **factor**
        is the interpolation value. It may be less than 0 and greater
        than 1.0. It may be a :ref:`type-int-float` or a tuple of
        two :ref:`type-int-float`. If it is a tuple, the first
        number indicates the x factor and the second number indicates
        the y factor. **round** indicates if the result should be
        rounded to integers. **suppressError** indicates if incompatible
        data should be ignored or if an error should be raised when
        such incompatibilities are found.
        """
        ...
    
    compatibilityReporterClass = LayerCompatibilityReporter
    def isCompatible(self, other): # -> tuple[bool, Any]:
        """
        Evaluate interpolation compatibility with **other**. ::

            >>> compat, report = self.isCompatible(otherLayer)
            >>> compat
            False
            >>> report
            A
            -
            [Fatal] The glyphs do not contain the same number of contours.

        This will return a ``bool`` indicating if the layer is
        compatible for interpolation with **other** and a
        :ref:`type-string` of compatibility notes.
        """
        ...
    
    def getReverseComponentMapping(self): # -> None:
        """
        Create a dictionary of unicode -> [glyphname, ...] mappings.
        All glyphs are loaded. Note that one glyph can have multiple
        unicode values, and a unicode value can have multiple glyphs
        pointing to it.
        """
        ...
    
    def getCharacterMapping(self): # -> None:
        """
        Get a reversed map of component references in the font.
        {
        'A' : ['Aacute', 'Aring']
        'acute' : ['Aacute']
        'ring' : ['Aring']
        etc.
        }
        """
        ...
    


