"""
This type stub file was generated by pyright.
"""

class dynamicProperty:
    """
    This implements functionality that is very similar
    to Python's built in property function, but makes
    it much easier for subclassing. Here is an example
    of why this is needed:

        class BaseObject(object):

            _foo = 1

            def _get_foo(self):
                return self._foo

            def _set_foo(self, value):
                self._foo = value

            foo = property(_get_foo, _set_foo)


        class MyObject(BaseObject):

            def _set_foo(self, value):
                self._foo = value * 100


        >>> m = MyObject()
        >>> m.foo
        1
        >>> m.foo = 2
        >>> m.foo
        2

    The expected value is 200. The _set_foo method
    needs to be reregistered. Doing that also requires
    reregistering the _get_foo method. It's possible
    to do this, but it's messy and will make subclassing
    less than ideal.

    Using dynamicProperty solves this.

        class BaseObject(object):

            _foo = 1

            foo = dynamicProperty("foo")

            def _get_foo(self):
                return self._foo

            def _set_foo(self, value):
                self._foo = value


        class MyObject(BaseObject):

            def _set_foo(self, value):
                self._foo = value * 100


        >>> m = MyObject()
        >>> m.foo
        1
        >>> m.foo = 2
        >>> m.foo
        200
    """
    def __init__(self, name, doc=...) -> None:
        ...
    
    def __get__(self, obj, cls): # -> Any | Self:
        ...
    
    def __set__(self, obj, value): # -> None:
        ...
    


def interpolate(a, b, v):
    ...

class BaseObject:
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __eq__(self, other) -> bool:
        """
        Subclasses may override this method.
        """
        ...
    
    def __ne__(self, other) -> bool:
        """
        Subclasses must not override this method.
        """
        ...
    
    def __hash__(self) -> int:
        """
        Allow subclasses to be used in hashable collections.

        Subclasses may override this method.
        """
        ...
    
    copyClass = ...
    copyAttributes = ...
    def copy(self): # -> Self:
        """
        Copy this object into a new object of the same type.
        The returned object will not have a parent object.
        """
        ...
    
    def copyData(self, source): # -> None:
        """
        Subclasses may override this method.
        If so, they should call the super.
        """
        ...
    
    def raiseNotImplementedError(self):
        """
        This exception needs to be raised frequently by
        the base classes. So, it's here for convenience.
        """
        ...
    
    def changed(self, *args, **kwargs): # -> None:
        """
        Tell the environment that something has changed in
        the object. The behavior of this method will vary
        from environment to environment.

            >>> obj.changed()
        """
        ...
    
    def naked(self): # -> None:
        """
        Return the environment's native object
        that has been wrapped by this object.

            >>> loweLevelObj = obj.naked()
        """
        ...
    


class BaseDict(BaseObject):
    keyNormalizer = ...
    valueNormalizer = ...
    def copyData(self, source): # -> None:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def keys(self): # -> list[Any]:
        ...
    
    def items(self): # -> list[tuple[Any, Any]]:
        ...
    
    def values(self): # -> list[Any]:
        ...
    
    def __contains__(self, key): # -> None:
        ...
    
    has_key = ...
    def __setitem__(self, key, value): # -> None:
        ...
    
    def __getitem__(self, key): # -> None:
        ...
    
    def get(self, key, default=...): # -> None:
        ...
    
    def __delitem__(self, key): # -> None:
        ...
    
    def pop(self, key, default=...): # -> None:
        ...
    
    def __iter__(self): # -> Generator[Any, Any, None]:
        ...
    
    def update(self, other): # -> None:
        ...
    
    def clear(self): # -> None:
        ...
    


class TransformationMixin:
    def transformBy(self, matrix, origin=...): # -> None:
        """
        Transform the object.

            >>> obj.transformBy((0.5, 0, 0, 2.0, 10, 0))
            >>> obj.transformBy((0.5, 0, 0, 2.0, 10, 0), origin=(500, 500))

        **matrix** must be a :ref:`type-transformation`.
        **origin** defines the point at with the transformation
        should originate. It must be a :ref:`type-coordinate`
        or ``None``. The default is ``(0, 0)``.
        """
        ...
    
    def moveBy(self, value): # -> None:
        """
        Move the object.

            >>> obj.moveBy((10, 0))

        **value** must be an iterable containing two
        :ref:`type-int-float` values defining the x and y
        values to move the object by.
        """
        ...
    
    def scaleBy(self, value, origin=...): # -> None:
        """
        Scale the object.

            >>> obj.scaleBy(2.0)
            >>> obj.scaleBy((0.5, 2.0), origin=(500, 500))

        **value** must be an iterable containing two
        :ref:`type-int-float` values defining the x and y
        values to scale the object by. **origin** defines the
        point at with the scale should originate. It must be
        a :ref:`type-coordinate` or ``None``. The default is
        ``(0, 0)``.
        """
        ...
    
    def rotateBy(self, value, origin=...): # -> None:
        """
        Rotate the object.

            >>> obj.rotateBy(45)
            >>> obj.rotateBy(45, origin=(500, 500))

        **value** must be a :ref:`type-int-float` values
        defining the angle to rotate the object by. **origin**
        defines the point at with the rotation should originate.
        It must be a :ref:`type-coordinate` or ``None``.
        The default is ``(0, 0)``.
        """
        ...
    
    def skewBy(self, value, origin=...): # -> None:
        """
        Skew the object.

            >>> obj.skewBy(11)
            >>> obj.skewBy((25, 10), origin=(500, 500))

        **value** must be rone of the following:

        * single :ref:`type-int-float` indicating the
          value to skew the x direction by.
        * iterable cointaining type :ref:`type-int-float`
          defining the values to skew the x and y directions by.

        **origin** defines the point at with the skew should
        originate. It must be a :ref:`type-coordinate` or
        ``None``. The default is ``(0, 0)``.
        """
        ...
    


class InterpolationMixin:
    compatibilityReporterClass = ...
    def isCompatible(self, other, cls): # -> tuple[bool, Any]:
        """
        Evaluate interpolation compatibility with other.
        """
        ...
    


class SelectionMixin:
    selected = ...


class PointPositionMixin:
    """
    This adds a ``position`` attribute as a dyanmicProperty,
    for use as a mixin with objects that have ``x`` and ``y``
    attributes.
    """
    position = ...


class IdentifierMixin:
    identifier = ...
    def getIdentifier(self): # -> None:
        """
        Create a new, unique identifier for and assign it to the object.
        If the object already has an identifier, the existing one should
        be returned.
        """
        ...
    


def reference(obj): # -> Callable[[], Any]:
    """
    This code returns a simple function that returns the given object.
    This is a backwards compatibility function that is under review.
    See #749. We used to use weak references, but they proved
    problematic (see issue #71), so this function was put in place to
    make sure existing code continued to function. The need for it is
    questionable, so it may be deleted soon.
    """
    ...

class FuzzyNumber:
    """
    A number like object with a threshold.
    Use it to compare numbers where a threshold is needed.
    """
    def __init__(self, value, threshold) -> None:
        ...
    
    def __repr__(self): # -> LiteralString:
        ...
    
    def __lt__(self, other) -> bool:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    


