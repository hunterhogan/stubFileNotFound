"""
This type stub file was generated by pyright.
"""

import sys
from itertools import chain

__all__ = ['count', 'cycle', 'repeat', 'repeatedly', 'iterate', 'take', 'drop', 'first', 'second', 'nth', 'last', 'rest', 'butlast', 'ilen', 'map', 'filter', 'lmap', 'lfilter', 'remove', 'lremove', 'keep', 'lkeep', 'without', 'lwithout', 'concat', 'lconcat', 'chain', 'cat', 'lcat', 'flatten', 'lflatten', 'mapcat', 'lmapcat', 'interleave', 'interpose', 'distinct', 'ldistinct', 'dropwhile', 'takewhile', 'split', 'lsplit', 'split_at', 'lsplit_at', 'split_by', 'lsplit_by', 'group_by', 'group_by_keys', 'group_values', 'count_by', 'count_reps', 'partition', 'lpartition', 'chunks', 'lchunks', 'partition_by', 'lpartition_by', 'with_prev', 'with_next', 'pairwise', 'lzip', 'reductions', 'lreductions', 'sums', 'lsums', 'accumulate']
def repeatedly(f, n=...): # -> Generator[Any, None, None]:
    """Takes a function of no args, presumably with side effects,
       and returns an infinite (or length n) iterator of calls to it."""
    ...

def iterate(f, x): # -> Generator[Any, Any, NoReturn]:
    """Returns an infinite iterator of `x, f(x), f(f(x)), ...`"""
    ...

def take(n, seq): # -> list[Any]:
    """Returns a list of first n items in the sequence,
       or all items if there are fewer than n."""
    ...

def drop(n, seq): # -> islice[Any]:
    """Skips first n items in the sequence, yields the rest."""
    ...

def first(seq): # -> None:
    """Returns the first item in the sequence.
       Returns None if the sequence is empty."""
    ...

def second(seq): # -> None:
    """Returns second item in the sequence.
       Returns None if there are less than two items in it."""
    ...

def nth(n, seq): # -> None:
    """Returns nth item in the sequence or None if no such item exists."""
    ...

def last(seq): # -> None:
    """Returns the last item in the sequence or iterator.
       Returns None if the sequence is empty."""
    ...

def rest(seq): # -> islice[Any]:
    """Skips first item in the sequence, yields the rest."""
    ...

def butlast(seq): # -> Generator[Any, Any, None]:
    """Iterates over all elements of the sequence but last."""
    ...

def ilen(seq): # -> int:
    """Consumes an iterable not reading it into memory
       and returns the number of items."""
    ...

def lmap(f, *seqs): # -> list[Any]:
    """An extended version of builtin map() returning a list.
       Derives a mapper from string, int, slice, dict or set."""
    ...

def lfilter(pred, seq): # -> list[Any]:
    """An extended version of builtin filter() returning a list.
       Derives a predicate from string, int, slice, dict or set."""
    ...

def map(f, *seqs): # -> map[Any]:
    """An extended version of builtin map().
       Derives a mapper from string, int, slice, dict or set."""
    ...

def filter(pred, seq): # -> filter[Any]:
    """An extended version of builtin filter().
       Derives a predicate from string, int, slice, dict or set."""
    ...

def lremove(pred, seq): # -> list[Any]:
    """Creates a list if items passing given predicate."""
    ...

def remove(pred, seq): # -> filterfalse[Any]:
    """Iterates items passing given predicate."""
    ...

def lkeep(f, seq=...): # -> list[Any]:
    """Maps seq with f and keeps only truthy results.
       Simply lists truthy values in one argument version."""
    ...

def keep(f, seq=...): # -> filter[Any]:
    """Maps seq with f and iterates truthy results.
       Simply iterates truthy values in one argument version."""
    ...

def without(seq, *items): # -> Generator[Any, Any, None]:
    """Iterates over sequence skipping items."""
    ...

def lwithout(seq, *items): # -> list[Any]:
    """Removes items from sequence, preserves order."""
    ...

def lconcat(*seqs): # -> list[Any]:
    """Concatenates several sequences."""
    ...

concat = chain
def lcat(seqs): # -> list[Any]:
    """Concatenates the sequence of sequences."""
    ...

cat = ...
def flatten(seq, follow=...): # -> Generator[Any, Any, None]:
    """Flattens arbitrary nested sequence.
       Unpacks an item if follow(item) is truthy."""
    ...

def lflatten(seq, follow=...): # -> list[Any]:
    """Iterates over arbitrary nested sequence.
       Dives into when follow(item) is truthy."""
    ...

def lmapcat(f, *seqs): # -> list[Any]:
    """Maps given sequence(s) and concatenates the results."""
    ...

def mapcat(f, *seqs): # -> chain[Any]:
    """Maps given sequence(s) and chains the results."""
    ...

def interleave(*seqs): # -> chain[Any]:
    """Yields first item of each sequence, then second one and so on."""
    ...

def interpose(sep, seq): # -> islice[Any]:
    """Yields items of the sequence alternating with sep."""
    ...

def takewhile(pred, seq=...): # -> takewhile[Any]:
    """Yields sequence items until first predicate fail.
       Stops on first falsy value in one argument version."""
    ...

def dropwhile(pred, seq=...): # -> dropwhile[Any]:
    """Skips the start of the sequence passing pred (or just truthy),
       then iterates over the rest."""
    ...

def ldistinct(seq, key=...): # -> list[Any]:
    """Removes duplicates from sequences, preserves order."""
    ...

def distinct(seq, key=...): # -> Generator[Any, Any, None]:
    """Iterates over sequence skipping duplicates"""
    ...

def split(pred, seq): # -> tuple[Generator[Any, Any, None], Generator[Any, Any, None]]:
    """Lazily splits items which pass the predicate from the ones that don't.
       Returns a pair (passed, failed) of respective iterators."""
    ...

def lsplit(pred, seq): # -> tuple[list[Any], list[Any]]:
    """Splits items which pass the predicate from the ones that don't.
       Returns a pair (passed, failed) of respective lists."""
    ...

def split_at(n, seq): # -> tuple[islice[Any], islice[Any]]:
    """Lazily splits the sequence at given position,
       returning a pair of iterators over its start and tail."""
    ...

def lsplit_at(n, seq): # -> tuple[list[Any], list[Any]]:
    """Splits the sequence at given position,
       returning a tuple of its start and tail."""
    ...

def split_by(pred, seq): # -> tuple[takewhile[Any], dropwhile[Any]]:
    """Lazily splits the start of the sequence,
       consisting of items passing pred, from the rest of it."""
    ...

def lsplit_by(pred, seq): # -> tuple[list[Any], list[Any]]:
    """Splits the start of the sequence,
       consisting of items passing pred, from the rest of it."""
    ...

def group_by(f, seq): # -> defaultdict[Any, list[Any]]:
    """Groups given sequence items into a mapping f(item) -> [item, ...]."""
    ...

def group_by_keys(get_keys, seq): # -> defaultdict[Any, list[Any]]:
    """Groups items having multiple keys into a mapping key -> [item, ...].
       Item might be repeated under several keys."""
    ...

def group_values(seq): # -> defaultdict[Any, list[Any]]:
    """Takes a sequence of (key, value) pairs and groups values by keys."""
    ...

def count_by(f, seq): # -> defaultdict[Any, int]:
    """Counts numbers of occurrences of values of f()
       on elements of given sequence."""
    ...

def count_reps(seq): # -> defaultdict[Any, int]:
    """Counts number occurrences of each value in the sequence."""
    ...

def partition(n, step, seq=...): # -> Generator[Sequence[Any], None, None] | Generator[list[Any], Any, None]:
    """Lazily partitions seq into parts of length n.
       Skips step items between parts if passed. Non-fitting tail is ignored."""
    ...

def lpartition(n, step, seq=...): # -> list[Sequence[Any]]:
    """Partitions seq into parts of length n.
       Skips step items between parts if passed. Non-fitting tail is ignored."""
    ...

def chunks(n, step, seq=...): # -> Generator[Sequence[Any], None, None] | Generator[list[Any], Any, None]:
    """Lazily chunks seq into parts of length n or less.
       Skips step items between parts if passed."""
    ...

def lchunks(n, step, seq=...): # -> list[Sequence[Any]]:
    """Chunks seq into parts of length n or less.
       Skips step items between parts if passed."""
    ...

def partition_by(f, seq): # -> Generator[Iterator[Any], Any, None]:
    """Lazily partition seq into continuous chunks with constant value of f."""
    ...

def lpartition_by(f, seq): # -> list[Any]:
    """Partition seq into continuous chunks with constant value of f."""
    ...

def with_prev(seq, fill=...): # -> zip[tuple[Any, Any | None]]:
    """Yields each item paired with its preceding: (item, prev)."""
    ...

def with_next(seq, fill=...): # -> zip[tuple[Any, Any | None]]:
    """Yields each item paired with its following: (item, next)."""
    ...

def pairwise(seq): # -> zip[tuple[Any, Any]]:
    """Yields all pairs of neighboring items in seq."""
    ...

if sys.version_info >= (3, 10):
    def lzip(*seqs, strict=...): # -> list[tuple[Any, ...]]:
        """List zip() version."""
        ...
    
else:
    ...
def reductions(f, seq, acc=...): # -> accumulate[Any] | Generator[Any, Any, None]:
    """Yields intermediate reductions of seq by f."""
    ...

def lreductions(f, seq, acc=...): # -> list[Any]:
    """Lists intermediate reductions of seq by f."""
    ...

def sums(seq, acc=...): # -> accumulate[Any] | Generator[Any, Any, None]:
    """Yields partial sums of seq."""
    ...

def lsums(seq, acc=...): # -> list[Any]:
    """Lists partial sums of seq."""
    ...

