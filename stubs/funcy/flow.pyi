"""
This type stub file was generated by pyright.
"""

from .decorators import contextmanager, decorator

__all__ = ['raiser', 'ignore', 'silent', 'suppress', 'nullcontext', 'reraise', 'retry', 'fallback', 'limit_error_rate', 'ErrorRateExceeded', 'throttle', 'post_processing', 'collecting', 'joining', 'once', 'once_per', 'once_per_args', 'wrap_with']
def raiser(exception_or_class=..., *args, **kwargs): # -> Callable[..., NoReturn]:
    """Constructs function that raises the given exception
       with given arguments on any invocation."""
    ...

def ignore(errors, default=...): # -> Callable[..., Callable[..., Any | None]]:
    """Alters function to ignore given errors, returning default instead."""
    ...

def silent(func): # -> Callable[..., Any | None]:
    """Alters function to ignore all exceptions."""
    ...

@contextmanager
def reraise(errors, into): # -> Generator[None, Any, None]:
    """Reraises errors as other exception."""
    ...

@decorator
def retry(call, tries, errors=..., timeout=..., filter_errors=...): # -> None:
    """Makes decorated function retry up to tries times.
       Retries only on specified errors.
       Sleeps timeout or timeout(attempt) seconds between tries."""
    ...

def fallback(*approaches): # -> object | None:
    """Tries several approaches until one works.
       Each approach has a form of (callable, expected_errors)."""
    ...

class ErrorRateExceeded(Exception):
    ...


def limit_error_rate(fails, timeout, exception=...): # -> Callable[..., Callable[..., Any]]:
    """If function fails to complete fails times in a row,
       calls to it will be intercepted for timeout with exception raised instead."""
    ...

def throttle(period): # -> Callable[..., Callable[..., Any | None]]:
    """Allows only one run in a period, the rest is skipped"""
    ...

@decorator
def post_processing(call, func):
    """Post processes decorated function result with func."""
    ...

collecting = ...
@decorator
def joining(call, sep):
    """Joins decorated function results with sep."""
    ...

def once_per(*argnames): # -> Callable[..., Callable[..., Any | None]]:
    """Call function only once for every combination of the given arguments."""
    ...

once = ...
def once_per_args(func): # -> Callable[..., Any | None]:
    """Call function once for every combination of values of its arguments."""
    ...

@decorator
def wrap_with(call, ctx):
    """Turn context manager into a decorator"""
    ...

