from _typeshed import Incomplete

class SpecialFunctions:
    '''
    This class implements special functions using high-level code.

    Elementary and some other functions (e.g. gamma function, basecase
    hypergeometric series) are assumed to be predefined by the context as
    "builtins" or "low-level" functions.
    '''
    defined_functions: Incomplete
    THETA_Q_LIM: Incomplete
    mpq_1: Incomplete
    mpq_0: Incomplete
    mpq_1_2: Incomplete
    mpq_3_2: Incomplete
    mpq_1_4: Incomplete
    mpq_1_16: Incomplete
    mpq_3_16: Incomplete
    mpq_5_2: Incomplete
    mpq_3_4: Incomplete
    mpq_7_4: Incomplete
    mpq_5_4: Incomplete
    mpq_1_3: Incomplete
    mpq_2_3: Incomplete
    mpq_4_3: Incomplete
    mpq_1_6: Incomplete
    mpq_5_6: Incomplete
    mpq_5_3: Incomplete
    _misc_const_cache: Incomplete
    zetazero_memoized: Incomplete
    def __init__(self) -> None: ...
    @classmethod
    def _wrap_specfun(cls, name, f, wrap) -> None: ...
    def _besselj(ctx, n, z) -> None: ...
    def _erf(ctx, z) -> None: ...
    def _erfc(ctx, z) -> None: ...
    def _gamma_upper_int(ctx, z, a) -> None: ...
    def _expint_int(ctx, n, z) -> None: ...
    def _zeta(ctx, s) -> None: ...
    def _zetasum_fast(ctx, s, a, n, derivatives, reflect) -> None: ...
    def _ei(ctx, z) -> None: ...
    def _e1(ctx, z) -> None: ...
    def _ci(ctx, z) -> None: ...
    def _si(ctx, z) -> None: ...
    def _altzeta(ctx, s) -> None: ...

def defun_wrapped(f): ...
def defun(f): ...
def defun_static(f): ...
def cot(ctx, z): ...
def sec(ctx, z): ...
def csc(ctx, z): ...
def coth(ctx, z): ...
def sech(ctx, z): ...
def csch(ctx, z): ...
def acot(ctx, z): ...
def asec(ctx, z): ...
def acsc(ctx, z): ...
def acoth(ctx, z): ...
def asech(ctx, z): ...
def acsch(ctx, z): ...
def sign(ctx, x): ...
def agm(ctx, a, b: int = 1): ...
def sinc(ctx, x): ...
def sincpi(ctx, x): ...
def expm1(ctx, x): ...
def log1p(ctx, x): ...
def powm1(ctx, x, y): ...
def _rootof1(ctx, k, n): ...
def root(ctx, x, n, k: int = 0): ...
def unitroots(ctx, n, primitive: bool = False): ...
def arg(ctx, x): ...
def fabs(ctx, x): ...
def re(ctx, x): ...
def im(ctx, x): ...
def conj(ctx, x): ...
def polar(ctx, z): ...
def rect(ctx, r, phi): ...
def log(ctx, x, b: Incomplete | None = None): ...
def log10(ctx, x): ...
def fmod(ctx, x, y): ...
def degrees(ctx, x): ...
def radians(ctx, x): ...
def _lambertw_special(ctx, z, k): ...
def _lambertw_approx_hybrid(z, k): ...
def _lambertw_series(ctx, z, k, tol):
    """
    Return rough approximation for W_k(z) from an asymptotic series,
    sufficiently accurate for the Halley iteration to converge to
    the correct value.
    """
def lambertw(ctx, z, k: int = 0): ...
def bell(ctx, n, x: int = 1): ...
def _polyexp(ctx, n, x, extra: bool = False): ...
def polyexp(ctx, s, z): ...
def cyclotomic(ctx, n, z): ...
def mangoldt(ctx, n):
    """
    Evaluates the von Mangoldt function `\\Lambda(n) = \\log p`
    if `n = p^k` a power of a prime, and `\\Lambda(n) = 0` otherwise.

    **Examples**

        >>> from mpmath import *
        >>> mp.dps = 25; mp.pretty = True
        >>> [mangoldt(n) for n in range(-2,3)]
        [0.0, 0.0, 0.0, 0.0, 0.6931471805599453094172321]
        >>> mangoldt(6)
        0.0
        >>> mangoldt(7)
        1.945910149055313305105353
        >>> mangoldt(8)
        0.6931471805599453094172321
        >>> fsum(mangoldt(n) for n in range(101))
        94.04531122935739224600493
        >>> fsum(mangoldt(n) for n in range(10001))
        10013.39669326311478372032

    """
def stirling1(ctx, n, k, exact: bool = False): ...
def stirling2(ctx, n, k, exact: bool = False): ...
