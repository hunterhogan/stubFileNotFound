from . import libmp as libmp
from .ctx_base import StandardBaseContext as StandardBaseContext
from .libmp import ComplexResult as ComplexResult, MPZ_ONE as MPZ_ONE, dps_to_prec as dps_to_prec, finf as finf, fnan as fnan, fninf as fninf, from_float as from_float, from_int as from_int, from_rational as from_rational, from_str as from_str, fzero as fzero, int_types as int_types, mpc_hash as mpc_hash, mpci_abs as mpci_abs, mpci_add as mpci_add, mpci_div as mpci_div, mpci_exp as mpci_exp, mpci_log as mpci_log, mpci_mul as mpci_mul, mpci_neg as mpci_neg, mpci_pos as mpci_pos, mpci_pow as mpci_pow, mpci_sub as mpci_sub, mpf_hash as mpf_hash, mpf_le as mpf_le, mpf_neg as mpf_neg, mpi_abs as mpi_abs, mpi_add as mpi_add, mpi_delta as mpi_delta, mpi_div as mpi_div, mpi_from_str as mpi_from_str, mpi_mid as mpi_mid, mpi_mul as mpi_mul, mpi_neg as mpi_neg, mpi_pos as mpi_pos, mpi_pow as mpi_pow, mpi_pow_int as mpi_pow_int, mpi_str as mpi_str, mpi_sub as mpi_sub, prec_to_dps as prec_to_dps, repr_dps as repr_dps, round_ceiling as round_ceiling, round_floor as round_floor
from .libmp.backend import basestring as basestring
from .matrices.matrices import _matrix as _matrix
from _typeshed import Incomplete

mpi_zero: Incomplete
new: Incomplete

def convert_mpf_(x, prec, rounding): ...

class ivmpf:
    """
    Interval arithmetic class. Precision is controlled by iv.prec.
    """
    def __new__(cls, x: int = 0): ...
    def cast(self, cls, f_convert): ...
    def __int__(self) -> int: ...
    def __float__(self) -> float: ...
    def __complex__(self) -> complex: ...
    def __hash__(self): ...
    @property
    def real(self): ...
    @property
    def imag(self): ...
    def conjugate(self): ...
    @property
    def a(self): ...
    @property
    def b(self): ...
    @property
    def mid(self): ...
    @property
    def delta(self): ...
    @property
    def _mpci_(self): ...
    def _compare(*args) -> None: ...
    __gt__ = _compare
    __le__ = _compare
    __gt__ = _compare
    __ge__ = _compare
    def __contains__(self, t) -> bool: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def _compare(s, t, cmpfun): ...
    def __eq__(s, t): ...
    def __ne__(s, t): ...
    def __lt__(s, t): ...
    def __le__(s, t): ...
    def __gt__(s, t): ...
    def __ge__(s, t): ...
    def __abs__(self): ...
    def __pos__(self): ...
    def __neg__(self): ...
    def ae(s, t, rel_eps: Incomplete | None = None, abs_eps: Incomplete | None = None): ...

class ivmpc:
    def __new__(cls, re: int = 0, im: int = 0): ...
    def __hash__(self): ...
    def __repr__(s) -> str: ...
    def __str__(s) -> str: ...
    @property
    def a(self): ...
    @property
    def b(self): ...
    @property
    def c(self): ...
    @property
    def d(self): ...
    @property
    def real(s): ...
    @property
    def imag(s): ...
    def conjugate(s): ...
    def overlap(s, t): ...
    def __contains__(s, t) -> bool: ...
    def _compare(s, t, ne: bool = False): ...
    def __eq__(s, t): ...
    def __ne__(s, t): ...
    def __lt__(s, t): ...
    __le__ = __lt__
    __gt__ = __lt__
    __ge__ = __lt__
    def __neg__(s): ...
    def __pos__(s): ...
    def __abs__(s): ...
    def ae(s, t, rel_eps: Incomplete | None = None, abs_eps: Incomplete | None = None): ...

def _binary_op(f_real, f_complex): ...

class ivmpf_constant(ivmpf):
    _f: Incomplete
    def __new__(cls, f): ...
    def _get_mpi_(self): ...
    _mpi_: Incomplete

class MPIntervalContext(StandardBaseContext):
    def __init__(ctx) -> None: ...
    def _mpi(ctx, a, b: Incomplete | None = None): ...
    def _init_builtins(ctx): ...
    def _wrap_mpi_function(ctx, f_real, f_complex: Incomplete | None = None): ...
    @classmethod
    def _wrap_specfun(cls, name, f, wrap): ...
    def _set_prec(ctx, n) -> None: ...
    def _set_dps(ctx, n) -> None: ...
    prec: Incomplete
    dps: Incomplete
    def make_mpf(ctx, v): ...
    def make_mpc(ctx, v): ...
    def _mpq(ctx, pq): ...
    def convert(ctx, x): ...
    def nstr(ctx, x, n: int = 5, **kwargs): ...
    def mag(ctx, x): ...
    def isnan(ctx, x): ...
    def isinf(ctx, x): ...
    def isint(ctx, x): ...
    def ldexp(ctx, x, n): ...
    def absmin(ctx, x): ...
    def absmax(ctx, x): ...
    def atan2(ctx, y, x): ...
    def _convert_param(ctx, x): ...
    def _is_real_type(ctx, z): ...
    def _is_complex_type(ctx, z): ...
    def hypsum(ctx, p, q, types, coeffs, z, maxterms: int = 6000, **kwargs): ...
