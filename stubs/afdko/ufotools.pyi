"""
This type stub file was generated by pyright.
"""

__version__ = ...
__doc__ = ...
_hintFormat1_ = ...
_hintFormat2_ = ...
kDefaultGlyphsLayerName = ...
kDefaultGlyphsLayer = ...
kProcessedGlyphsLayerName = ...
kProcessedGlyphsLayer = ...
DEFAULT_LAYER_ENTRY = ...
PROCESSED_LAYER_ENTRY = ...
kFontInfoName = ...
kContentsName = ...
kLibName = ...
kPublicGlyphOrderKey = ...
kAdobeDomainPrefix = ...
kAdobHashMapName = ...
kAdobHashMapVersionName = ...
kAdobHashMapVersion = ...
kAutohintName = ...
kCheckOutlineName = ...
kCheckOutlineNameUFO = ...
kOutlinePattern = ...
COMP_TRANSFORM = ...
class UFOParseError(Exception):
    ...


class UFOFontData:
    def __init__(self, parentPath, useHashMap, programName) -> None:
        ...
    
    def getGlyphMap(self): # -> dict[Never, Any] | Any | None:
        ...
    
    def readHashMap(self): # -> None:
        ...
    
    def writeHashMap(self): # -> None:
        ...
    
    def getGlyphSrcPath(self, glyphName): # -> str:
        ...
    
    def getGlyphDefaultPath(self, glyphName): # -> str:
        ...
    
    def getGlyphProcessedPath(self, glyphName): # -> str | None:
        ...
    
    def checkSkipGlyph(self, glyphName, newSrcHash, doAll): # -> bool:
        ...
    
    @staticmethod
    def getGlyphXML(glyphDir, glyphFileName): # -> tuple[None, None, None] | tuple[Any | Literal[0], Any, Any]:
        ...
    
    def getOrSkipGlyph(self, glyphName, doAll=...): # -> tuple[None, Literal[True]] | tuple[Any | Literal[0] | None, bool]:
        ...
    
    def loadGlyphMap(self): # -> None:
        ...
    
    def buildGlyphHashValue(self, width, outlineXML, glyphName, useDefaultGlyphDir, level=...): # -> tuple[str, list[str | Any]]:
        """
        glyphData must be the official <outline> XML from a GLIF.
        We skip contours with only one point.
        """
        ...
    
    def close(self): # -> None:
        ...
    


def parseGlyphOrder(filePath): # -> dict[Any, Any] | None:
    ...

def parsePList(filePath, dictKey=...): # -> tuple[dict[Any, Any] | Any | None, list[Any]]:
    ...

def addWhiteSpace(parent, level): # -> None:
    ...

def regenerate_glyph_hashes(ufo_font_data): # -> None:
    """
    The handling of the glyph hashes is super convoluted.
    This method fixes https://github.com/adobe-type-tools/afdko/issues/349
    """
    ...

def checkHashMaps(fontPath, doSync): # -> tuple[Literal[True], list[Any]] | tuple[bool, list[Any]]:
    """
    Checks if the hashes of the glyphs in the default layer match the hash
    values stored in the UFO's 'data/com.adobe.type.processedHashMap' file.

    Returns a tuple of a boolean and a list. The boolean is True if all glyph
    hashes matched. The list contains strings that report the glyph names
    whose hash did not match.

    If doSync is True, it will delete any glyph in the processed glyph
    layer directory which does not have a matching glyph in the default
    layer, or whose source glyph hash does not match. It will then update
    the contents.plist file for the processed glyph layer, and delete
    the program specific hash maps.
    """
    ...

kAdobeLCALtSuffix = ...
def cleanUpGLIFFiles(defaultContentsFilePath, glyphDirPath, doWarning=...): # -> Literal[0, 1]:
    ...

def cleanupContentsList(glyphDirPath, doWarning=...): # -> None:
    ...

def validateLayers(ufoFontPath, doWarning=...): # -> None:
    ...

def makeUFOFMNDB(srcFontPath): # -> str:
    ...

def thresholdAttrGlyph(aGlyph, threshold=...):
    """
    Like fontPens.thresholdPen.thresholdGlyph, but preserves some glyph- and
    point-level attributes that are not preserved by that method.
    """
    ...

