"""
This type stub file was generated by pyright.
"""

import argparse

"""
Tool that performs outline quality checks and can remove path overlaps.
"""
__version__ = ...
UFO_FONT_TYPE = ...
TYPE1_FONT_TYPE = ...
CFF_FONT_TYPE = ...
OTF_FONT_TYPE = ...
class FocusOptionParseError(Exception):
    ...


class FocusFontError(Exception):
    ...


class FontFile:
    def __init__(self, font_path, font_format) -> None:
        ...
    
    def open(self, use_hash_map): # -> Font:
        ...
    
    def close(self): # -> None:
        ...
    
    def save(self): # -> None:
        ...
    
    def check_skip_glyph(self, glyph_name, do_all): # -> bool:
        ...
    
    def clear_hash_map(self): # -> None:
        ...
    


class COOptions:
    def __init__(self) -> None:
        ...
    


def parse_glyph_list_arg(glyph_string): # -> filter[str]:
    ...

class InlineHelpFormatter(argparse.RawDescriptionHelpFormatter):
    ...


def get_options(args): # -> COOptions:
    ...

def get_glyph_id(glyph_tag, font_glyph_list): # -> int | None:
    ...

def expand_names(glyph_name):
    ...

def get_glyph_names(glyph_tag, font_glyph_list, font_file_name): # -> list[Any] | None:
    ...

def filter_glyph_list(options_glyph_list, font_glyph_list, font_file_name): # -> list[Any]:
    ...

def get_digest(digest_glyph): # -> list[Any]:
    """copied from robofab ObjectsBase.py.
    """
    ...

def remove_coincident_points(bool_glyph, changed, msg): # -> tuple[Any | Literal[True], Any]:
    """ Remove coincident points.
    # a point is (segment_type, pt, smooth, name).
    # e.g. (u'curve', (138, -92), False, None)
    """
    ...

def remove_tiny_sub_paths(bool_glyph, min_area, msg):
    """
    Removes tiny subpaths that are created by overlap removal when the start
    and end path segments cross each other, rather than meet.
    """
    ...

def is_colinear_line(b3, b2, b1, tolerance=...): # -> bool:
    ...

def remove_flat_curves(new_glyph, changed, msg, options): # -> tuple[Any | Literal[True], Any]:
    """ Remove flat curves.
    # a point is (segment_type, pt, smooth, name).
    # e.g. (u'curve', (138, -92), False, None)
    """
    ...

def remove_colinear_lines(new_glyph, changed, msg, options): # -> tuple[Any | Literal[True], Any]:
    """ Remove colinear line- curves.
    # a point is (segment_type, pt, smooth, name).
    # e.g. (u'curve', (138, -92), False, None)
    """
    ...

def split_touching_paths(new_glyph): # -> None:
    """ This hack fixes a design difference between the Adobe checkoutlines
    logic and booleanGlyph, and is used only when comparing the two. With
    checkoutlines, if only a single point on a contour lines is coincident
    with the path of the another contour, the paths are NOT merged. With
    booleanGlyph, they are merged. An example is the vertex of a diamond
    shape having the same y coordinate as a horizontal line in another path,
    but no other overlap. However, this works only when a single point on one
    contour is coincident with another contour, with no other overlap. If
    there is more than one point of contact, then result is separate inner
    (unfilled) contour. This logic works only when the touching contour is
    merged with the other contour.
    """
    ...

def round_point(pt): # -> tuple[int, int]:
    ...

def do_overlap_removal(bool_glyph, changed, msg, options): # -> tuple[Any, Any | Literal[True], Any]:
    ...

def do_cleanup(new_glyph, changed, msg, options): # -> tuple[Any, Any, Any] | tuple[Any, Any | Literal[True], Any]:
    ...

def set_max_p(contour): # -> None:
    ...

def sort_contours(c1, c2): # -> Literal[1, -1, 0]:
    ...

def restore_contour_order(fixed_glyph, original_contours): # -> None:
    """ The pyClipper library first sorts all the outlines by x position,
    then y position. I try to undo that, so that un-touched contours will end
    up in the same order as the in the original, and any combined contours
    will end up in a similar order. The reason I try to match new contours
    to the old is to reduce arbitrariness in the new contour order between
    similar fonts. I can't completely avoid this, but I can reduce how often
    it happens.
    """
    ...

RE_SPACE_PATTERN = ...
def run(args=...): # -> None:
    ...

def main(): # -> None:
    ...

if __name__ == '__main__':
    ...
