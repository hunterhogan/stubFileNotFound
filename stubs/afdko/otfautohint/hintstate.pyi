"""
This type stub file was generated by pyright.
"""

from enum import Enum

"""
Storage for intermediate state built by the hinter object
"""
log = ...
class hintSegment:
    """Represents a hint "segment" (one side of a potential stem)"""
    class sType(Enum):
        LINE = ...
        BEND = ...
        CURVE = ...
        LSBBOX = ...
        USBBOX = ...
        LGBBOX = ...
        UGBBOX = ...
        GHOST = ...
    
    
    def __init__(self, aloc, oMin, oMax, pe, typ, bonus, isV, isInc, desc) -> None:
        """
        Initializes the object

        self.loc is the segment location in the aligned dimension
        (x for horizontal, y for vertical)

        self.min and self.max are the extent of the segment in the
        opposite dimension

        self.bonus is 0 for normal segments and more for "special"
        segments (e.g. those within a BlueValue)

        self.type indicates the source of the segment (with GHOST
        being specially important)

        self.isV records the dimension (False for horizontal, etc.)

        self.desc is a string with a more detailed indication of
        how the segment was derived)

        self.pe is a weak reference to the pathElement (spline) from
        which the segment was derived

        self.hintval, self.replacedBy, and self.deleted are state used
        by the hinter
        """
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __lt__(self, other) -> bool:
        ...
    
    def isBend(self):
        ...
    
    def isCurve(self):
        ...
    
    def isLine(self): # -> bool:
        ...
    
    def isBBox(self): # -> bool:
        ...
    
    def isGBBox(self): # -> bool:
        ...
    
    def isUBBox(self): # -> bool:
        ...
    
    def isGhost(self):
        ...
    
    def current(self, orig=...): # -> Self:
        """
        Returns the object corresponding to this object relative to
        self.replacedBy
        """
        ...
    
    def show(self, label): # -> None:
        """Logs a debug message about the segment"""
        ...
    


class stemValue:
    """Represents a potential hint stem"""
    def __init__(self, lloc, uloc, val, spc, lseg, useg, isGhost=...) -> None:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __lt__(self, other) -> bool:
        """Orders values by lower and then upper location"""
        ...
    
    def ghosted(self): # -> tuple[Any, Any]:
        """Return the stem range but with ghost stems normalized"""
        ...
    
    def compVal(self, spcFactor=..., ghostFactor=...): # -> tuple[Any, Any]:
        """Represent self.val and self.spc as a comparable 2-tuple"""
        ...
    
    def show(self, isV, typ): # -> None:
        """Add a log message with the content of the object"""
        ...
    


class pathElementHintState:
    """Stores the intermediate hint state of a pathElement"""
    def __init__(self) -> None:
        ...
    
    def cleanup(self): # -> None:
        """Updates and deletes segments according to deleted and replacedBy"""
        ...
    
    def pruneHintSegs(self): # -> None:
        """Deletes segments with no assigned hintval"""
        ...
    
    def segments(self): # -> list[Any]:
        ...
    
    def segLists(self, first=...): # -> tuple[tuple[str, list[Any]], tuple[str, list[Any]], tuple[str, list[Any]]] | None:
        ...
    


class glyphHintState:
    """
    Stores the intermediate hint state (for one dimension) of a glyphData
    object

    peStates: A hash of pathElementHintState objects with the pathElement as
              key
    increasingSegs: Segments with endpoints (in the opposite dimension) greater
                    than their start points
    decreasingSegs: Segments with endpoints (in the opposite dimension) less
                    than their start points
    stemValues: List of stemValue objects in increasing order of position
    mainValues: List of non-overlapping "main" stemValues in decreasing order
                of value
    rejectValues: The set of stemValues - mainValues
    counterHinted: True if the glyph is counter hinted in this dimension
    stems: stemValue stems represented in glyphData 'stem' object format
    weights: weights corresponding to 'stems', for resolving conflicts
    keepHints: If true, keep already defined hints and masks in this dimension
               (XXX only partially implemented)
    hasOverlaps: True when some stemValues overlap
    stemOverlaps: 2d boolean array. Stem n "overlaps" with stem m <=>
                  stemOverlaps[n][m] == True
    ghostCompat: if stem m is a ghost stem, ghostCompat[m] is a boolean
                 array where ghostCompat[m][n] is True <=> n can substitute
                 for m (n has the same location on the relevant side)
    mainMask: glyphData hintmask-like representation of mainValues
    """
    def __init__(self) -> None:
        ...
    
    def getPEState(self, pe, make=...): # -> pathElementHintState | None:
        """
        Returns the pathElementHintState object for pe, allocating the object
        if necessary
        """
        ...
    
    def addSegment(self, fr, to, loc, pe1, pe2, typ, bonus, isV, mid1, mid2, desc): # -> None:
        """Adds a new segment associated with pathElements pe1 and pe2"""
        ...
    
    def compactList(self, l): # -> None:
        """
        Compacts overlapping segments with the same location by picking
        one segment to represent the pair, adjusting its values, and
        removing the other segment
        """
        ...
    
    def compactLists(self): # -> None:
        """Compacts both segment lists"""
        ...
    
    def remExtraBends(self): # -> None:
        """
        Delete BEND segment x when there is another segment y:
           1. At the same location
           2. but in the other direction
           2. that is not of type BEND or GHOST and
           3. that overlaps with x and
           4. is at least three times longer
        """
        ...
    
    def deleteSegments(self): # -> None:
        ...
    
    def cleanup(self): # -> None:
        """Runs cleanup on all pathElementHintState objects"""
        ...
    
    def pruneHintSegs(self): # -> None:
        """Runs pruneHintSegs on all pathElementHintState objects"""
        ...
    


class stemLocCandidate:
    strongMultiplier = ...
    bandMultiplier = ...
    def __init__(self, loc) -> None:
        ...
    
    def addScore(self, score, strong): # -> None:
        ...
    
    def weight(self, inBand): # -> float:
        ...
    
    def isStrong(self): # -> bool:
        ...
    
    def isMixed(self): # -> bool:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __lt__(self, other) -> bool:
        ...
    


class instanceStemState:
    """
    State for the process of deciding on the lower and upper locations
    for a particular region stem.
    """
    def __init__(self, loc, dhinter) -> None:
        ...
    
    def addToLoc(self, loc, score, strong=..., bb=..., seg=...): # -> None:
        ...
    
    def bestLocation(self, isBottom): # -> None:
        ...
    


class links:
    """
    Tracks which subpaths need which stem hints and calculates a subpath
    to reduce hint substitution

    cnt: The number of subpaths
    links: A cnt x cnt array of integers modified by mark
           (Values only 0 or 1 but kept as ints for later arithmetic)
    """
    def __init__(self, glyph) -> None:
        ...
    
    def logLinks(self): # -> None:
        """Prints a log message representing links"""
        ...
    
    def logShort(self, shrt, lab): # -> None:
        """Prints a log message representing (1-d) shrt"""
        ...
    
    def mark(self, stemValues, isV): # -> None:
        """
        For each stemValue in hntr, set links[m][n] and links[n][m] to 1
        if one side of a stem is in m and the other is in n
        """
        ...
    
    def moveIdx(self, suborder, subidxs, outlinks, idx): # -> None:
        """
        Move value idx from subidxs to the end of suborder and update
        outlinks to record all links shared with idx
        """
        ...
    
    def shuffle(self): # -> list[Any] | None:
        """
        Returns suborder list with all subpath indexes in decreasing
        order of links shared with previous subpath. (The first subpath
        being the one with most links overall.)
        """
        ...
    


