"""
This type stub file was generated by pyright.
"""

from abc import abstractmethod

"""
Associates segments with points on a pathElement, then builds
these into candidate stem pairs that are evaluated and pruned
to an optimal set.
"""
log = ...
GlyphPE = ...
LocDict = ...
class dimensionHinter:
    """
    Common hinting implementation inherited by vertical and horizontal
    variants
    """
    @staticmethod
    def diffSign(a, b):
        ...
    
    @staticmethod
    def sameSign(a, b):
        ...
    
    def __init__(self, options) -> None:
        ...
    
    def setGlyph(self, fddicts, report, gllist, name, clearPrev=...): # -> None:
        """Initialize the state for processing a specific glyph"""
        ...
    
    def resetForHinting(self): # -> None:
        """Reset state for rehinting same glyph"""
        ...
    
    class glIter:
        """A pathElement set iterator for the glyphData object list"""
        __slots__ = ...
        def __init__(self, gllist, glidx=...) -> None:
            ...
        
        def __next__(self): # -> list[GlyphPE]:
            ...
        
        def __iter__(self): # -> Self:
            ...
        
    
    
    def __iter__(self, glidx=...): # -> glIter:
        ...
    
    @abstractmethod
    def startFlex(self): # -> None:
        ...
    
    @abstractmethod
    def stopFlex(self): # -> None:
        ...
    
    @abstractmethod
    def startHint(self): # -> None:
        ...
    
    @abstractmethod
    def stopHint(self): # -> None:
        ...
    
    @abstractmethod
    def startStemConvert(self): # -> None:
        ...
    
    @abstractmethod
    def stopStemConvert(self): # -> None:
        ...
    
    @abstractmethod
    def startMaskConvert(self): # -> None:
        ...
    
    @abstractmethod
    def stopMaskConvert(self): # -> None:
        ...
    
    @abstractmethod
    def isV(self): # -> None:
        ...
    
    @abstractmethod
    def segmentLists(self): # -> None:
        ...
    
    @abstractmethod
    def dominantStems(self): # -> None:
        ...
    
    @abstractmethod
    def isCounterGlyph(self): # -> None:
        ...
    
    @abstractmethod
    def inBand(self, loc, isBottom=...): # -> None:
        ...
    
    @abstractmethod
    def hasBands(self): # -> None:
        ...
    
    @abstractmethod
    def aDesc(self): # -> None:
        ...
    
    @abstractmethod
    def isSpecial(self, lower=...): # -> None:
        ...
    
    @abstractmethod
    def checkTfm(self): # -> None:
        ...
    
    def linearFlexOK(self): # -> Literal[False]:
        ...
    
    def addFlex(self, force=..., inited=...): # -> None:
        """Path-level interface to add flex hints to current glyph"""
        ...
    
    def tryFlex(self, gl, c): # -> bool:
        """pathElement-level interface to add flex hints to current glyph"""
        ...
    
    def markFlex(self, cl): # -> None:
        ...
    
    def calcHintValues(self, lnks, force=..., tryCounter=...): # -> None:
        """
        Top-level method for calculating stem hints for a glyph in one
        dimension
        """
        ...
    
    def handleOverlap(self): # -> bool:
        ...
    
    def addSegment(self, fr, to, loc, pe1, pe2, typ, desc, mid=...): # -> None:
        ...
    
    def CPFrom(self, cp2, cp3):
        """Return point cp3 adjusted relative to cp2 by CPFrac"""
        ...
    
    def CPTo(self, cp0, cp1):
        """Return point cp1 adjusted relative to cp0 by CPFrac"""
        ...
    
    def adjustDist(self, v, q):
        ...
    
    def testTan(self, p):
        """Test angle of p (treated as vector) relative to BendTangent"""
        ...
    
    @staticmethod
    def interpolate(q, v0, q0, v1, q1):
        ...
    
    def flatQuo(self, p1, p2, doOppo=...): # -> Literal[1, 0]:
        """
        Returns a measure of the flatness of the line between p1 and p2

        1 means exactly flat wrt dimension a (or o if doOppo)
        0 means not interestingly flat in dimension a. (or o if doOppo)
        Intermediate values represent degrees of interesting flatness
        """
        ...
    
    def testBend(self, p0, p1, p2): # -> Literal[False]:
        """Test of the angle between p0-p1 and p1-p2"""
        ...
    
    def isCCW(self, p0, p1, p2):
        """
        Returns true if p0 -> p1 -> p2 is counter-clockwise in glyph space.
        """
        ...
    
    def relPosition(self, c, lower=...): # -> bool:
        """
        Return value indicates whether c is in the upper (or lower)
        subpath of the glyph (assuming a strict ordering of subpaths
        in this dimension)
        """
        ...
    
    def doBendsNext(self, c): # -> None:
        """
        Adds a BEND segment (short segments marking somewhat flat
        areas) at the end of a spline. In some cases the segment is
        added in both "directions"
        """
        ...
    
    def doBendsPrev(self, c): # -> None:
        """
        Adds a BEND segment (short segments marking somewhat flat
        areas) at the start of a spline. In some cases the segment is
        added in both "directions"
        """
        ...
    
    def nodeIsFlat(self, c, doPrev=...): # -> Literal[False] | None:
        """
        Returns true if the junction of this spline and the next
        (or previous) is sufficiently flat, measured by OppoFlatMax
        and FlatMin
        """
        ...
    
    def sameDir(self, c, doPrev=...): # -> bool | None:
        """
        Returns True if the next (or previous) spline continues in roughly
        the same direction as c
        """
        ...
    
    def extremaSegment(self, pe, extp, extt, isMn): # -> tuple[Any, Any]:
        """
        Given a curved pathElement pe and a point on that spline extp at
        t == extt, calculates a segment intersecting extp where all portions
        of the segment are within ExtremaDist of pe
        """
        ...
    
    def pickSpot(self, p0, p1, dist, pp0, pp1, prv, nxt):
        """
        Picks a segment location based on candidates p0 and p1 and
        other locations and metrics picked from the spline and
        the adjacent splines. Locations within BlueValue bands are
        priviledged.
        """
        ...
    
    def cpDirection(self, p0, p1, p2): # -> Literal[1, -1, 0]:
        """
        Utility function for detecting singly-inflected curves.
        See original C code or "Fast Detection o the Geometric Form of
        Two-Dimensional Cubic Bezier Curves" by Stephen Vincent
        """
        ...
    
    def prepForSegs(self): # -> None:
        ...
    
    def genSegs(self): # -> None:
        """
        Calls genSegsForPathElement for each pe and cleans up the
        generated segment lists
        """
        ...
    
    def genSegsForPathElement(self, c):
        """
        Calculates and adds segments for pathElement c. These segments
        indicate "flat" areas of the glyph in the relevant dimension
        weighted by segment length.
        """
        ...
    
    def limitSegs(self): # -> None:
        ...
    
    def showSegs(self): # -> None:
        """
        Adds a debug log message for each generated segment.
        This information is redundant with the genSegs info except that
        it shows the result of processing with compactLists(),
        remExtraBends(), etc.
        """
        ...
    
    def genStemVals(self): # -> None:
        """
        Pairs segments of opposite direction and adds them as potential
        stems weighted by evalPair(). Also adds ghost stems for segments
        within BlueValue bands
        """
        ...
    
    def evalPair(self, ls, us): # -> tuple[Literal[0], Literal[0]] | tuple[Literal[0], int] | tuple[float, int]:
        """
        Calculates the initial "value" and "special" weights of a potential
        stem.

        Stems in one BlueValue band are given a spc boost but stems in
        both are ignored (presuambly because the Blues and OtherBlues are
        sufficient for hinting).

        Otherwise the value is based on:
           o The distance between the segment locations
           o The segment lengths
           o the extent of segment overlap (in the opposite direction)
           o Segment "bonus" values
        """
        ...
    
    def stemMiss(self, ls, us): # -> Literal[0] | None:
        """
        Adds an info message for each stem within two em-units of a dominant
        stem width
        """
        ...
    
    def addStemValue(self, lloc, uloc, val, spc, lseg, useg): # -> None:
        """Adapts the stem parameters into a stemValue object and adds it"""
        ...
    
    def insertStemValue(self, sv, note=...): # -> None:
        """
        Adds a stemValue object into the stemValues list in sort order,
        skipping redundant GHOST stems
        """
        ...
    
    def combineStemValues(self): # -> None:
        """
        Adjusts the values of stems with the same locations to give them
        each the same combined value.
        """
        ...
    
    def pruneStemVals(self): # -> None:
        """
        Prune (remove) candidate stems based on comparisons to other stems.
        """
        ...
    
    def closeSegs(self, s1, s2): # -> bool:
        """
        Returns true if the segments (and the path between them)
        are within CloseMerge of one another
        """
        ...
    
    def prune(self, sv, other_sv, desc): # -> None:
        """
        Sets the pruned property on sv and logs it and the "better" stemValue
        """
        ...
    
    def highestStemVals(self): # -> None:
        """
        Associates each segment in both lists with the highest related stemVal,
        pruning stemValues with no association
        """
        ...
    
    def findHighestValForSegs(self, segl, isU): # -> None:
        """Associates each segment in segl with the highest related stemVal"""
        ...
    
    def findHighestVal(self, seg, isU, locFlag): # -> None:
        """Finds the highest stemVal related to seg"""
        ...
    
    def considerValForSeg(self, sv, seg, isU): # -> bool:
        """Utility test for findHighestVal"""
        ...
    
    def findBestValues(self): # -> None:
        """
        Looks among stemValues with the same locations and finds the one
        with the highest spc/val. Assigns that stemValue to the .best
        property of that set
        """
        ...
    
    def replaceVals(self, oldl, oldu, newl, newu, newbest): # -> None:
        """
        Finds each stemValue at oldl, oldu and gives it a new "best"
        stemValue reference and its val and spc.
        """
        ...
    
    def mergeVals(self): # -> None:
        """
        Finds stem pairs with sides close to one another (in different
        senses) and uses replaceVals() to substitute one for another
        """
        ...
    
    def limitVals(self): # -> None:
        """
        Limit the number of stem values in a dimension
        """
        ...
    
    def checkVals(self): # -> None:
        """Reports stems with widths close to a dominant stem width"""
        ...
    
    def findLineSeg(self, loc, isBottom=...): # -> bool:
        """Returns LINE segments with the passed location"""
        ...
    
    def reportStems(self): # -> None:
        """Reports stem zones and char ("alignment") zones"""
        ...
    
    def mainVals(self): # -> None:
        """Picks set of highest-valued non-overlapping stems"""
        ...
    
    def mainOK(self, spc, val, hasHints, prevBV): # -> bool:
        """Utility test for mainVals"""
        ...
    
    def tryCounterHinting(self): # -> bool:
        """
        Attempts to counter-hint the dimension with the first three
        (e.g. highest value) mainValue stems
        """
        ...
    
    def addBBox(self, doSubpaths=...): # -> None:
        """
        Adds the top and bottom (or left and right) sides of the glyph
        as a stemValue -- serves as a backup hint stem when few are found

        When called with doSubpaths == True adds stem hints for the
        top/bottom or right/left of each subpath
        """
        ...
    
    def markStraySegs(self): # -> None:
        """
        highestStemVals() may not assign a hintval to a given segment.
        Once the list of stems has been arrived at we go through each
        looking for stems where the segment on one side is unassigned
        and assign it to that stem.
        """
        ...
    
    def convertToStemLists(self): # -> bool:
        """
        This method builds up the information needed to mostly get away from
        looking at stem values when distributing hintmasks.

        hs.stems: Tuple of arrays of the eventual hstems or vstems objects
                  that will be copied into the glyphData object, one array
                  per gllist.
        """
        ...
    
    def calcInstanceStems(self, glidx): # -> None:
        ...
    
    def bestLocation(self, sidx, ul, iSSl, hs0):
        ...
    
    def unconflict(self, sc, curSet=..., pinSet=...): # -> tuple[int, list[bool] | Any]:
        ...
    
    def convertToMasks(self): # -> None:
        """
        This method builds up the information needed to mostly get away from
        looking at stem values when distributing hintmasks.

        hs.stemOverlaps: A map of which stems overlap with which other stems.
        hs.ghostCompat: [i][j] is true if stem i is a ghost and stem j can
                        substitute for it.
        """
        ...
    
    def makePEMask(self, pestate, c):
        """Convert the hints desired by pathElement to a conflict-free mask"""
        ...
    
    def OKToRem(self, loc, spc): # -> bool:
        ...
    


class hhinter(dimensionHinter):
    def startFlex(self): # -> None:
        """Make pt.a map to x and pt.b map to y"""
        ...
    
    def stopFlex(self): # -> None:
        ...
    
    def startHint(self): # -> None:
        """
        Make pt.a map to x and pt.b map to y and store BlueValue bands
        for easier processing
        """
        ...
    
    startMaskConvert = ...
    stopMaskConvert = ...
    def dominantStems(self):
        ...
    
    def isV(self): # -> Literal[False]:
        """Mark the hinter as horizontal rather than vertical"""
        ...
    
    def inBand(self, loc, isBottom=...): # -> bool:
        """Return true if loc is within the selected set of bands"""
        ...
    
    def hasBands(self): # -> bool:
        ...
    
    def isSpecial(self, lower=...): # -> Literal[False]:
        ...
    
    def aDesc(self): # -> Literal['horizontal']:
        ...
    
    def checkTfm(self): # -> None:
        ...
    
    def checkTfmVal(self, sl, pl): # -> None:
        ...
    
    def checkInsideBands(self, loc, pl): # -> bool:
        ...
    
    def checkNearBands(self, loc, pl): # -> None:
        ...
    
    def segmentLists(self): # -> tuple[list[Any], list[Any]]:
        ...
    
    def isCounterGlyph(self): # -> bool:
        ...
    


class vhinter(dimensionHinter):
    def startFlex(self): # -> None:
        ...
    
    def stopFlex(self): # -> None:
        ...
    
    startMaskConvert = ...
    stopMaskConvert = ...
    def isV(self): # -> Literal[True]:
        ...
    
    def dominantStems(self):
        ...
    
    def inBand(self, loc, isBottom=...): # -> Literal[False]:
        ...
    
    def hasBands(self): # -> Literal[False]:
        ...
    
    def isSpecial(self, lower=...): # -> bool:
        """Check the Specials list for the current glyph"""
        ...
    
    def aDesc(self): # -> Literal['vertical']:
        ...
    
    def checkTfm(self): # -> None:
        ...
    
    def segmentLists(self): # -> tuple[list[Any], list[Any]]:
        ...
    
    def isCounterGlyph(self): # -> bool:
        ...
    


class glyphHinter:
    """
    Adapter between high-level autohint.py code and the 1D hinter.
    Also contains code that uses hints from both dimensions, primarily
    for hintmask distribution
    """
    impl = ...
    @classmethod
    def initialize(cls, options, dictRecord, logQueue=...): # -> None:
        ...
    
    @classmethod
    def hint(cls, name, glyphTuple=..., fdKey=...): # -> tuple[Any, None] | tuple[Any, GlyphReport] | tuple[Any, Any]:
        ...
    
    def __init__(self, options, dictRecord) -> None:
        ...
    
    def getSegments(self, glyph, pe, oppo=...): # -> list[Any]:
        """Returns the list of segments for pe in the requested dimension"""
        ...
    
    def getMasks(self, glyph, pe): # -> list[Any]:
        """
        Returns the masks of hints needed by/desired for pe in each dimension
        """
        ...
    
    def compatiblePaths(self, gllist, fddicts): # -> bool:
        ...
    
    def distributeMasks(self, glyph):
        """
        When necessary, chose the locations and contents of hintmasks for
        the glyph
        """
        ...
    
    def buildCounterMasks(self, glyph): # -> None:
        """
        For glyph dimensions that are counter-hinted, make a cntrmask
        with all Trues in that dimension (because only h/vstem3 style counter
        hints are supported)
        """
        ...
    
    def joinMasks(self, m, cm, log): # -> tuple[list[None], bool]:
        """
        Try to add the stems in cm to m, or start a new mask if there are
        conflicts.
        """
        ...
    
    def bridgeMasks(self, glyph, o, n, used, pe): # -> None:
        """
        For switching hintmasks: Clean up o by adding compatible stems from
        mainMask and add stems from o to n when they are close to pe

        used contains a running map of which stems have ever been included
        in a hintmask
        """
        ...
    
    def mergeMain(self, glyph): # -> bool:
        ...
    
    def cleanupUnused(self, gllist, usedmasks): # -> None:
        ...
    
    def delUnused(self, l, ml): # -> None:
        """If ml[d][i] is False delete that entry from ml[d]"""
        ...
    
    def listHintInfo(self, glyph): # -> None:
        """
        Output debug messages about which stems are associated with which
        segments
        """
        ...
    
    def remFlares(self, glyph): # -> None:
        """
        When two paths are witin MaxFlare and connected by a path that
        also stays within MaxFlare, and both desire different stems,
        (sometimes) remove the lower-valued stem of the pair
        """
        ...
    
    def isFlare(self, loc, glyph, c, n): # -> bool:
        """Utility function for remFlares"""
        ...
    
    def isUSeg(self, loc, uloc, lloc):
        ...
    
    def reportRemFlare(self, pe, pe2, desc): # -> None:
        ...
    
    def otherInstanceStems(self, gllist): # -> Literal[True] | None:
        ...
    
    def otherInstanceMasks(self, gllist): # -> Literal[True] | None:
        ...
    


