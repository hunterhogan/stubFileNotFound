"""
This type stub file was generated by pyright.
"""

from fontTools.pens.pointPen import AbstractPointPen

"""
This module provides means of reading glyph data from and writing data
to UFO fonts, partly in virtue of the fontTools UFO library.

Developed in order to support checkOutlines and autohint, the code
supports two main functions:
- convert between UFO GLIF and GlyphData representations
- Calculate a hash value for a glyph path used to maintain a map of what
  glyphs have already been processed.

The basic model is:
 - read GLIF file
 - transform GLIF XML element to a GlyphData structure
 - operate on the GlyphData structure
 - transform the altered GlyphData back to a GLIF XML element,
   and save in list
-
After all glyphs are done save all the new GLIF XML elements to GLIF
files, and update the hash map.

A complication in the Adobe UFO workflow comes from the fact we want to
make sure that checkOutlines and autohint have been run on each glyph in
a UFO font, when building an OTF font from the UFO font. We need to run
checkOutlines, because we no longer remove overlaps from source UFO font
data, because this can make revising a glyph much easier. We need to run
autohint, because the glyphs must be hinted after checkOutlines is run,
and in any case we want all glyphs to have been autohinted. The problem
with this is that it can take a minute or two to run autohint or
checkOutlines on a 2K-glyph font. The way we avoid this is to make and
keep a hash of the source glyph drawing operators for each tool. When
the tool is run, it calculates a hash of the source glyph, and compares
it to the saved hash. If these are the same, the tool can skip the
glyph. This saves a lot of time: if checkOutlines and autohint are run
on all glyphs in a font, then a second pass is under 2 seconds.

Another issue is that since we no longer remove overlaps from the source
glyph files, checkOutlines must write any edited glyph data to a
different layer in order to not destroy the source data. The ufoFont
defines an Adobe-specific glyph layer for processed glyphs, named
"glyphs.com.adobe.type.processedGlyphs".
checkOutlines writes new glyph files to the processed glyphs layer only
when it makes a change to the glyph data.

When the autohint program is run, the ufoFont must be able to tell
whether checkOutlines has been run and has altered a glyph: if so, the
input file needs to be from the processed glyph layer, else it needs to
be from the default glyph layer.

The way the hashmap works is that we keep an entry for every glyph that
has been processed, identified by a hash of its marking path data. Each
entry contains:
- a hash of the glyph point coordinates, from the default layer.
This is set after a program has been run.
- a history list: a list of the names of each program that has been run,
  in order.
- an editStatus flag.
Altered GLIF data is always written to the Adobe processed glyph layer. The
program may or may not have altered the outline data. For example, autohint
adds private hint data, and adds names to points, but does not change any
paths.

If the stored hash for the glyph does not exist, the ufoFont lib will save the
new hash in the hash map entry and will set the history list to contain just
the current program. The program will read the glyph from the default layer.

If the stored hash matches the hash for the current glyph file in the default
layer, and the current program name is in the history list,then ufoFont
will return "skip=1", and the calling program may skip the glyph.

If the stored hash matches the hash for the current glyph file in the default
layer, and the current program name is not in the history list, then the
ufoFont will return "skip=0". If the font object field 'usedProcessedLayer' is
set True, the program will read the glyph from the from the Adobe processed
layer, if it exists, else it will always read from the default layer.

If the hash differs between the hash map entry and the current glyph in the
default layer, and usedProcessedLayer is False, then ufoFont will return
"skip=0". If usedProcessedLayer is True, then the program will consult the
list of required programs. If any of these are in the history list, then the
program will report an error and return skip =1, else it will return skip=1.
The program will then save the new hash in the hash map entry and reset the
history list to contain just the current program. If the old and new hash
match, but the program name is not in the history list, then the ufoFont will
not skip the glyph, and will add the program name to the history list.


The only tools using this are, at the moment, checkOutlines, checkOutlinesUFO
and autohint. checkOutlines and checkOutlinesUFO use the hash map to skip
processing only when being used to edit glyphs, not when reporting them.
checkOutlines necessarily flattens any components in the source glyph file to
actual outlines. autohint adds point names, and saves the hint data as a
private data in the new GLIF file.

autohint saves the hint data in the GLIF private data area, /lib/dict,
as a key and data pair. See below for the format.

autohint started with _hintFormat1_, a reasonably compact XML representation of
the data. In Sep 2105, autohhint switched to _hintFormat2_ in order to be plist
compatible. This was necessary in order to be compatible with the UFO spec, by
was driven more immediately by the fact the the UFO font file normalization
tools stripped out the _hintFormat1_ hint data as invalid elements.


"""
log = ...
_hintFormat1_ = ...
_hintFormat2_ = ...
PUBLIC_GLYPH_ORDER = ...
ADOBE_DOMAIN_PREFIX = ...
PROCESSED_LAYER_NAME = ...
PROCESSED_GLYPHS_DIRNAME = ...
HASHMAP_NAME = ...
HASHMAP_VERSION_NAME = ...
HASHMAP_VERSION = ...
AUTOHINT_NAME = ...
CHECKOUTLINE_NAME = ...
POINT_NAME_PATTERN = ...
HINT_DOMAIN_NAME1 = ...
HINT_DOMAIN_NAME2 = ...
FLEX_INDEX_LIST_NAME = ...
HINT_SET_LIST_NAME = ...
HSTEM3_NAME = ...
HSTEM_NAME = ...
POINT_NAME = ...
POINT_TAG = ...
STEMS_NAME = ...
VSTEM3_NAME = ...
VSTEM_NAME = ...
STACK_LIMIT = ...
class UFOFontData:
    def __init__(self, path, log_only, write_to_default_layer) -> None:
        ...
    
    def getUnitsPerEm(self): # -> Any:
        ...
    
    def getPSName(self): # -> Any:
        ...
    
    def getInputPath(self): # -> Any:
        ...
    
    @staticmethod
    def isCID(): # -> Literal[False]:
        ...
    
    def convertToGlyphData(self, name, readStems, readFlex, roundCoords, doAll=...): # -> glyphData | None:
        ...
    
    def updateFromGlyph(self, glyph, name): # -> None:
        ...
    
    def save(self, path): # -> None:
        ...
    
    @property
    def hashMap(self): # -> dict[str, tuple[Literal[1], Literal[0]]] | Any:
        ...
    
    def writeHashMap(self, writer): # -> None:
        ...
    
    def updateHashEntry(self, glyphName): # -> None:
        ...
    
    def removeHashEntry(self, glyphName): # -> None:
        ...
    
    def recalcHashEntry(self, glyphName, glyph): # -> None:
        ...
    
    def checkSkipGlyph(self, glyphName, newSrcHash, doAll): # -> bool:
        ...
    
    @staticmethod
    def get_glyph_data(glyph, name, readStems, readFlex, roundCoords, glyphset): # -> glyphData:
        ...
    
    def getGlyphList(self): # -> list[Any]:
        ...
    
    @property
    def glyphMap(self):
        ...
    
    @property
    def processedLayerGlyphMap(self): # -> dict[Any, Any]:
        ...
    
    @property
    def fontInfo(self): # -> dict[str, Any]:
        ...
    
    def getPrivateFDDict(self, allowNoBlues, noFlex, vCounterGlyphs, hCounterGlyphs, desc, fdIndex=...): # -> FDDict:
        ...
    
    def getfdIndex(self, name): # -> Literal[0]:
        ...
    
    def isVF(self): # -> Literal[False]:
        ...
    
    def get_min_max(self, upm): # -> tuple[Any, Any]:
        ...
    
    def mergePrivateMap(self, privateMap): # -> None:
        ...
    
    @staticmethod
    def close(): # -> None:
        ...
    


class HashPointPen(AbstractPointPen):
    def __init__(self, glyph, glyphset=...) -> None:
        ...
    
    def getHash(self): # -> str:
        ...
    
    def beginPath(self, identifier=..., **kwargs): # -> None:
        ...
    
    def endPath(self): # -> None:
        ...
    
    def addPoint(self, pt, segmentType=..., smooth=..., name=..., identifier=..., **kwargs): # -> None:
        ...
    
    def addComponent(self, baseGlyphName, transformation, identifier=..., **kwargs): # -> None:
        ...
    


class GlyphDataWrapper:
    """
    Wraps a glyphData object while storing the properties set by readGlyph
    to aid output of hint data in Adobe's "hint format 2" for UFO.
    """
    def __init__(self, glyph) -> None:
        ...
    
    def addUfoFlex(self, uhl, pointname): # -> None:
        """Mark the named point as starting a flex hint"""
        ...
    
    def addUfoMask(self, uhl, masks, pointname): # -> None:
        """Associates the hint set represented by masks with the named point"""
        ...
    
    def addUfoHints(self, uhl, pe, labelnum, startSubpath=...): # -> tuple[Any, None] | tuple[Any | int, Any]:
        """Adds hints to the pathElement, naming points as necessary"""
        ...
    
    def drawPoints(self, pen, ufoHintLib=...): # -> None:
        """
        Calls pointPen commands on pen to draw the glyph, optionally naming
        some points and building a library of hint annotations
        """
        ...
    


