"""
This type stub file was generated by pyright.
"""

from fontTools.ttLib import TTFont
from fontTools.misc.loggingTools import Timer

"""
How to build a feature-file format.
1) Traverse script->language->feature tree, building up list as we go.

These are all expected to be in alphabetic order in the font.

Add each  feature entry as FeatDict[tag][lang_sys].append(index]), and as
FeatDict[index] .append(lang_sys)

If there is no DFLT script, then step through all entries of  FeatDict[index].
Add FeatDict[tag]["DFLT_dflt"].append(index) for all FeatDict[index] where the
number of lang_sys entries is the same as the number of lang_sys values.

Write out the language systems.

Collect and write the class defs.
For each lookup in lookup list: for each class def in the lookup:
    add entry to ClassesByNameDict[<glyph list as tuple>].append(lookup index,
        subtable_index, class index)

Get list of keys for ClassesByNameDict. Sort. MakeClassNameDict.
For each  keys for ClassesByNameDict:
    make class name from <firstglyph_lastglyph>.
    while class name is in ClassesByNameDict:
        find glyph in current class that is not in previous class, and
            make name firstglyph_diff-glyph_last-glyph
    add entry to ClassesByLookup[lookup index, subtable_index, class index)] =
        class name.

Same for mark classes.

Write out class defs.

Write out the feature list.
Make lookupDict = {}
Get feat tag list. For each tag:
    note if DFLT dflt lang sys has any lookups.
    for each lang_sys ( by definition, starts with DFLT, then the rest in
      alpha order).
        If script is DFLT:
            don't write script/lang
            build list of lookups for DFLT script.
        else:
            get union of lookup indicies in all feat indicies
            Remove all the default lookups from the lookup list:
            if no lookups left, continue
            if there was no intersection with default lookups, set exclude
                keyword
            if the script is same as last one, write language only,
            else write script and language.

        if lookupIndex is in lookupDict:
            just write lookup references
        else:
            write lookup definition with name "feat_script_lang_new_index"


"""
__help__ = ...
__version__ = ...
log = ...
curSystem = ...
TX_TOOL = ...
INDENT = ...
ChainINDENT = ...
MAX_LINE_LENGTH = ...
gtextWrapper = ...
NULL_VALUE_RECORD = ...
def getValueRecord(a, b, c, d): # -> LiteralString:
    ...

def getAnchorString(anchorTable): # -> str:
    ...

class ClassRecord:
    def __init__(self, lookupIndex, subtableIndex, classIndex, side=..., anchor=...) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    


def addClassDef(otlConv, classDefs, coverage, side=..., anchor=...): # -> None:
    ...

def AddMarkClassDef(otlConv, markCoverage, markArray, tag): # -> None:
    ...

def classPairGPOS(subtable, otlConv=...): # -> None:
    ...

def markClassPOS(subtable, otlConv=...): # -> None:
    ...

def markLigClassPOS(subtable, otlConv=...): # -> None:
    ...

def markMarkClassPOS(subtable, otlConv=...): # -> None:
    ...

def classContext(subtable, otlConv): # -> None:
    ...

def classChainContext(subtable, otlConv): # -> None:
    ...

def classExt(subtable, otlConv): # -> None:
    ...

class ContextRecord:
    def __init__(self, inputList, sequenceIndex) -> None:
        ...
    


def checkGlyphInSequence(glyphName, contextSequence, i): # -> Literal[1, 0]:
    ...

def ruleSinglePos(subtable, otlConv, context=...): # -> list[Any]:
    ...

def rulePairPos(subtable, otlConv, context=...):
    ...

def ruleCursivePos(subtable, otlConv, context=...): # -> list[Any]:
    ...

def ruleMarkBasePos(subtable, otlConv, context=...): # -> list[Any]:
    ...

def ruleMarkLigPos(subtable, otlConv, context=...): # -> list[Any]:
    ...

def ruleMarkMarkPos(subtable, otlConv, context=...): # -> list[Any]:
    ...

def ruleContextPOS(subtable, otlConv, context=...): # -> list[Any]:
    ...

def ruleChainContextPOS(subtable, otlConv, context=...): # -> list[Any]:
    ...

def ruleExt(subtable, otlConv, context=...):
    ...

def ruleSingleSub(subtable, otlConv, context=...): # -> list[Any]:
    ...

def ruleMultipleSub(subtable, otlConv, context=...): # -> list[Any]:
    ...

def ruleAltSub(subtable, otlConv, context=...): # -> list[Any]:
    ...

def ruleLigatureSub(subtable, otlConv, context=...): # -> list[Any]:
    ...

def ruleContextSUB(subtable, otlConv, context=...): # -> list[Any]:
    ...

def wrap_statement(token_str): # -> str:
    """
    Wraps a long string of space-separated tokens
    or a list of tokens.
    """
    ...

def ruleChainContextSUB(subtable, otlConv, context=...): # -> list[Any]:
    ...

def ruleReverseChainSub(subtable, otlConv, context=...): # -> list[Any]:
    ...

def getValRec(valueFormat, valueRec): # -> LiteralString | Literal['0']:
    ...

gLookupFlagMap = ...
gLookupFlagKeys = ...
def getLookupFlagTag(lookupFlag): # -> LiteralString:
    ...

DFLT_LANGSYS_KEYS = ...
class OTLConverter:
    leftSideTag = ...
    rightSideTag = ...
    backtrackTag = ...
    InputTag = ...
    lookAheadTag = ...
    markTag = ...
    mark1Tag = ...
    mark2Tag = ...
    def __init__(self, writer, ttFont, table_tag) -> None:
        ...
    
    def otlFeatureFormat(self): # -> None:
        ...
    
    @staticmethod
    def addLangSysEntry(pfeatList, scriptTag, langTag, langSys, featDictByLangSys, featDictByIndex): # -> None:
        ...
    
    def buildLangSys(self): # -> tuple[list[Any], dict[Any, Any], dict[Any, Any]]:
        ...
    
    def writeLangSys(self, lsList): # -> None:
        ...
    
    def buildClasses(self): # -> None:
        ...
    
    def writeClasses(self): # -> None:
        ...
    
    def writeMarkClasses(self): # -> None:
        ...
    
    def doFeatures(self, featDictByLangSys): # -> None:
        ...
    
    def writeDfltLangSysFeat(self, langSysKey, featIndexList): # -> dict[Any, Any]:
        ...
    
    def writeLangSysFeat(self, langSysKey, prevLangSysKey, featIndexList, dfltLookupIndexDict): # -> None:
        ...
    
    def writeLookup(self, lookup): # -> None:
        ...
    


def dumpOTLAsFeatureFile(writer, ttFont, table_tag): # -> None:
    ...

class TTXNTTFont(TTFont):
    def __init__(self, file=..., res_name_or_index=..., sfntVersion=..., flavor=..., checkChecksums=..., verbose=..., recalcBBoxes=..., ignoreDecompileErrors=..., recalcTimestamp=..., fontNumber=..., lazy=..., quiet=..., supressHints=..., showExtensionFlag=...) -> None:
        ...
    


def shellcmd(cmdList): # -> str:
    ...

def dumpFont(writer, fontPath, supressHints=...): # -> None:
    ...

@Timer(log, 'Done dumping TTX in %(time).3f seconds')
def ttnDump(input_file, output, options, showExtensionFlag, supressHints=..., supressVersions=..., supressTTFDiffs=...):
    ...

def main(args=...): # -> Literal[0, 2, 1] | None:
    ...

if __name__ == "__main__":
    ...
