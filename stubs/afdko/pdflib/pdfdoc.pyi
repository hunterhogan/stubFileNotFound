"""
This type stub file was generated by pyright.
"""

"""
PDFgen is a library to generate PDF files containing text and graphics.  It is the
foundation for a complete reporting solution in Python.

The module pdfdoc.py handles the 'outer structure' of PDF documents, ensuring that
all objects are properly cross-referenced and indexed to the nearest byte.  The
'inner structure' - the page descriptions - are presumed to be generated before
each page is saved.
pdfgen.py calls this and provides a 'canvas' object to handle page marking operators.
piddlePDF calls pdfgen and offers a high-level interface.

(C) Copyright Andy Robinson 1998-1999

Modified 7/25/2006 read rooberts. Added supported for embedding fonts.
"""
Log = ...
StandardEnglishFonts = ...
kDefaultEncoding = ...
kDefaultFontType = ...
AFMDIR = ...
A4 = ...
class PDFError(KeyError):
    ...


class PDFDocument:
    """Responsible for linking and writing out the whole document.
    Builds up a list of objects using add(key, object).  Each of these
    must inherit from PDFObject and be able to write itself into the file.
    For cross-linking, it provides getPosition(key) which tells you where
    another object is, or raises a KeyError if not found.  The rule is that
    objects should only refer ones previously written to file.
    """
    def __init__(self) -> None:
        ...
    
    def add(self, key, obj): # -> int:
        ...
    
    def getPosition(self, key):
        """Tell you where the given object is in the file - used for
        cross-linking; an object can call self.doc.getPosition("Page001")
        to find out where the object keyed under "Page001" is stored."""
        ...
    
    def setTitle(self, title): # -> None:
        "embeds in PDF file"
        ...
    
    def setAuthor(self, author): # -> None:
        "embedded in PDF file"
        ...
    
    def setSubject(self, subject): # -> None:
        "embeds in PDF file"
        ...
    
    def printXref(self): # -> None:
        ...
    
    def writeXref(self, f): # -> None:
        ...
    
    def printTrailer(self): # -> None:
        ...
    
    def writeTrailer(self, f): # -> None:
        ...
    
    def SaveToFile(self, filename): # -> None:
        ...
    
    def SaveToFileObject(self, fileobj): # -> None:
        """Open a file, and ask each object in turn to write itself to
        the file.  Keep track of the file position at each point for
        use in the index at the end"""
        ...
    
    def printPDF(self): # -> None:
        "prints it to standard output.  Logs positions for doing trailer"
        ...
    
    def addPage(self, page): # -> None:
        """adds page and stream at end.  Maintains pages list"""
        ...
    
    def hasFont(self, psfontname, encoding=...): # -> Literal[1, 0]:
        ...
    
    def addFont(self, psname, encoding=..., clientCtx=..., getFontDescriptorItems=..., getEncodingInfo=...): # -> None:
        """ If you pass in just the psname, you can font dict that will work
        with only one of the built-in fonts. To emebed a font, you need to pass
        in all of the rest. "encoding" must be a string that is either one of
        the stanrd PDF encoding names, like '/MacRoman', or a string containing
        a well-formed PDF encoding dict.

        clientCtx is a client-provided Python object that cntains the data used
        be the client call back functions, getFontDescriptorItems,
        getEncodingInfo.

        getFontDescriptorItems is a client call back function that must return
        fdText, type, fontStream, fontStreamType

        fdText must be sttring containing a well-formed /FontDescriptor dict. In
        this string, the the reference to the embedded font stream must be as an
        indirect reference, with the object number being a string format , ie.
        /FontFile3 %s 0 R" This is is necessary ot allow the font stream object
        number ot be filled in later, by the line: fdText = fdText %
        objectNumber in MakeType1Font.

        type must tbe the PDF name for the font type, such as "/Type1"

        fontStream must be the actual font data to be embedded, not the entire
        PDF stream object. At the moment, it supports only CFF font data.

        fontStreamType is the value for the stream font SubType, e.g. /Type1C
        getEncodingInfo is a client call back function that must return
        firstChar, lastChar, widths

        firstChar is the index in the encoding array of the first glyph name
        which is not notdef lastChar is the index in the encoding array of the
        last glyph name whcih is not notdef widths is the width array of the
        encoded glyphs. It must contain a list of widths for the glyphs in the
        encoding array from firstChar to lastChar.

        The call to addFont will add the font descriptor object and the embedded
        stream object the first time it is called. If it is called again with
        the same PS name and encoding string, it will simply reference the font
        descriptor object and the embedded stream object that was already added,
        but will create a new font dict with a new widths and encoding dict.


        """
        ...
    
    def getInternalFontName(self, psfontname, encoding=...):
        ...
    
    def getAvailableFonts(self): # -> map[list[Any]]:
        ...
    
    def MakeType1Font(self, fontIndex, psName, encoding=..., clientCtx=..., getFontDescriptorItems=..., getEncodingInfo=...): # -> PDFType0Font | PDFType1Font:
        "returns a font object"
        ...
    


class OutputGrabber:
    """At times we need to put something in the place of standard
    output.  This grabs stdout, keeps the data, and releases stdout
    when done.

    NOT working well enough!"""
    def __init__(self) -> None:
        ...
    
    def write(self, x): # -> None:
        ...
    
    def getData(self): # -> LiteralString:
        ...
    
    def close(self): # -> None:
        ...
    
    def __del__(self): # -> None:
        ...
    


def testOutputGrabber(): # -> None:
    ...

class PDFObject:
    """Base class for all PDF objects.  In PDF, precise measurement
    of file offsets is essential, so the usual trick of just printing
    and redirecting output has proved to give different behaviour on
    Mac and Windows.  While it might be soluble, I'm taking charge
    of line ends at the binary level and explicitly writing to a file.
    The LINEEND constant lets me try CR, LF and CRLF easily to help
    pin down the problem."""
    def save(self, file): # -> None:
        "Save its content to an open file"
        ...
    
    def printPDF(self): # -> None:
        ...
    


class PDFLiteral(PDFObject):
    " a ready-made one you wish to quote"
    def __init__(self, text) -> None:
        ...
    
    def save(self, file): # -> None:
        ...
    


class PDFCatalog(PDFObject):
    "requires RefPages and RefOutlines set"
    def __init__(self) -> None:
        ...
    
    def save(self, file): # -> None:
        ...
    


class PDFInfo(PDFObject):
    """PDF documents can have basic information embedded, viewable from
    File | Document Info in Acrobat Reader.  If this is wrong, you get
    Postscript errors while printing, even though it does not print."""
    def __init__(self) -> None:
        ...
    
    def save(self, file): # -> None:
        ...
    


class PDFOutline(PDFObject):
    "null outline, does nothing yet"
    def __init__(self) -> None:
        ...
    
    def save(self, file): # -> None:
        ...
    


class PDFPageCollection(PDFObject):
    "presumes PageList attribute set (list of integers)"
    def __init__(self) -> None:
        ...
    
    def save(self, file): # -> None:
        ...
    


class PDFPage(PDFObject):
    """The Bastard.  Needs list of Resources etc. Use a standard one for now.
    It manages a PDFStream object which must be added to the document's list
    of objects as well."""
    def __init__(self) -> None:
        ...
    
    def setCompression(self, onoff=...): # -> None:
        "Turns page compression on or off"
        ...
    
    def save(self, file): # -> None:
        ...
    
    def clear(self): # -> None:
        ...
    
    def setStream(self, data): # -> None:
        ...
    


TestStream = ...
class PDFStream(PDFObject):
    "Used for the contents of a page"
    def __init__(self) -> None:
        ...
    
    def setStream(self, data): # -> None:
        ...
    
    def save(self, file): # -> None:
        ...
    


class PDFImage(PDFObject):
    def save(self, file): # -> None:
        ...
    


class PDFEmbddedFont(PDFStream):
    def __init__(self, fontStreamType) -> None:
        ...
    
    def save(self, file): # -> None:
        ...
    


class PDFType1Font(PDFObject):
    def __init__(self, key, psName, encoding=..., fontDescriptObjectNumber=..., type=..., firstChar=..., lastChar=..., widths=...) -> None:
        ...
    
    def save(self, file): # -> None:
        ...
    


class PDFType0Font(PDFType1Font):
    ...


class PDFontDescriptor(PDFObject):
    def __init__(self, text) -> None:
        ...
    
    def save(self, file): # -> None:
        ...
    


def MakeFontDictionary(fontMapping): # -> LiteralString:
    ...

