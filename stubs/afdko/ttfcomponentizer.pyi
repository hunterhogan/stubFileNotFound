"""
This type stub file was generated by pyright.
"""

"""
Takes in a TrueType font and looks for a UFO font stored in the same folder.
Uses the UFO's components data to componentize matching TrueType glyphs.
The script only supports components that are not scaled, rotated nor flipped.
"""
__version__ = ...
PUBLIC_PSNAMES = ...
GOADB_FILENAME = ...
class ComponentsData:
    def __init__(self) -> None:
        ...
    
    def add_component(self, name, pos): # -> None:
        ...
    


class TTComponentizer:
    def __init__(self, ufo, ps_names, input_path, output_path=...) -> None:
        ...
    
    def componentize(self): # -> None:
        ...
    
    def get_composites_data(self): # -> None:
        """
        Iterate thru each glyph of a UFO and collect the names and positions
        of all components that make up a composite glyph. The process will
        only collect data for composites that are strictly made with components
        (i.e. no mixed contours-components composites), and whose components
        only have x and y transformations (thus composites with scaled,
        rotated, or flipped componentes will NOT be considered).

        Fills the 'composites_data' dictionary whose keys are composite names
        and whose values are ComponentsData objects.

        NOTE: All glyph names in the returned dictionary are production names.
        """
        ...
    
    def check_1st_comp_advwidth(self, glyph):
        """
        Returns True if the advance width of the composite glyph is the same
        as the advance width of its first component, and False otherwise.
        This information is essential for setting the flag of the composite's
        first component later on.
        """
        ...
    
    def componentize_ttf(self): # -> None:
        """
        Loads a TrueType font and iterates thru a dictionary of composites
        data. Remakes some glyphs in the glyf table from being made of
        countours to being made of components.

        Saves the modified font in a new location if an output path was
        provided, otherwise overwrites the original one.

        Updates a count of the glyphs that got componentized.
        """
        ...
    
    @staticmethod
    def assemble_components(comps_data): # -> list[Any]:
        """
        Assemble and return a list of GlyphComponent objects.
        """
        ...
    


def get_ufo_path(ttf_path): # -> None:
    """
    Find a UFO font in the same folder as the TT font.
    Returns the UFO's path or None.
    """
    ...

def get_goadb_path(font_path): # -> str | None:
    """
    Find a file named GlyphOrderAndAliasDB. This file can be in the same
    folder as the font, or up-to 3 folders above.
    Returns the GOADB's path or None.
    """
    ...

def read_txt_file_lines(file_path): # -> list[str]:
    ...

def process_goadb(goadb_path): # -> dict[Any, Any]:
    """
    Read a GOADB file and return a dictionary mapping glyph design names to
    glyph production names. The returned mapping may be empty as it will only
    contain entries for glyph names that change from design to production.
    The sctructure of each line of a GOADB file is:
    production_name<tab>design_name<tab>unicode_overrides
    Blank lines and comment lines are alowed in a GOADB file.
    """
    ...

def get_goadb_names_mapping(ufo_path): # -> dict[Any, Any]:
    """
    Assemble a glyph names' mapping dictionary from a GOADB file.
    Returns a dictionary, which can be empty.
    """
    ...

def get_glyph_names_mapping(ufo_path): # -> tuple[None, None] | tuple[Font, Any] | tuple[Font, dict[Any, Any]]:
    """
    Return a dictionary mapping glyphs' design names to production names.
    This mapping is necessary because the glyph names of the input TTF will
    be production (a.k.a. final) glyph names. In many cases the glyph's design
    name and the production name will be the same, but they may also differ.

    The method will first try to obtain the mapping from the UFO's lib key
    named 'public.postscriptNames'. If this key is not present, the method
    will try to find (and later process) a GlyphOrderAndAliasDB file in the
    folder tree.

    The returned dictionary may be empty, in which case it's assumed that
    there's no difference between the UFO's and the TTF's glyphs' names.

    The UFO object is also returned.
    """
    ...

def get_options(args): # -> Namespace:
    ...

def main(args=...): # -> Literal[1] | None:
    ...

if __name__ == "__main__":
    ...
