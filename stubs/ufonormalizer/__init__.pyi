"""
This type stub file was generated by pyright.
"""

import binascii
import time
import os
import shutil
import plistlib
import datetime
import glob
import logging
from xml.etree import cElementTree as ET
from collections import OrderedDict
from io import open
from ._version import __version__

description = ...
log = ...
def main(args=...): # -> bool | Literal[1] | None:
    ...

modTimeLibKey = ...
imageReferencesLibKey = ...
def tobytes(s, encoding=..., errors=...): # -> bytes:
    '''no docstring'''
    ...

def tounicode(s, encoding=..., errors=...): # -> str:
    ...

if str == bytes:
    tostr = ...
else:
    tostr = ...
class UFONormalizerError(Exception):
    ...


DEFAULT_FLOAT_PRECISION = ...
FLOAT_FORMAT = ...
def normalizeUFO(ufoPath, outputPath=..., onlyModified=..., floatPrecision=..., writeModTimes=...): # -> None:
    ...

def normalizeGlyphsDirectoryNames(ufoPath): # -> list[tuple[Any, Any]] | None:
    """
    Normalize glyphs directory names following
    UFO 3 user name to file name convention.
    """
    ...

def normalizeUFO1And2GlyphsDirectory(ufoPath, modTimes): # -> None:
    ...

def normalizeGlyphsDirectory(ufoPath, layerDirectory, onlyModified=..., writeModTimes=...): # -> set[Any]:
    ...

def normalizeLayerInfoPlist(ufoPath, layerDirectory): # -> None:
    ...

def normalizeGlyphNames(ufoPath, layerDirectory): # -> dict[Any, Any]:
    """
    Normalize GLIF file names following
    UFO 3 user name to file name convention.
    """
    ...

def normalizeMetaInfoPlist(ufoPath, modTimes): # -> None:
    ...

def normalizeFontInfoPlist(ufoPath, modTimes): # -> None:
    ...

def normalizeGroupsPlist(ufoPath, modTimes): # -> None:
    ...

def normalizeKerningPlist(ufoPath, modTimes): # -> None:
    ...

def normalizeLayerContentsPlist(ufoPath, modTimes): # -> None:
    ...

def normalizeLibPlist(ufoPath): # -> None:
    ...

def normalizePropertyList(data, preprocessor=...): # -> str:
    ...

def normalizeGLIFString(text, glifPath=..., imageFileRef=...): # -> str:
    ...

def normalizeGLIF(ufoPath, *subpath): # -> None:
    """
    - Normalize the mark color if specified.

    TO DO: need doctests
    The best way to test this is going to be have a GLIF
    that contains all of the element types. This can be
    round tripped and compared to make sure that the result
    matches the expectations. This GLIF doesn't need to
    contain a robust series of element variations as the
    testing of those will be handled by the element
    normalization functions.
    """
    ...

_glifDefaultTransformation = ...
xmlDeclaration = ...
plistDocType = ...
xmlTextMaxLineLength = ...
xmlIndent = ...
xmlLineBreak = ...
xmlAttributeOrder = ...
d = ...
xmlAttributeOrder = ...
class XMLWriter:
    def __init__(self, isPropertyList=..., declaration=...) -> None:
        ...
    
    def getText(self): # -> str:
        ...
    
    def raw(self, line): # -> None:
        ...
    
    def data(self, text): # -> None:
        ...
    
    def simpleElement(self, tag, attrs=..., value=...): # -> None:
        ...
    
    def beginElement(self, tag, attrs=...): # -> None:
        ...
    
    def endElement(self, tag): # -> None:
        ...
    
    def propertyListObject(self, data): # -> None:
        ...
    
    def attributesToString(self, attrs): # -> LiteralString:
        """
        - Sort the known attributes in the preferred order.
        - Sort unknown attributes in alphabetical order and
          place them after the known attributes.
        - Format as space separated name="value".
        """
        ...
    


def xmlEscapeText(text):
    ...

def xmlEscapeAttribute(text):
    ...

def xmlConvertValue(value): # -> str:
    ...

def xmlConvertFloat(value): # -> str:
    ...

def xmlConvertInt(value): # -> str:
    ...

def duplicateUFO(inPath, outPath): # -> None:
    """
    Duplicate an entire UFO.
    """
    ...

def subpathJoin(ufoPath, *subpath): # -> str:
    """
    Join path parts.
    """
    ...

def subpathSplit(path): # -> tuple[Any, Any]:
    """
    Split path parts.
    """
    ...

def subpathExists(ufoPath, *subpath): # -> bool:
    """
    Get a boolean indicating if a path exists.
    """
    ...

def subpathReadFile(ufoPath, *subpath): # -> str:
    """
    Read the contents of a file.
    """
    ...

def subpathReadPlist(ufoPath, *subpath): # -> Any:
    """
    Read the contents of a property list
    and convert it into a Python object.
    """
    ...

def subpathWriteFile(text, ufoPath, *subpath): # -> None:
    """
    Write data to a file.

    This will only modify the file if the
    file contains data that is different
    from the new data.
    """
    ...

def subpathWritePlist(data, ufoPath, *subpath): # -> None:
    """
    Write a Python object to a property list.
    THIS DOES NOT WRITE NORMALIZED OUTPUT.

    This will only modify the file if the
    file contains data that is different
    from the new data.
    """
    ...

def subpathRenameFile(ufoPath, fromSubpath, toSubpath): # -> None:
    """
    Rename a file.
    """
    ...

def subpathRenameDirectory(ufoPath, fromSubpath, toSubpath): # -> None:
    """
    Rename a directory.
    """
    ...

def subpathRemoveFile(ufoPath, *subpath): # -> None:
    """
    Remove a file.
    """
    ...

def subpathGetModTime(ufoPath, *subpath): # -> float:
    """
    Get the modification time for a file.
    """
    ...

def subpathNeedsRefresh(modTimes, ufoPath, *subPath): # -> Literal[True]:
    """
    Determine if a file needs to be refreshed.
    Returns True if the file's latest modification time is different
    from its previous modification time.
    """
    ...

def storeModTimes(lib, modTimes): # -> None:
    """
    Write the file mod times to the lib.
    """
    ...

def readModTimes(lib): # -> dict[Any, Any]:
    """
    Read the file mod times from the lib.
    """
    ...

def readImagesDirectory(ufoPath): # -> set[Any]:
    """
    Get a listing of all images in the images directory.
    """
    ...

def purgeImagesDirectory(ufoPath, toPurge): # -> None:
    """
    Purge specified images from the images directory.
    """
    ...

def storeImageReferences(lib, imageReferences): # -> None:
    """
    Store the image references.
    """
    ...

def readImageReferences(lib):
    """
    Read the image references.
    """
    ...

illegalCharacters = ...
reservedFileNames = ...
maxFileNameLength = ...
class NameTranslationError(Exception):
    ...


def userNameToFileName(userName, existing=..., prefix=..., suffix=...): # -> str:
    """
    existing should be a case-insensitive list
    of all existing file names.
    """
    ...

def handleClash1(userName, existing=..., prefix=..., suffix=...): # -> str:
    """
    existing must be a case-insensitive list
    of all existing file names.
    """
    ...

def handleClash2(existing=..., prefix=..., suffix=...): # -> str:
    """
    existing must be a case-insensitive list
    of all existing file names.
    """
    ...

def runTests(): # -> bool | Literal[1]:
    ...

if __name__ == "__main__":
    ...
