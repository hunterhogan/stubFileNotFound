"""
This type stub file was generated by pyright.
"""

from enum import IntEnum

"""Convert Glyphs smart components.

Smart components (https://glyphsapp.com/learn/smart-components) are a
feature within Glyphs whereby a component can essentially define its
own private designspace - each master of a component glyph can
define its own axes and masters. When the component is used, instead
of simply scaling or transforming the component, the designer can
*interpolate* the component by specifying the location in the private
designspace.

For example, a font might define a ``_part.serif`` glyph component with
"left width" and "right width" axes, and for each master in the font,
define layers for the ``_part.serif`` at some default left width and
right width, one with an extended left width, and one with an extended
right width, and use the "smart components settings" to assign locations
to these additional layers. (Unlike a full interpolation model, the
locations of smart component layers can only be at the axis extremes.)

We handle smart components by decomposing them and then applying a standard
OpenType interpolation model to adjust the node positions.
"""
class Pole(IntEnum):
    MIN = ...
    MAX = ...


def normalized_location(layer, base_layer): # -> dict[Any, Any]:
    ...

def variation_model(glyph, smart_layers, layer): # -> VariationModel:
    ...

def get_coordinates(layer): # -> GlyphCoordinates:
    ...

def set_coordinates(layer, coords): # -> None:
    ...

def decompose_smart_components_in_layer(self, layer): # -> GSLayer:
    """Decompose any smart components in a layer, returning a new layer with paths.

    This recursively instantiates nested smart components before extracting
    coordinates for interpolation.

    See https://github.com/googlefonts/glyphsLib/issues/1111
    """
    ...

def instantiate_smart_component(self, layer, component, pen): # -> None:
    """Instantiate a smart component by interpolating and drawing to a pointPen."""
    ...

