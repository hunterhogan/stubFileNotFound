"""
This type stub file was generated by pyright.
"""

from typing import Iterable, TYPE_CHECKING
from fontTools.misc.transform import Transform
from glyphsLib import glyphdata
from glyphsLib.classes import GSAnchor, GSComponent, GSFont, GSGlyph, GSLayer

"""Propagating anchors from components to their composites

Glyphs.app has a nice feature where anchors defined in the components
of composite glyphs are copied into the composites themselves. This feature
however is not very extensively documented.
The code here is based off the Rust implementation in fontc:

  https://github.com/googlefonts/fontc/blob/85795bf/glyphs-reader/src/propagate_anchors.rs

The latter is in turn based off the original Objective-C implementation, which was
shared with us privately.
"""
logger = ...
if TYPE_CHECKING:
    ...
def propagate_all_anchors(font: GSFont, *, glyph_data: glyphdata.GlyphData | None = ...) -> None:
    """Copy anchors from component glyphs into their including composites.

    If a custom `glyph_data` is provided, it will be used to override the
    category and subCategory of glyphs.
    """
    ...

def propagate_all_anchors_impl(glyphs: dict[str, GSGlyph], *, glyph_data: glyphdata.GlyphData | None = ...) -> None:
    ...

def maybe_log_new_anchors(anchors: list[GSAnchor], glyph: GSGlyph, layer: GSLayer) -> None:
    ...

def anchors_traversing_components(glyph: GSGlyph, layer: GSLayer, glyphs: dict[str, GSGlyph], done_anchors: dict[str, dict[str, list[GSAnchor]]], base_glyph_counts: dict[(str, str), int], glyph_data: glyphdata.GlyphData | None = ...) -> list[GSAnchor]:
    """Return the anchors for this glyph, including anchors from components

    This function is a reimplmentation of a similarly named function in glyphs.app.

    The logic for copying anchors from components into their containing composites
    is tricky. Anchors need to be adjusted in various ways:

    - a special "*origin" anchor may exist, which modifies the position of other anchors
    - if a component is flipped on the x or y axes, we rename "top" to "bottom"
      and/or "left" to "right"
    - we need to apply the transform from the component
    - we may need to rename an anchor when the component is part of a ligature glyph
    """
    ...

def origin_adjusted_anchors(anchors: list[GSAnchor]) -> Iterable[GSAnchor]:
    """Iterate over anchors taking into account the special "*origin" anchor

    If that anchor is present it will be used to adjust the positions of other
    anchors, and will not be included in the output.
    """
    ...

def get_xy_rotation(xform: Transform) -> tuple[float, float]:
    """Returns (x, y) where a negative value indicates axis is flipped"""
    ...

def apply_transform_to_anchor(anchor: GSAnchor, transform: Transform) -> None:
    """Apply the transform but also do some rounding.

    So we don't have anchors with points like (512, 302.000000006).
    """
    ...

def maybe_rename_component_anchor(comp_name: str, anchors: list[GSAnchor]) -> None:
    ...

def make_liga_anchor_name(name: str, base_number: int) -> str:
    ...

def rename_anchor_for_scale(name: str, xscale: float, yscale: float) -> str:
    """If a component is rotated, flip bottom/top, left/right, entry/exit"""
    ...

def get_component_layer_anchors(component: GSComponent, layer: GSLayer, glyphs: dict[str, GSGlyph], anchors: dict[str, dict[str, list[GSAnchor]]]) -> list[GSAnchor] | None:
    ...

def compute_max_component_depths(glyphs: dict[str, GSGlyph]) -> dict[str, float]:
    ...

def depth_sorted_composite_glyphs(glyphs: dict[str, GSGlyph]) -> list[str]:
    ...

