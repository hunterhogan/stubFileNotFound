from _typeshed import Incomplete

__all__ = ['streamplot']

def streamplot(axes, x, y, u, v, density: int = 1, linewidth: Incomplete | None = None, color: Incomplete | None = None, cmap: Incomplete | None = None, norm: Incomplete | None = None, arrowsize: int = 1, arrowstyle: str = '-|>', minlength: float = 0.1, transform: Incomplete | None = None, zorder: Incomplete | None = None, start_points: Incomplete | None = None, maxlength: float = 4.0, integration_direction: str = 'both', broken_streamlines: bool = True):
    """
    Draw streamlines of a vector flow.

    Parameters
    ----------
    x, y : 1D/2D arrays
        Evenly spaced strictly increasing arrays to make a grid.  If 2D, all
        rows of *x* must be equal and all columns of *y* must be equal; i.e.,
        they must be as if generated by ``np.meshgrid(x_1d, y_1d)``.
    u, v : 2D arrays
        *x* and *y*-velocities. The number of rows and columns must match
        the length of *y* and *x*, respectively.
    density : float or (float, float)
        Controls the closeness of streamlines. When ``density = 1``, the domain
        is divided into a 30x30 grid. *density* linearly scales this grid.
        Each cell in the grid can have, at most, one traversing streamline.
        For different densities in each direction, use a tuple
        (density_x, density_y).
    linewidth : float or 2D array
        The width of the streamlines. With a 2D array the line width can be
        varied across the grid. The array must have the same shape as *u*
        and *v*.
    color : :mpltype:`color` or 2D array
        The streamline color. If given an array, its values are converted to
        colors using *cmap* and *norm*.  The array must have the same shape
        as *u* and *v*.
    cmap, norm
        Data normalization and colormapping parameters for *color*; only used
        if *color* is an array of floats. See `~.Axes.imshow` for a detailed
        description.
    arrowsize : float
        Scaling factor for the arrow size.
    arrowstyle : str
        Arrow style specification.
        See `~matplotlib.patches.FancyArrowPatch`.
    minlength : float
        Minimum length of streamline in axes coordinates.
    start_points : (N, 2) array
        Coordinates of starting points for the streamlines in data coordinates
        (the same coordinates as the *x* and *y* arrays).
    zorder : float
        The zorder of the streamlines and arrows.
        Artists with lower zorder values are drawn first.
    maxlength : float
        Maximum length of streamline in axes coordinates.
    integration_direction : {'forward', 'backward', 'both'}, default: 'both'
        Integrate the streamline in forward, backward or both directions.
    data : indexable object, optional
        DATA_PARAMETER_PLACEHOLDER
    broken_streamlines : boolean, default: True
        If False, forces streamlines to continue until they
        leave the plot domain.  If True, they may be terminated if they
        come too close to another streamline.

    Returns
    -------
    StreamplotSet
        Container object with attributes

        - ``lines``: `.LineCollection` of streamlines

        - ``arrows``: `.PatchCollection` containing `.FancyArrowPatch`
          objects representing the arrows half-way along streamlines.

        This container will probably change in the future to allow changes
        to the colormap, alpha, etc. for both lines and arrows, but these
        changes should be backward compatible.
    """

class StreamplotSet:
    lines: Incomplete
    arrows: Incomplete
    def __init__(self, lines, arrows) -> None: ...

class DomainMap:
    """
    Map representing different coordinate systems.

    Coordinate definitions:

    * axes-coordinates goes from 0 to 1 in the domain.
    * data-coordinates are specified by the input x-y coordinates.
    * grid-coordinates goes from 0 to N and 0 to M for an N x M grid,
      where N and M match the shape of the input data.
    * mask-coordinates goes from 0 to N and 0 to M for an N x M mask,
      where N and M are user-specified to control the density of streamlines.

    This class also has methods for adding trajectories to the StreamMask.
    Before adding a trajectory, run `start_trajectory` to keep track of regions
    crossed by a given trajectory. Later, if you decide the trajectory is bad
    (e.g., if the trajectory is very short) just call `undo_trajectory`.
    """
    grid: Incomplete
    mask: Incomplete
    x_grid2mask: Incomplete
    y_grid2mask: Incomplete
    x_mask2grid: Incomplete
    y_mask2grid: Incomplete
    x_data2grid: Incomplete
    y_data2grid: Incomplete
    def __init__(self, grid, mask) -> None: ...
    def grid2mask(self, xi, yi):
        """Return nearest space in mask-coords from given grid-coords."""
    def mask2grid(self, xm, ym): ...
    def data2grid(self, xd, yd): ...
    def grid2data(self, xg, yg): ...
    def start_trajectory(self, xg, yg, broken_streamlines: bool = True) -> None: ...
    def reset_start_point(self, xg, yg) -> None: ...
    def update_trajectory(self, xg, yg, broken_streamlines: bool = True) -> None: ...
    def undo_trajectory(self) -> None: ...

class Grid:
    """Grid of data."""
    nx: Incomplete
    ny: Incomplete
    dx: Incomplete
    dy: Incomplete
    x_origin: Incomplete
    y_origin: Incomplete
    width: Incomplete
    height: Incomplete
    def __init__(self, x, y) -> None: ...
    @property
    def shape(self): ...
    def within_grid(self, xi, yi):
        """Return whether (*xi*, *yi*) is a valid index of the grid."""

class StreamMask:
    """
    Mask to keep track of discrete regions crossed by streamlines.

    The resolution of this grid determines the approximate spacing between
    trajectories. Streamlines are only allowed to pass through zeroed cells:
    When a streamline enters a cell, that cell is set to 1, and no new
    streamlines are allowed to enter.
    """
    _mask: Incomplete
    shape: Incomplete
    _current_xy: Incomplete
    def __init__(self, density) -> None: ...
    def __getitem__(self, args): ...
    _traj: Incomplete
    def _start_trajectory(self, xm, ym, broken_streamlines: bool = True) -> None:
        """Start recording streamline trajectory"""
    def _undo_trajectory(self) -> None:
        """Remove current trajectory from mask"""
    def _update_trajectory(self, xm, ym, broken_streamlines: bool = True) -> None:
        """
        Update current trajectory position in mask.

        If the new position has already been filled, raise `InvalidIndexError`.
        """

class InvalidIndexError(Exception): ...
class TerminateTrajectory(Exception): ...
class OutOfBounds(IndexError): ...
