from _typeshed import Incomplete
from abc import ABC, abstractmethod
from collections import OrderedDict
from dataclasses import dataclass
from enum import Enum
from typing import Any
import abc

class CacheEntryStatus(Enum):
    VALID = 'VALID'
    IN_PROGRESS = 'IN_PROGRESS'

class EvictionPolicyType(Enum):
    time_based = 'time_based'
    frequency_based = 'frequency_based'

@dataclass(frozen=True)
class CacheKey:
    command: str
    redis_keys: tuple[Any, ...]

class CacheEntry:
    cache_key: Incomplete
    cache_value: Incomplete
    status: Incomplete
    connection_ref: Incomplete
    def __init__(self, cache_key: CacheKey, cache_value: bytes, status: CacheEntryStatus, connection_ref: Any) -> None: ...
    def __hash__(self) -> Any: ...
    def __eq__(self, other: Any) -> Any: ...

class EvictionPolicyInterface(ABC, metaclass=abc.ABCMeta):
    @property
    @abstractmethod
    def cache(self) -> Any: ...
    @cache.setter
    def cache(self, value: Any) -> Any: ...
    @property
    @abstractmethod
    def type(self) -> EvictionPolicyType: ...
    @abstractmethod
    def evict_next(self) -> CacheKey: ...
    @abstractmethod
    def evict_many(self, count: int) -> list[CacheKey]: ...
    @abstractmethod
    def touch(self, cache_key: CacheKey) -> None: ...

class CacheConfigurationInterface(ABC, metaclass=abc.ABCMeta):
    @abstractmethod
    def get_cache_class(self) -> Any: ...
    @abstractmethod
    def get_max_size(self) -> int: ...
    @abstractmethod
    def get_eviction_policy(self) -> Any: ...
    @abstractmethod
    def is_exceeds_max_size(self, count: int) -> bool: ...
    @abstractmethod
    def is_allowed_to_cache(self, command: str) -> bool: ...

class CacheInterface(ABC, metaclass=abc.ABCMeta):
    @property
    @abstractmethod
    def collection(self) -> OrderedDict[Any, Any]: ...
    @property
    @abstractmethod
    def config(self) -> CacheConfigurationInterface: ...
    @property
    @abstractmethod
    def eviction_policy(self) -> EvictionPolicyInterface: ...
    @property
    @abstractmethod
    def size(self) -> int: ...
    @abstractmethod
    def get(self, key: CacheKey) -> CacheEntry | None: ...
    @abstractmethod
    def set(self, entry: CacheEntry) -> bool: ...
    @abstractmethod
    def delete_by_cache_keys(self, cache_keys: list[CacheKey]) -> list[bool]: ...
    @abstractmethod
    def delete_by_redis_keys(self, redis_keys: list[bytes]) -> list[bool]: ...
    @abstractmethod
    def flush(self) -> int: ...
    @abstractmethod
    def is_cachable(self, key: CacheKey) -> bool: ...

class DefaultCache(CacheInterface):
    _cache: Incomplete
    _cache_config: Incomplete
    _eviction_policy: Incomplete
    def __init__(self, cache_config: CacheConfigurationInterface) -> None: ...
    @property
    def collection(self) -> OrderedDict[Any, Any]: ...
    @property
    def config(self) -> CacheConfigurationInterface: ...
    @property
    def eviction_policy(self) -> EvictionPolicyInterface: ...
    @property
    def size(self) -> int: ...
    def set(self, entry: CacheEntry) -> bool: ...
    def get(self, key: CacheKey) -> CacheEntry | None: ...
    def delete_by_cache_keys(self, cache_keys: list[CacheKey]) -> list[bool]: ...
    def delete_by_redis_keys(self, redis_keys: list[bytes]) -> list[bool]: ...
    def flush(self) -> int: ...
    def is_cachable(self, key: CacheKey) -> bool: ...

class LRUPolicy(EvictionPolicyInterface):
    def __init__(self) -> None: ...
    @property
    def cache(self) -> Any: ...
    _cache: Incomplete
    @cache.setter
    def cache(self, cache: CacheInterface) -> Any: ... # pyright: ignore[reportIncompatibleMethodOverride]
    @property
    def type(self) -> EvictionPolicyType: ...
    def evict_next(self) -> CacheKey: ...
    def evict_many(self, count: int) -> list[CacheKey]: ...
    def touch(self, cache_key: CacheKey) -> None: ...
    def _assert_cache(self) -> None: ...

class EvictionPolicy(Enum):
    LRU = LRUPolicy

class CacheConfig(CacheConfigurationInterface):
    DEFAULT_CACHE_CLASS = DefaultCache
    DEFAULT_EVICTION_POLICY: Incomplete
    DEFAULT_MAX_SIZE: int
    DEFAULT_ALLOW_LIST: Incomplete
    _cache_class: Incomplete
    _max_size: Incomplete
    _eviction_policy: Incomplete
    def __init__(self, max_size: int = ..., cache_class: Any = ..., eviction_policy: EvictionPolicy = ...) -> None: ...
    def get_cache_class(self) -> Any: ...
    def get_max_size(self) -> int: ...
    def get_eviction_policy(self) -> EvictionPolicy: ...
    def is_exceeds_max_size(self, count: int) -> bool: ...
    def is_allowed_to_cache(self, command: str) -> bool: ...

class CacheFactoryInterface(ABC, metaclass=abc.ABCMeta):
    @abstractmethod
    def get_cache(self) -> CacheInterface: ...

class CacheFactory(CacheFactoryInterface):
    _config: Incomplete
    def __init__(self, cache_config: CacheConfig | None = None) -> None: ...
    def get_cache(self) -> CacheInterface: ...
