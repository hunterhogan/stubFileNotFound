"""
This type stub file was generated by pyright.
"""

import sys
from typing import Any, Mapping, NamedTuple
from fontTools.designspaceLib import DesignSpaceDocument

logger = ...
def makeOfficialGlyphOrder(font, glyphOrder=...): # -> list[Any]:
    """Make the final glyph order for 'font'.

    If glyphOrder is None, try getting the font.glyphOrder list.
    If not explicit glyphOrder is defined, sort glyphs alphabetically.

    If ".notdef" glyph is present in the font, force this to always be
    the first glyph (at index 0).
    """
    ...

def decomposeCompositeGlyph(glyph, glyphSet, skipMissing=..., reverseFlipped=..., include=..., decomposeNested=...): # -> None:
    """Decompose composite glyph in-place resolving references from glyphSet."""
    ...

class _GlyphSet(dict):
    @classmethod
    def from_layer(cls, font, layerName=..., copy=..., skipExportGlyphs=...): # -> Self:
        """Return a mapping of glyph names to glyph objects from `font`."""
        ...
    


def deepCopyContours(glyphSet, parent, composite, transformation, specificComponents=...): # -> None:
    """Copy contours from component to parent, including nested components.

    specificComponent: an optional list of glyph name strings. If not passed or
    None, decompose all components of a glyph unconditionally and completely. If
    passed, only completely decompose components whose baseGlyph is in the list.
    """
    ...

def makeUnicodeToGlyphNameMapping(font, glyphOrder=...): # -> dict[Any, Any]:
    """Make a unicode: glyph name mapping for this glyph set (dict or Font).

    Raises InvalidFontData exception if multiple glyphs are mapped to the
    same unicode codepoint.
    """
    ...

def compileGSUB(featureFile, glyphOrder, fvar=...): # -> table_G_S_U_B_ | None:
    """Compile and return a GSUB table from `featureFile` (feaLib
    FeatureFile), using the given `glyphOrder` (list of glyph names).
    """
    ...

def compileGDEF(featureFile, glyphOrder): # -> table_G_D_E_F_ | None:
    """Compile and return a GDEF table from `featureFile` (feaLib FeatureFile),
    using the given `glyphOrder` (list of glyph names).
    """
    ...

def closeGlyphsOverGSUB(gsub, glyphs): # -> None:
    """Use the FontTools subsetter to perform a closure over the GSUB table
    given the initial `glyphs` (set of glyph names, str). Update the set
    in-place adding all the glyph names that can be reached via GSUB
    substitutions from this initial set.
    """
    ...

def classifyGlyphs(unicodeFunc, cmap, gsub=..., extra_substitutions=...): # -> dict[Any, Any]:
    """'unicodeFunc' is a callable that takes a Unicode codepoint and
    returns a string, or collection of strings, denoting some Unicode
    property associated with the given character (or None if a character
    is considered 'neutral'). 'cmap' is a dictionary mapping Unicode
    codepoints to glyph names. 'gsub' is an (optional) fonttools GSUB
    table object, used to find all the glyphs that are "reachable" via
    substitutions from the initial sets of glyphs defined in the cmap.
    'extra_substitutions' is an optional dictionary mapping glyph names
    to a set of other glyphs which should be considered reachable from them
    (for example when using designspace rules to effect substitutions).

    Returns a dictionary of glyph sets associated with the given Unicode
    properties.
    """
    ...

def unicodeInScripts(uv, scripts): # -> bool | None:
    """Check UnicodeData's ScriptExtension property for unicode codepoint
    'uv' and return True if it intersects with the set of 'scripts' provided,
    False if it does not intersect.
    Return None for 'Common' script ('Zyyy').
    """
    ...

DFLT_SCRIPTS = ...
def unicodeScriptDirection(uv): # -> str | None:
    ...

class _LazyFontName:
    def __init__(self, font) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    


def getDefaultMasterFont(designSpaceDoc):
    ...

_pluginSpecRE = ...
def quantize(number, factor):
    """Round to a multiple of the given parameter"""
    ...

def otRoundIgnoringVariable(number):
    ...

def init_kwargs(kwargs, defaults): # -> dict[Any, Any]:
    """Initialise kwargs default values.

    To be used as the first function in top-level `ufo2ft.compile*` functions.

    Raise TypeError with unexpected keyword arguments (missing from 'defaults').
    """
    ...

def prune_unknown_kwargs(kwargs, *callables): # -> dict[Any, Any]:
    """Inspect callables and return a new dict skipping any unknown arguments.

    To be used after `init_kwargs` to narrow down arguments for underlying code.
    """
    ...

def ensure_all_sources_have_names(doc: DesignSpaceDocument) -> None:
    """Change in-place the given document to make sure that all <source> elements
    have a unique name assigned.

    This may rename sources with a "temp_master.N" name, designspaceLib's default
    stand-in.
    """
    ...

def getMaxComponentDepth(glyph, glyphSet, maxComponentDepth=..., visited=..., rec_stack=...): # -> int:
    """Return the height of a composite glyph's tree of components.

    This is equal to the depth of its deepest node, where the depth
    means the number of edges (component references) from the node
    to the tree's root.

    For glyphs that contain no components, only contours, this is 0.
    Composite glyphs have max component depth of 1 or greater.

    Raises InvalidFontData if a cyclical component reference is detected.
    """
    ...

def location_to_string(location): # -> str:
    """Reports a designspace location (dictionary mapping axis:loc)
    in a user-friendly way"""
    ...

def unicodeScriptExtensions(codepoint: int, aliases: Mapping[str, str] = ...) -> set[str]:
    """Returns the Unicode script extensions for a codepoint, optionally
    aliasing some scripts.

    This allows lookups to contain more than one script. The most prominent case
    is being able to kern Hiragana and Katakana against each other, Unicode
    defines "Hrkt" as an alias for both scripts.
    """
    ...

def describe_ufo(ufo: Any) -> str:
    """Returns a description of a UFO suitable for logging."""
    ...

def colrClipBoxQuantization(ufo: Any) -> int:
    """Integer value to quantize COLR ClipBoxes.

    The higher the value, the greater the chances that that same clipboxes get
    reused for multiple color glyphs.
    This is only called when compile option `colrAutoClipBoxes` is True.

    By default, we quantize to 1/10th of the font's upem, rounded to nearest
    multiple of 10: e.g. 100 unit intervals for 1000 upem, 200 units for 2048 etc.

    The caller can pass their own callback function to return a different value
    than the default one.
    """
    ...

def get_userspace_location(designspace, location): # -> dict[Any, Any]:
    """Map a location from designspace to userspace across all axes."""
    ...

def collapse_varscalar(varscalar, threshold=...):
    """Collapse a variable scalar to a plain scalar if all values are similar"""
    ...

class OpenTypeCategories(NamedTuple):
    unassigned: frozenset[str]
    base: frozenset[str]
    ligature: frozenset[str]
    mark: frozenset[str]
    component: frozenset[str]
    @classmethod
    def load(cls, font): # -> Self:
        """Return 'public.openTypeCategories' values as a tuple of sets of
        unassigned, bases, ligatures, marks, components."""
        ...
    


def importUfoModule(): # -> Any:
    ...

def openFontFactory(*, ufo_module=...): # -> Callable[..., Font | Any] | type[Font]:
    ...

def openFont(*args, ufo_module=..., **kwargs): # -> Font:
    ...

if sys.version_info[: 2] < (3, 10):
    def zip_strict(*iterables): # -> Generator[tuple[Any, ...], Any, None]:
        ...
    
else:
    zip_strict = ...
