"""
This type stub file was generated by pyright.
"""

from ufo2ft.featureWriters import BaseFeatureWriter

class AbstractMarkPos:
    """Object containing all the mark attachments for glyph 'name'.
    The 'marks' is a list of NamedAnchor objects.
    Provides methods to filter marks given some callable, and convert
    itself to feaLib AST 'pos' statements for mark2base, mark2liga and
    mark2mark lookups.
    """
    Statement = ...
    def __init__(self, name, marks) -> None:
        ...
    
    def asAST(self):
        ...
    
    def __str__(self) -> str:
        ...
    
    def filter(self, include): # -> Self | None:
        ...
    
    def getMarkGlyphToMarkClasses(self): # -> dict_items[Any, set[Any]]:
        """Return a list of pairs (markGlyph, markClasses)."""
        ...
    


class MarkToBasePos(AbstractMarkPos):
    Statement = ...


class MarkToMarkPos(AbstractMarkPos):
    Statement = ...


class MarkToLigaPos(AbstractMarkPos):
    Statement = ...
    def getMarkGlyphToMarkClasses(self): # -> dict_items[Any, set[Any]]:
        """Return a list of pairs (markGlyph, markClasses)."""
        ...
    


LIGA_SEPARATOR = ...
LIGA_NUM_RE = ...
def parseAnchorName(anchorName, markPrefix=..., ligaSeparator=..., ligaNumRE=..., ignoreRE=..., libData=...): # -> tuple[bool, Any | str, int | None, bool, Any | bool | Literal['']]:
    """Parse anchor name and return a tuple that specifies:
    1) whether the anchor is a "mark" anchor (bool);
    2) the "key" name of the anchor, i.e. the name after stripping all the
       prefixes and suffixes, which identifies the class it belongs to (str);
    3) An optional number (int), starting from 1, which identifies that index
       of the ligature component the anchor refers to.

    The 'ignoreRE' argument is an optional regex pattern (str) identifying
    sub-strings in the anchor name that should be ignored when parsing the
    three elements above.
    """
    ...

class NamedAnchor:
    """A position with a name, and an associated markClass."""
    __slots__ = ...
    markPrefix = ...
    ignoreRE = ...
    ligaSeparator = ...
    ligaNumRE = ...
    def __init__(self, name, x, y, markClass=..., libData=...) -> None:
        ...
    
    @property
    def markAnchorName(self): # -> str:
        ...
    
    def __repr__(self): # -> str:
        ...
    


def colorGraph(adjacency): # -> list[list[Any]]:
    """Color the graph defined by the provided adjacency lists.
    The input is a dict of iterables. Each entry of the dict is one vertex,
    and the value is a list of neighbours of that vertex.
    The input graph is expected to be undirected and the input should reflect
    that (have symmetric adjacency for A -> B and B -> A).
    Vertices that don't have neighbours should still be present in the input.

    The output is a list of lists, each list being one color assignment,
    and its members being vertices.
    """
    ...

def firstAvailable(colorSet): # -> int:
    """Return smallest non-negative integer not in the given set of colors."""
    ...

class MarkFeatureWriter(BaseFeatureWriter):
    """Generates a mark, mkmk, abvm and blwm features based on glyph anchors.

    The default mode is 'skip': i.e. if any of the supported features is
    already present in the feature file, it is not generated again.

    The optional 'append' mode will add extra lookups to already existing
    features, if any. New markClass definitions with unique names are
    generated when the mark anchors from UFO glyphs are different from those
    already defined in the feature file, otherwise the existing markClass
    definitions are reused in the newly appended lookups.

    Anchors prefixed with "_" are considered mark anchors; any glyph
    containing those is as such considered a mark glyph, thus added to
    markClass definitions, and in mark-to-mark lookups (if the glyph also
    contains other non-underscore-prefixed anchors).

    Anchors suffixed with a number, e.g. "top_1", "bottom_2", etc., are used
    for ligature glyphs. The number refers to the index (counting from 1) of
    the ligature component where the mark is meant to be attached.

    It is possible that a ligature component has no marks defined, in which
    case one can have an anchor with an empty name and only the number (e.g.
    '_3'), which is encoded as '<anchor NULL>' in the generated 'pos ligature'
    statement.

    If the glyph set contains glyphs whose unicode codepoint's script extension
    property intersects with one of the scripts which are processed by the Indic,
    USE, or Khmer complex shapers, then the "abvm" and "blwm" features are also
    generated for those glyphs, as well as for alternate glyphs only accessible
    via GSUB substitutions.

    The "abvm" (above-base marks) and "blwm" (below-base marks) features
    include all mark2base, mark2liga and mark2mark attachments for Indic/USE/Khmer
    glyphs containing anchors from predefined lists of "above" and "below" anchor
    names (see below). If these glyphs contain anchors with names not in those
    lists, the anchors' vertical position relative to the half of the UPEM
    square is used to decide whether they are considered above or below.

    If the `quantization` argument is given in the filter options, the resulting
    anchors are rounded to the nearest multiple of the quantization value.

    If `groupMarkClases=True`, mark-to-base or mark-to-ligature attachments that
    reference non-overlapping mark classes will get grouped in the same lookup; and
    if a mark glyph is in more than one mark class, additional lookups will be generated
    for those as required. NOTE: this was the default behavior until ufo2ft 2.33.4.
    The current default behavior was simplified to match other font editors and
    we now build as many mark-to-base and mark-to-liga lookups as there
    are mark classes, and lookups are sorted alphabetically by the mark class
    name so the more specific ('top.alt' instead 'top') would be applied last and
    wins in case when the same base or ligature glyph can attach to the same mark
    through multiple mark classes.
    https://github.com/googlefonts/ufo2ft/issues/591
    """
    options = ...
    tableTag = ...
    features = ...
    NamedAnchor = NamedAnchor
    markClassPrefix = ...
    abvmAnchorNames = ...
    blwmAnchorNames = ...
    scriptsUsingAbvm = ...
    anchorSortKey = ...
    def setContext(self, font, feaFile, compiler=...): # -> None:
        ...
    
    def shouldContinue(self): # -> bool:
        ...
    


