"""
This type stub file was generated by pyright.
"""

INSERT_FEATURE_MARKER = ...
class BaseFeatureWriter:
    """Abstract features writer.

    The `tableTag` class attribute (str) states the tag of the OpenType
    Layout table which the generated features are intended for.
    For example: "GPOS", "GSUB", "BASE", etc.

    The `features` class attribute defines the set of all the features
    that this writer supports. If you want to only write some of the
    available features you can provide a smaller sequence to 'features'
    constructor argument. By the default all the features supported by
    this writer will be outputted.

    Two writing modes are defined here:
    1) "skip" (default) will not write features if already present;
    2) "append" will add additional lookups to an existing feature,
       if present, or it will add a new one at the end of all features.
    Subclasses can set a different default mode or define a different
    set of `_SUPPORTED_MODES`.

    The `options` class attribute contains a mapping of option
    names with their default values. These can be overridden on an
    instance by passing keyword arguments to the constructor.

    Combining manually written and automatically generated feature code
    can be achieved by using the `# Automatic Code` insertion marker
    inside the feature code. Automatically generated code for the
    respective feature is added in that spot.
    """
    tableTag = ...
    features = ...
    mode = ...
    insertFeatureMarker = ...
    options = ...
    _SUPPORTED_MODES = ...
    def __init__(self, features=..., mode=..., **kwargs) -> None:
        ...
    
    def setContext(self, font, feaFile, compiler=...): # -> SimpleNamespace:
        """Populate a temporary `self.context` namespace, which is reset
        after each new call to `_write` method.
        Subclasses can override this to provide contextual information
        which depends on other data, or set any temporary attributes.

        The default implementation sets:
        - the current font;
        - the current FeatureFile object;
        - the current compiler instance (only present when this writer was
          instantiated from a FeatureCompiler);
        - a set of features (tags) to be generated. If self.mode is "skip",
          these are all the features which are _not_ already present.
        - a set of all existing features (tags) in the feaFile.

        Returns the context namespace instance.
        """
        ...
    
    def shouldContinue(self): # -> bool:
        """Decide whether to start generating features or return early.
        Returns a boolean: True to proceed, False to skip.

        Sublcasses may override this to skip generation based on the presence
        or lack of other required pieces of font data.
        """
        ...
    
    def write(self, font, feaFile, compiler=...): # -> Literal[False]:
        """Write features and class definitions for this font to a feaLib
        FeatureFile object.

        The main entry point for the FeatureCompiler to any of the
        FeatureWriters.

        Returns True if feature file was modified, False if no new features were
        generated.
        """
        ...
    
    @staticmethod
    def collectInsertMarkers(feaFile, insertFeatureMarker, featureTags): # -> dict[Any, Any]:
        """
        Returns a dictionary of tuples (block, comment) keyed by feature tag
        with the block that contains the comment matching the insert feature
        marker, for given feature tags.
        """
        ...
    
    def makeUnicodeToGlyphNameMapping(self): # -> dict[Any, Any] | Any:
        """Return the Unicode to glyph name mapping for the current font."""
        ...
    
    def getOrderedGlyphSet(self): # -> Any | OrderedDict[Any, Any]:
        """Return OrderedDict[glyphName, glyph] sorted by glyphOrder."""
        ...
    
    def compileGSUB(self): # -> Any | table_G_S_U_B_ | None:
        """Compile a temporary GSUB table from the current feature file."""
        ...
    
    def extraSubstitutions(self): # -> Any | None:
        ...
    
    def getOpenTypeCategories(self): # -> OpenTypeCategories:
        """Return 'public.openTypeCategories' values as a tuple of sets of
        unassigned, bases, ligatures, marks, components."""
        ...
    
    def getGDEFGlyphClasses(self): # -> _GDEFGlyphClasses:
        """Return a tuple of GDEF GlyphClassDef base, ligature, mark, component
        glyph names.
        Sets are `None` if no 'public.openTypeCategories' values are defined or
        if no GDEF table is defined in the feature file.
        """
        ...
    
    def guessFontScripts(self): # -> set[Any]:
        """Returns a set of scripts the font probably supports.

        This is done by:

        1. Looking at all defined codepoints in a font and remembering the
           script of any of the codepoints if it is associated with just one
           script. This would remember the script of U+0780 THAANA LETTER HAA
           (Thaa) but not U+061F ARABIC QUESTION MARK (multiple scripts).
        2. Adding explicitly declared `languagesystem` scripts on top.
        """
        ...
    


