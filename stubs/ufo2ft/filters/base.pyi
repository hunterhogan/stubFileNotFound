"""
This type stub file was generated by pyright.
"""

from types import SimpleNamespace
from typing import Any, FrozenSet, TYPE_CHECKING, Tuple, TypeAlias
from ufoLib2.objects import Font, Glyph
from ufo2ft.instantiator import Instantiator, InterpolatedLayer

if TYPE_CHECKING:
    ...
logger = ...
timing_logger = ...
class BaseFilter:
    _args = ...
    _kwargs = ...
    _pre = ...
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def start(self): # -> None:
        """Subclasses can perform here custom initialization code."""
        ...
    
    def set_context(self, font, glyphSet): # -> SimpleNamespace:
        """Populate a `self.context` namespace, which is reset before each
        new filter call.

        Subclasses can override this to provide contextual information
        which depends on other data in the font that is not available in
        the glyphs objects currently being filtered, or set any other
        temporary attributes.

        The default implementation simply sets the current font and glyphSet,
        and initializes an empty set that keeps track of the names of the
        glyphs that were modified.

        Returns the namespace instance.
        """
        ...
    
    def filter(self, glyph):
        """This is where the filter is applied to a single glyph.
        Subclasses must override this method, and return True
        when the glyph was modified.
        """
        ...
    
    @property
    def name(self): # -> str:
        ...
    
    def __call__(self, font, glyphSet=...): # -> Any:
        """Run this filter on all the included glyphs.
        Return the set of glyph names that were modified, if any.

        If `glyphSet` (dict) argument is provided, run the filter on
        the glyphs contained therein (which may be copies).
        Otherwise, run the filter in-place on the font's default
        glyph set.
        """
        ...
    
    @classmethod
    def getInterpolatableFilterClass(cls) -> BaseIFilter | None:
        """Return interpolatable filter class if one is found in the same module.

        We search for a class with the same name and the 'IFilter' suffix
        (where the 'I' stands for "interpolatable").

        Subclasses can override this if they wish to use a different class name
        or module.
        """
        ...
    


HashableLocation: TypeAlias = FrozenSet[Tuple[str, float]]
class BaseIFilter(BaseFilter):
    """Interpolatable variant that zips through mutliple glyphs at a time."""
    def set_context(self, fonts: list[Font], glyphSets: list[dict[str, Glyph]], instantiator: Instantiator | None = ..., **kwargs: dict[str, Any]) -> SimpleNamespace:
        """Populate a `self.context` namespace, which is reset before each
        new filter call.

        Subclasses can override this to provide contextual information
        which depends on other data in the fonts that is not available in
        the glyphs objects currently being filtered, or set any other
        temporary attributes.

        The default implementation simply sets the current fonts, glyphSets,
        and optional instantiator and initializes an empty set that keeps track
        of the names of the glyphs that were modified.

        Any extra keyword arguments are passed to the context namespace.

        Returns the namespace instance.
        """
        ...
    
    def filter(self, glyphName: str, glyphs: list) -> bool:
        """This is where the filter is applied to a set of interpolatable glyphs.

        Subclasses must override this method, and return True
        when the glyph was modified.
        """
        ...
    
    def __call__(self, fonts: list[Font], glyphSets: list[dict[str, Glyph]] | None = ..., instantiator: Instantiator | None = ..., **kwargs: dict[str, Any]) -> set[str]:
        """Run this filter on all the included glyphs from the given glyphSets.
        Return the set of glyph names that were modified, if any.

        If `glyphSets` (list[dict]) argument is provided, run the filter on
        the glyphs contained therein (which may be copies).
        Otherwise, run the filter in-place on the fonts' default
        glyph sets.

        The `instantiator` optional argument allows interpolatable filters to
        generate glyph instances on demand at any location in the designspace.

        Any extra keyword arguments are passed on to the `set_context` method.
        """
        ...
    
    @classmethod
    def getInterpolatableFilterClass(cls) -> BaseIFilter | None:
        """Return the same class as self."""
        ...
    
    def getDefaultFont(self) -> Font:
        ...
    
    def getDefaultGlyphSet(self) -> dict[str, Glyph]:
        """Return the current glyphSet corresponding to the default location."""
        ...
    
    def getInterpolatedLayers(self) -> list[InterpolatedLayer] | list[None]:
        """Return InterpolatedLayers at source locations or Nones if no Instantiator."""
        ...
    
    @staticmethod
    def hashableLocation(location: dict[str, float]) -> HashableLocation:
        """Convert (normalized) location dict to a hashable set of tuples."""
        ...
    
    def glyphSourceLocations(self, glyphName) -> set[HashableLocation]:
        """Return locations of all the sources that have a glyph."""
        ...
    
    def locationsFromComponentGlyphs(self, glyphName: str, include: set[str] | None = ...) -> set[HashableLocation]:
        """Return locations from all the components' base glyphs, recursively."""
        ...
    
    def ensureCompositeDefinedAtComponentLocations(self, glyphName: str, include: set[str] | None = ...): # -> None:
        """Ensure the composite glyph is defined at all its components' locations.

        The Instantiator is used to interpolate the glyph at the missing locations.
        If we have no Instantiator, we can't interpolate so this does nothing.
        """
        ...
    


