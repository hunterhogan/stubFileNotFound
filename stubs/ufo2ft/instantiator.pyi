"""
This type stub file was generated by pyright.
"""

import fontMath
from dataclasses import dataclass
from functools import cached_property
from typing import Any, Callable, Dict, List, Mapping, Optional, TYPE_CHECKING, Tuple, Union
from fontTools import designspaceLib, varLib
from collections.abc import Iterable, KeysView
from ufoLib2.objects import Font, Glyph, Info

"""Module for generating static font instances.

It is an alternative to ufoProcessor originally meant to be used internally by fontmake.
The aim is to be a minimal implementation that is focussed on using ufoLib2 for font data
abstraction, varLib for instance computation and fontMath as a font data shell for
instance computation directly and exclusively.
"""
if TYPE_CHECKING:
    ...
NameRecordDict = Dict[str, Any]
logger = ...
FontMathObject = Union[fontMath.MathGlyph, fontMath.MathInfo, fontMath.MathKerning]
Location = Mapping[str, float]
LocationKey = Tuple[Tuple[str, float], ...]
AxisBounds = Dict[str, Tuple[float, float, float]]
SourceLayer = Tuple[Location, Dict[str, "Glyph"]]
WDTH_VALUE_TO_OS2_WIDTH_CLASS = ...
UFO_INFO_ATTRIBUTES_TO_COPY_TO_INSTANCES = ...
class InstantiatorError(Exception):
    ...


def process_rules_swaps(rules, location, glyphNames): # -> list[Any]:
    """Apply these rules at this location to these glyphnames
    - rule order matters

    Return a list of (oldName, newName) in the same order as the rules.
    """
    ...

def merge_public_font_info(font: Font, override_public_font_info: Dict[str, Any], instance_location: Location) -> None:
    """Merge the public.fontInfo dict into the font's info object (fontinfo.plist)."""
    ...

@dataclass(frozen=True)
class Instantiator:
    """Data class that holds all necessary information to generate a static
    font instance object at an arbitary location within the design space."""
    axis_bounds: AxisBounds
    source_layers: List[SourceLayer]
    copy_feature_text: str = ...
    copy_nonkerning_groups: Mapping[str, List[str]] = ...
    copy_info: Optional[Info] = ...
    copy_lib: Mapping[str, Any] = ...
    designspace_rules: List[designspaceLib.RuleDescriptor] = ...
    glyph_mutators: Mapping[str, Optional[Variator]] = ...
    info_mutator: Optional[Variator] = ...
    kerning_mutator: Optional[Variator] = ...
    round_geometry: bool = ...
    skip_export_glyphs: List[str] = ...
    designspace_root_lib_font_info: Dict[str, Any] = ...
    special_axes: Mapping[str, designspaceLib.AxisDescriptor] = ...
    default_source_idx: int = ...
    default_design_location: Location = ...
    def __post_init__(self): # -> None:
        ...
    
    @classmethod
    def from_designspace(cls, designspace: designspaceLib.DesignSpaceDocument, round_geometry: bool = ..., do_info=..., do_kerning=..., do_glyphs=...): # -> Self:
        """Instantiates a new data class from a Designspace object."""
        ...
    
    @property
    def axis_order(self): # -> list[str]:
        ...
    
    @property
    def default_source_glyphs(self) -> Dict[str, Glyph]:
        ...
    
    @property
    def glyph_names(self) -> KeysView[str]:
        ...
    
    @property
    def source_locations(self) -> Iterable[Location]:
        ...
    
    def normalize(self, location: Location) -> Location:
        ...
    
    def generate_instance(self, instance: designspaceLib.InstanceDescriptor) -> Font:
        """Generate an interpolated instance font object for an
        InstanceDescriptor."""
        ...
    
    @cached_property
    def glyph_factory(self) -> Callable[[str], Glyph]:
        ...
    
    def new_glyph(self, name: str) -> Glyph:
        ...
    
    def generate_glyph_instance(self, glyph_name: str, normalized_location: Location, output_glyph: Glyph | None = ...) -> Glyph:
        """Generate an instance of a single glyph at the given location.

        The location must be specified using normalized coordinates.
        If output_glyph is None, the instance is generated in a new Glyph object
        and returned. Otherwise, the instance is extracted to the given Glyph object.
        """
        ...
    
    @property
    def interpolated_layers(self) -> list[InterpolatedLayer]:
        """Return one InterpolatedLayer for each source location."""
        ...
    
    def replace_source_layers(self, new_layers: list[dict[str, Glyph]]): # -> None:
        """Replace source layers with `new_layers` and clear the cached glyph models.

        Raises `ValueError` if len(new_layers) != len(self.source_layers).
        """
        ...
    


def location_to_key(location: Location) -> LocationKey:
    """Converts a Location into a sorted tuple so it can be used as a dict
    key."""
    ...

def anisotropic(location: Location) -> bool:
    """Tests if any single location value is a MutatorMath-style anisotropic
    value, i.e. is a tuple of (x, y)."""
    ...

def collect_info_masters(designspace: designspaceLib.DesignSpaceDocument, axis_bounds: AxisBounds) -> List[Tuple[Location, FontMathObject]]:
    """Return master Info objects wrapped by MathInfo."""
    ...

def collect_kerning_masters(designspace: designspaceLib.DesignSpaceDocument, axis_bounds: AxisBounds) -> List[Tuple[Location, FontMathObject]]:
    """Return master kerning objects wrapped by MathKerning."""
    ...

def collect_glyph_masters(source_layers: List[SourceLayer], glyph_name: str, axis_bounds: AxisBounds, default_source_idx: int) -> List[Tuple[Location, FontMathObject]]:
    """Return master glyph objects for glyph_name wrapped by MathGlyph.

    Note: skips empty source glyphs if the default glyph is not empty to almost match
    what ufoProcessor is doing. In e.g. Mutator Sans, the 'S.closed' glyph is left
    empty in one source layer. One could treat this as a source error, but ufoProcessor
    specifically has code to skip that empty glyph and carry on.
    """
    ...

def width_class_from_wdth_value(wdth_user_value) -> int:
    """Return the OS/2 width class from the wdth axis user value.

    The OpenType 1.8.3 specification states:

        When mapping from 'wdth' values to usWidthClass, interpolate fractional
        values between the mapped values and then round, and clamp to the range
        1 to 9.

    "Mapped values" probably means the in-percent numbers layed out for the OS/2
    width class, so we are forcing these numerical semantics on the user values
    of the wdth axis.
    """
    ...

def weight_class_from_wght_value(wght_user_value) -> int:
    """Return the OS/2 weight class from the wght axis user value."""
    ...

def italic_angle_from_slnt_value(slnt_user_value) -> Union[int, float]:
    """Return the italic angle from the slnt axis user value."""
    ...

def swap_glyph_names(font: Any, name_old: str, name_new: str): # -> None:
    """Swap two existing glyphs in the default layer of a font (outlines,
    width, component references, kerning references, group membership).

    The idea behind swapping instead of overwriting is explained in
    https://github.com/fonttools/fonttools/tree/main/Doc/source/designspaceLib#ufo-instances.
    We need to keep the old glyph around in case any other glyph references
    it; glyphs that are not explicitly substituted by rules should not be
    affected by the rule application.

    The .unicodes are not swapped. The rules mechanism is supposed to swap
    glyphs, not characters.
    """
    ...

@dataclass(frozen=True)
class Variator:
    """A middle-man class that ingests a mapping of normalized locations to
    masters plus axis definitions and uses varLib to spit out interpolated
    instances at specified normalized locations.

    fontMath objects stand in for the actual master objects from the
    UFO. Upon generating an instance, these objects have to be extracted
    into an actual UFO object.
    """
    masters: List[FontMathObject]
    location_to_master: Mapping[LocationKey, FontMathObject]
    model: varLib.models.VariationModel
    @classmethod
    def from_masters(cls, items: List[Tuple[Location, FontMathObject]], axis_order: List[str]): # -> Self:
        ...
    
    def instance_at(self, normalized_location: Location) -> FontMathObject:
        """Return a FontMathObject for the specified location ready to be
        inflated.

        If an instance location matches a master location, this method
        returns the master data instead of running through varLib. This
        is both an optimization _and_ it enables having a Designspace
        with instances matching their masters without requiring them to
        be compatible. Glyphs.app works this way; it will only generate
        a font from an instance, but compatibility is only required if
        there is actual interpolation to be done. This enables us to
        store incompatible bare masters in one Designspace and having
        arbitrary instance data applied to them.
        """
        ...
    
    def is_static_font(self): # -> bool:
        ...
    


@dataclass(frozen=True, repr=False)
class InterpolatedLayer(Mapping):
    """Mapping of glyphs keyed by name, interpolated on demand.

    If the given location corresponds to one of the source layers, and the
    latter contains the glyph, this is used directly; otherwise, a new glyph
    instance is generated on-the-fly at that location, and cached for subsequent
    retrieval.

    This is useful for APIs that expect a dict of glyphs for resolving component
    references, e.g. FontTools pens.
    """
    instantiator: Instantiator
    location: Location
    source_layer: dict[str, Glyph] | None = ...
    _cache: dict[str, Glyph] = ...
    @cached_property
    def normalized_location(self): # -> Location:
        ...
    
    def __iter__(self) -> Iterable[str]:
        ...
    
    def __len__(self) -> int:
        ...
    
    def __getitem__(self, glyph_name: str) -> Glyph:
        ...
    
    def __repr__(self): # -> str:
        ...
    


