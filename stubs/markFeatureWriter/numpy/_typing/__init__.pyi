"""
This type stub file was generated by pyright.
"""

import numpy as np
from _typeshed import Incomplete
from types import EllipsisType
from typing import Any, Generic, Literal, LiteralString, Never, NoReturn, Protocol, SupportsIndex, TypeAlias, TypeVar, TypedDict, Unpack, overload, type_check_only
from numpy import _CastingKind, _OrderKACF, ufunc
from numpy.typing import NDArray
from ._array_like import ArrayLike, _ArrayLikeBool_co, _ArrayLikeInt_co
from ._dtype_like import DTypeLike
from ._scalars import _ScalarLike_co
from ._shape import _ShapeLike

"""A module with private type-check-only `numpy.ufunc` subclasses.

The signatures of the ufuncs are too varied to reasonably type
with a single class. So instead, `ufunc` has been expanded into
four private subclasses, one for each combination of
`~ufunc.nin` and `~ufunc.nout`.
"""
_T = TypeVar("_T")
_2Tuple: TypeAlias = tuple[_T, _T]
_3Tuple: TypeAlias = tuple[_T, _T, _T]
_4Tuple: TypeAlias = tuple[_T, _T, _T, _T]
_2PTuple: TypeAlias = tuple[_T, _T, *tuple[_T, ...]]
_3PTuple: TypeAlias = tuple[_T, _T, _T, *tuple[_T, ...]]
_4PTuple: TypeAlias = tuple[_T, _T, _T, _T, *tuple[_T, ...]]
_NTypes = TypeVar("_NTypes", bound=int, covariant=True)
_IDType = TypeVar("_IDType", covariant=True)
_NameType = TypeVar("_NameType", bound=LiteralString, covariant=True)
_Signature = TypeVar("_Signature", bound=LiteralString, covariant=True)
_NIn = TypeVar("_NIn", bound=int, covariant=True)
_NOut = TypeVar("_NOut", bound=int, covariant=True)
_ReturnType_co = TypeVar("_ReturnType_co", covariant=True)
_ArrayT = TypeVar("_ArrayT", bound=np.ndarray)
@type_check_only
class _SupportsArrayUFunc(Protocol):
    def __array_ufunc__(self, ufunc: ufunc, method: Literal["__call__", "reduce", "reduceat", "accumulate", "outer", "at"], *inputs: Any, **kwargs: Any) -> Any:
        ...
    


@type_check_only
class _UFunc3Kwargs(TypedDict, total=False):
    where: _ArrayLikeBool_co | None
    casting: _CastingKind
    order: _OrderKACF
    subok: bool
    signature: _3Tuple[str | None] | str | None
    ...


@type_check_only
class _ReduceKwargs(TypedDict, total=False):
    initial: Incomplete
    where: _ArrayLikeBool_co | None
    ...


@type_check_only
class _UFunc_Nin1_Nout1(ufunc, Generic[_NameType, _NTypes, _IDType]):
    @property
    def __name__(self) -> _NameType:
        ...
    
    @property
    def __qualname__(self) -> _NameType:
        ...
    
    @property
    def ntypes(self) -> _NTypes:
        ...
    
    @property
    def identity(self) -> _IDType:
        ...
    
    @property
    def nin(self) -> Literal[1]:
        ...
    
    @property
    def nout(self) -> Literal[1]:
        ...
    
    @property
    def nargs(self) -> Literal[2]:
        ...
    
    @property
    def signature(self) -> None:
        ...
    
    @overload
    def __call__(self, x1: _ScalarLike_co, /, out: None = ..., *, dtype: DTypeLike | None = ..., where: _ArrayLikeBool_co | None = ..., casting: _CastingKind = ..., order: _OrderKACF = ..., subok: bool = ..., signature: str | _2Tuple[str | None] = ...) -> Incomplete:
        ...
    
    @overload
    def __call__(self, x1: ArrayLike, /, out: np.ndarray | tuple[np.ndarray] | EllipsisType | None = ..., *, dtype: DTypeLike | None = ..., where: _ArrayLikeBool_co | None = ..., casting: _CastingKind = ..., order: _OrderKACF = ..., subok: bool = ..., signature: str | _2Tuple[str | None] = ...) -> NDArray[Incomplete]:
        ...
    
    @overload
    def __call__(self, x1: _SupportsArrayUFunc, /, out: np.ndarray | tuple[np.ndarray] | EllipsisType | None = ..., *, dtype: DTypeLike | None = ..., where: _ArrayLikeBool_co | None = ..., casting: _CastingKind = ..., order: _OrderKACF = ..., subok: bool = ..., signature: str | _2Tuple[str | None] = ...) -> Incomplete:
        ...
    
    def accumulate(self, array: Never, /) -> NoReturn:
        ...
    
    def reduce(self, array: Never, /) -> NoReturn:
        ...
    
    def reduceat(self, array: Never, /, indices: Never) -> NoReturn:
        ...
    
    def outer(self, A: Never, B: Never, /) -> NoReturn:
        ...
    
    def at(self, a: np.ndarray | _SupportsArrayUFunc, indices: _ArrayLikeInt_co, /) -> None:
        ...
    


@type_check_only
class _UFunc_Nin2_Nout1(ufunc, Generic[_NameType, _NTypes, _IDType]):
    @property
    def __name__(self) -> _NameType:
        ...
    
    @property
    def __qualname__(self) -> _NameType:
        ...
    
    @property
    def ntypes(self) -> _NTypes:
        ...
    
    @property
    def identity(self) -> _IDType:
        ...
    
    @property
    def nin(self) -> Literal[2]:
        ...
    
    @property
    def nout(self) -> Literal[1]:
        ...
    
    @property
    def nargs(self) -> Literal[3]:
        ...
    
    @property
    def signature(self) -> None:
        ...
    
    @overload
    def __call__(self, x1: _ScalarLike_co, x2: _ScalarLike_co, /, out: EllipsisType | None = ..., *, dtype: DTypeLike | None = ..., **kwds: Unpack[_UFunc3Kwargs]) -> Incomplete:
        ...
    
    @overload
    def __call__(self, x1: ArrayLike, x2: np.ndarray, /, out: np.ndarray | tuple[np.ndarray] | EllipsisType | None = ..., *, dtype: DTypeLike | None = ..., **kwds: Unpack[_UFunc3Kwargs]) -> NDArray[Incomplete]:
        ...
    
    @overload
    def __call__(self, x1: np.ndarray, x2: ArrayLike, /, out: np.ndarray | tuple[np.ndarray] | EllipsisType | None = ..., *, dtype: DTypeLike | None = ..., **kwds: Unpack[_UFunc3Kwargs]) -> NDArray[Incomplete]:
        ...
    
    @overload
    def __call__(self, x1: ArrayLike, x2: ArrayLike, /, out: np.ndarray | tuple[np.ndarray], *, dtype: DTypeLike | None = ..., **kwds: Unpack[_UFunc3Kwargs]) -> NDArray[Incomplete]:
        ...
    
    @overload
    def __call__(self, x1: ArrayLike, x2: ArrayLike, /, out: np.ndarray | tuple[np.ndarray] | EllipsisType | None = ..., *, dtype: DTypeLike | None = ..., **kwds: Unpack[_UFunc3Kwargs]) -> NDArray[Incomplete] | Incomplete:
        ...
    
    def accumulate(self, array: ArrayLike, /, axis: SupportsIndex = ..., dtype: DTypeLike | None = ..., out: np.ndarray | EllipsisType | None = ...) -> NDArray[Incomplete]:
        ...
    
    @overload
    def reduce(self, array: ArrayLike, /, axis: _ShapeLike | None = ..., dtype: DTypeLike | None = ..., out: None = ..., *, keepdims: Literal[False] = ..., **kwargs: Unpack[_ReduceKwargs]) -> Incomplete:
        ...
    
    @overload
    def reduce(self, array: ArrayLike, /, axis: _ShapeLike | None = ..., dtype: DTypeLike | None = ..., *, out: np.ndarray | EllipsisType, keepdims: bool = ..., **kwargs: Unpack[_ReduceKwargs]) -> NDArray[Incomplete]:
        ...
    
    @overload
    def reduce(self, array: ArrayLike, /, axis: _ShapeLike | None = ..., dtype: DTypeLike | None = ..., out: np.ndarray | EllipsisType | None = ..., *, keepdims: Literal[True], **kwargs: Unpack[_ReduceKwargs]) -> NDArray[Incomplete]:
        ...
    
    def reduceat(self, array: ArrayLike, /, indices: _ArrayLikeInt_co, axis: SupportsIndex = ..., dtype: DTypeLike | None = ..., out: np.ndarray | EllipsisType | None = ...) -> NDArray[Incomplete]:
        ...
    
    @overload
    def outer(self, A: _ScalarLike_co, B: _ScalarLike_co, /, *, out: None = ..., dtype: DTypeLike | None = ..., **kwds: Unpack[_UFunc3Kwargs]) -> Incomplete:
        ...
    
    @overload
    def outer(self, A: ArrayLike, B: np.ndarray, /, *, out: np.ndarray | tuple[np.ndarray] | EllipsisType | None = ..., dtype: DTypeLike | None = ..., **kwds: Unpack[_UFunc3Kwargs]) -> NDArray[Incomplete]:
        ...
    
    @overload
    def outer(self, A: np.ndarray, B: ArrayLike, /, *, out: np.ndarray | tuple[np.ndarray] | EllipsisType | None = ..., dtype: DTypeLike | None = ..., **kwds: Unpack[_UFunc3Kwargs]) -> NDArray[Incomplete]:
        ...
    
    @overload
    def outer(self, A: ArrayLike, B: ArrayLike, /, *, out: np.ndarray | tuple[np.ndarray] | EllipsisType, dtype: DTypeLike | None = ..., **kwds: Unpack[_UFunc3Kwargs]) -> NDArray[Incomplete]:
        ...
    
    @overload
    def outer(self, A: ArrayLike, B: ArrayLike, /, *, out: None = ..., dtype: DTypeLike | None = ..., **kwds: Unpack[_UFunc3Kwargs]) -> NDArray[Incomplete] | Incomplete:
        ...
    
    def at(self, a: np.ndarray | _SupportsArrayUFunc, indices: _ArrayLikeInt_co, b: ArrayLike, /) -> None:
        ...
    


@type_check_only
class _UFunc_Nin1_Nout2(ufunc, Generic[_NameType, _NTypes, _IDType]):
    @property
    def __name__(self) -> _NameType:
        ...
    
    @property
    def __qualname__(self) -> _NameType:
        ...
    
    @property
    def ntypes(self) -> _NTypes:
        ...
    
    @property
    def identity(self) -> _IDType:
        ...
    
    @property
    def nin(self) -> Literal[1]:
        ...
    
    @property
    def nout(self) -> Literal[2]:
        ...
    
    @property
    def nargs(self) -> Literal[3]:
        ...
    
    @property
    def signature(self) -> None:
        ...
    
    @overload
    def __call__(self, x1: _ScalarLike_co, out1: EllipsisType | None = ..., out2: None = ..., /, *, out: EllipsisType | None = ..., dtype: DTypeLike | None = ..., where: _ArrayLikeBool_co | None = ..., casting: _CastingKind = ..., order: _OrderKACF = ..., subok: bool = ..., signature: str | _3Tuple[str | None] = ...) -> _2Tuple[Incomplete]:
        ...
    
    @overload
    def __call__(self, x1: ArrayLike, out1: np.ndarray | EllipsisType | None = ..., out2: np.ndarray | None = ..., /, *, out: _2Tuple[np.ndarray] | EllipsisType = ..., dtype: DTypeLike | None = ..., where: _ArrayLikeBool_co | None = ..., casting: _CastingKind = ..., order: _OrderKACF = ..., subok: bool = ..., signature: str | _3Tuple[str | None] = ...) -> _2Tuple[NDArray[Incomplete]]:
        ...
    
    @overload
    def __call__(self, x1: _SupportsArrayUFunc, out1: np.ndarray | EllipsisType | None = ..., out2: np.ndarray | None = ..., /, *, out: _2Tuple[np.ndarray] | EllipsisType = ..., dtype: DTypeLike | None = ..., where: _ArrayLikeBool_co | None = ..., casting: _CastingKind = ..., order: _OrderKACF = ..., subok: bool = ..., signature: str | _3Tuple[str | None] = ...) -> _2Tuple[Incomplete]:
        ...
    
    def accumulate(self, array: Never, /) -> NoReturn:
        ...
    
    def reduce(self, array: Never, /) -> NoReturn:
        ...
    
    def reduceat(self, array: Never, /, indices: Never) -> NoReturn:
        ...
    
    def outer(self, A: Never, B: Never, /) -> NoReturn:
        ...
    
    def at(self, a: Never, indices: Never, /) -> NoReturn:
        ...
    


@type_check_only
class _UFunc_Nin2_Nout2(ufunc, Generic[_NameType, _NTypes, _IDType]):
    @property
    def __name__(self) -> _NameType:
        ...
    
    @property
    def __qualname__(self) -> _NameType:
        ...
    
    @property
    def ntypes(self) -> _NTypes:
        ...
    
    @property
    def identity(self) -> _IDType:
        ...
    
    @property
    def nin(self) -> Literal[2]:
        ...
    
    @property
    def nout(self) -> Literal[2]:
        ...
    
    @property
    def nargs(self) -> Literal[4]:
        ...
    
    @property
    def signature(self) -> None:
        ...
    
    @overload
    def __call__(self, x1: _ScalarLike_co, x2: _ScalarLike_co, out1: EllipsisType | None = ..., out2: None = ..., /, *, out: EllipsisType | None = ..., dtype: DTypeLike | None = ..., where: _ArrayLikeBool_co | None = ..., casting: _CastingKind = ..., order: _OrderKACF = ..., subok: bool = ..., signature: str | _4Tuple[str | None] = ...) -> _2Tuple[Incomplete]:
        ...
    
    @overload
    def __call__(self, x1: ArrayLike, x2: ArrayLike, out1: np.ndarray | EllipsisType | None = ..., out2: np.ndarray | None = ..., /, *, out: _2Tuple[np.ndarray] | EllipsisType = ..., dtype: DTypeLike | None = ..., where: _ArrayLikeBool_co | None = ..., casting: _CastingKind = ..., order: _OrderKACF = ..., subok: bool = ..., signature: str | _4Tuple[str | None] = ...) -> _2Tuple[NDArray[Incomplete]]:
        ...
    
    def accumulate(self, array: Never, /) -> NoReturn:
        ...
    
    def reduce(self, array: Never, /) -> NoReturn:
        ...
    
    def reduceat(self, array: Never, /, indices: Never) -> NoReturn:
        ...
    
    def outer(self, A: Never, B: Never, /) -> NoReturn:
        ...
    
    def at(self, a: Never, indices: Never, b: Never, /) -> NoReturn:
        ...
    


@type_check_only
class _GUFunc_Nin2_Nout1(ufunc, Generic[_NameType, _NTypes, _IDType, _Signature]):
    @property
    def __name__(self) -> _NameType:
        ...
    
    @property
    def __qualname__(self) -> _NameType:
        ...
    
    @property
    def ntypes(self) -> _NTypes:
        ...
    
    @property
    def identity(self) -> _IDType:
        ...
    
    @property
    def nin(self) -> Literal[2]:
        ...
    
    @property
    def nout(self) -> Literal[1]:
        ...
    
    @property
    def nargs(self) -> Literal[3]:
        ...
    
    @property
    def signature(self) -> _Signature:
        ...
    
    @overload
    def __call__(self, x1: ArrayLike, x2: ArrayLike, /, out: EllipsisType | None = ..., *, dtype: DTypeLike | None = ..., casting: _CastingKind = ..., order: _OrderKACF = ..., subok: bool = ..., signature: str | _3Tuple[str | None] = ..., axes: list[_2Tuple[SupportsIndex]] = ...) -> Incomplete:
        ...
    
    @overload
    def __call__(self, x1: ArrayLike, x2: ArrayLike, /, out: np.ndarray | tuple[np.ndarray] | EllipsisType, *, dtype: DTypeLike | None = ..., casting: _CastingKind = ..., order: _OrderKACF = ..., subok: bool = ..., signature: str | _3Tuple[str | None] = ..., axes: list[_2Tuple[SupportsIndex]] = ...) -> NDArray[Incomplete]:
        ...
    
    def accumulate(self, array: Never, /) -> NoReturn:
        ...
    
    def reduce(self, array: Never, /) -> NoReturn:
        ...
    
    def reduceat(self, array: Never, /, indices: Never) -> NoReturn:
        ...
    
    def outer(self, A: Never, B: Never, /) -> NoReturn:
        ...
    
    def at(self, a: Never, indices: Never, b: Never, /) -> NoReturn:
        ...
    


@type_check_only
class _PyFunc_Kwargs_Nargs2(TypedDict, total=False):
    where: _ArrayLikeBool_co | None
    casting: _CastingKind
    order: _OrderKACF
    dtype: DTypeLike
    subok: bool
    signature: str | tuple[DTypeLike, DTypeLike]
    ...


@type_check_only
class _PyFunc_Kwargs_Nargs3(TypedDict, total=False):
    where: _ArrayLikeBool_co | None
    casting: _CastingKind
    order: _OrderKACF
    dtype: DTypeLike
    subok: bool
    signature: str | tuple[DTypeLike, DTypeLike, DTypeLike]
    ...


@type_check_only
class _PyFunc_Kwargs_Nargs3P(TypedDict, total=False):
    where: _ArrayLikeBool_co | None
    casting: _CastingKind
    order: _OrderKACF
    dtype: DTypeLike
    subok: bool
    signature: str | _3PTuple[DTypeLike]
    ...


@type_check_only
class _PyFunc_Kwargs_Nargs4P(TypedDict, total=False):
    where: _ArrayLikeBool_co | None
    casting: _CastingKind
    order: _OrderKACF
    dtype: DTypeLike
    subok: bool
    signature: str | _4PTuple[DTypeLike]
    ...


@type_check_only
class _PyFunc_Nin1_Nout1(ufunc, Generic[_ReturnType_co, _IDType]):
    @property
    def identity(self) -> _IDType:
        ...
    
    @property
    def nin(self) -> Literal[1]:
        ...
    
    @property
    def nout(self) -> Literal[1]:
        ...
    
    @property
    def nargs(self) -> Literal[2]:
        ...
    
    @property
    def ntypes(self) -> Literal[1]:
        ...
    
    @property
    def signature(self) -> None:
        ...
    
    @overload
    def __call__(self, x1: _ScalarLike_co, /, out: EllipsisType | None = ..., **kwargs: Unpack[_PyFunc_Kwargs_Nargs2]) -> _ReturnType_co:
        ...
    
    @overload
    def __call__(self, x1: ArrayLike, /, out: EllipsisType | None = ..., **kwargs: Unpack[_PyFunc_Kwargs_Nargs2]) -> _ReturnType_co | NDArray[np.object_]:
        ...
    
    @overload
    def __call__(self, x1: ArrayLike, /, out: _ArrayT | tuple[_ArrayT], **kwargs: Unpack[_PyFunc_Kwargs_Nargs2]) -> _ArrayT:
        ...
    
    @overload
    def __call__(self, x1: _SupportsArrayUFunc, /, out: np.ndarray | tuple[np.ndarray] | EllipsisType | None = ..., **kwargs: Unpack[_PyFunc_Kwargs_Nargs2]) -> Incomplete:
        ...
    
    def accumulate(self, array: Never, /) -> NoReturn:
        ...
    
    def reduce(self, array: Never, /) -> NoReturn:
        ...
    
    def reduceat(self, array: Never, /, indices: Never) -> NoReturn:
        ...
    
    def outer(self, A: Never, B: Never, /) -> NoReturn:
        ...
    
    def at(self, a: np.ndarray | _SupportsArrayUFunc, indices: _ArrayLikeInt_co, /) -> None:
        ...
    


@type_check_only
class _PyFunc_Nin2_Nout1(ufunc, Generic[_ReturnType_co, _IDType]):
    @property
    def identity(self) -> _IDType:
        ...
    
    @property
    def nin(self) -> Literal[2]:
        ...
    
    @property
    def nout(self) -> Literal[1]:
        ...
    
    @property
    def nargs(self) -> Literal[3]:
        ...
    
    @property
    def ntypes(self) -> Literal[1]:
        ...
    
    @property
    def signature(self) -> None:
        ...
    
    @overload
    def __call__(self, x1: _ScalarLike_co, x2: _ScalarLike_co, /, out: EllipsisType | None = ..., **kwargs: Unpack[_PyFunc_Kwargs_Nargs3]) -> _ReturnType_co:
        ...
    
    @overload
    def __call__(self, x1: ArrayLike, x2: ArrayLike, /, out: EllipsisType | None = ..., **kwargs: Unpack[_PyFunc_Kwargs_Nargs3]) -> _ReturnType_co | NDArray[np.object_]:
        ...
    
    @overload
    def __call__(self, x1: ArrayLike, x2: ArrayLike, /, out: _ArrayT | tuple[_ArrayT], **kwargs: Unpack[_PyFunc_Kwargs_Nargs3]) -> _ArrayT:
        ...
    
    @overload
    def __call__(self, x1: _SupportsArrayUFunc, x2: _SupportsArrayUFunc | ArrayLike, /, out: np.ndarray | tuple[np.ndarray] | EllipsisType | None = ..., **kwargs: Unpack[_PyFunc_Kwargs_Nargs3]) -> Incomplete:
        ...
    
    @overload
    def __call__(self, x1: ArrayLike, x2: _SupportsArrayUFunc, /, out: np.ndarray | tuple[np.ndarray] | EllipsisType | None = ..., **kwargs: Unpack[_PyFunc_Kwargs_Nargs3]) -> Incomplete:
        ...
    
    @overload
    def accumulate(self, array: ArrayLike, /, axis: SupportsIndex = ..., dtype: DTypeLike | None = ..., out: EllipsisType | None = ...) -> NDArray[np.object_]:
        ...
    
    @overload
    def accumulate(self, array: ArrayLike, /, axis: SupportsIndex = ..., dtype: DTypeLike | None = ..., *, out: _ArrayT) -> _ArrayT:
        ...
    
    @overload
    def reduce(self, array: ArrayLike, /, axis: _ShapeLike | None = ..., dtype: DTypeLike | None = ..., *, out: _ArrayT | tuple[_ArrayT], keepdims: bool = ..., **kwargs: Unpack[_ReduceKwargs]) -> _ArrayT:
        ...
    
    @overload
    def reduce(self, array: ArrayLike, /, axis: _ShapeLike | None = ..., dtype: DTypeLike | None = ..., *, out: EllipsisType, keepdims: bool = ..., **kwargs: Unpack[_ReduceKwargs]) -> NDArray[np.object_]:
        ...
    
    @overload
    def reduce(self, array: ArrayLike, /, axis: _ShapeLike | None = ..., dtype: DTypeLike | None = ..., out: EllipsisType | None = ..., *, keepdims: Literal[True], **kwargs: Unpack[_ReduceKwargs]) -> NDArray[np.object_]:
        ...
    
    @overload
    def reduce(self, array: ArrayLike, /, axis: _ShapeLike | None = ..., dtype: DTypeLike | None = ..., out: EllipsisType | None = ..., keepdims: bool = ..., **kwargs: Unpack[_ReduceKwargs]) -> _ReturnType_co | NDArray[np.object_]:
        ...
    
    @overload
    def reduceat(self, array: ArrayLike, /, indices: _ArrayLikeInt_co, axis: SupportsIndex = ..., dtype: DTypeLike | None = ..., *, out: _ArrayT | tuple[_ArrayT]) -> _ArrayT:
        ...
    
    @overload
    def reduceat(self, array: ArrayLike, /, indices: _ArrayLikeInt_co, axis: SupportsIndex = ..., dtype: DTypeLike | None = ..., out: EllipsisType | None = ...) -> NDArray[np.object_]:
        ...
    
    @overload
    def reduceat(self, array: _SupportsArrayUFunc, /, indices: _ArrayLikeInt_co, axis: SupportsIndex = ..., dtype: DTypeLike | None = ..., out: np.ndarray | tuple[np.ndarray] | EllipsisType | None = ...) -> Incomplete:
        ...
    
    @overload
    def outer(self, A: _ScalarLike_co, B: _ScalarLike_co, /, *, out: EllipsisType | None = ..., **kwargs: Unpack[_PyFunc_Kwargs_Nargs3]) -> _ReturnType_co:
        ...
    
    @overload
    def outer(self, A: ArrayLike, B: ArrayLike, /, *, out: EllipsisType | None = ..., **kwargs: Unpack[_PyFunc_Kwargs_Nargs3]) -> _ReturnType_co | NDArray[np.object_]:
        ...
    
    @overload
    def outer(self, A: ArrayLike, B: ArrayLike, /, *, out: _ArrayT, **kwargs: Unpack[_PyFunc_Kwargs_Nargs3]) -> _ArrayT:
        ...
    
    @overload
    def outer(self, A: _SupportsArrayUFunc, B: _SupportsArrayUFunc | ArrayLike, /, *, out: EllipsisType | None = ..., **kwargs: Unpack[_PyFunc_Kwargs_Nargs3]) -> Incomplete:
        ...
    
    @overload
    def outer(self, A: _ScalarLike_co, B: _SupportsArrayUFunc | ArrayLike, /, *, out: EllipsisType | None = ..., **kwargs: Unpack[_PyFunc_Kwargs_Nargs3]) -> Incomplete:
        ...
    
    def at(self, a: np.ndarray | _SupportsArrayUFunc, indices: _ArrayLikeInt_co, b: ArrayLike, /) -> None:
        ...
    


@type_check_only
class _PyFunc_Nin3P_Nout1(ufunc, Generic[_ReturnType_co, _IDType, _NIn]):
    @property
    def identity(self) -> _IDType:
        ...
    
    @property
    def nin(self) -> _NIn:
        ...
    
    @property
    def nout(self) -> Literal[1]:
        ...
    
    @property
    def ntypes(self) -> Literal[1]:
        ...
    
    @property
    def signature(self) -> None:
        ...
    
    @overload
    def __call__(self, x1: _ScalarLike_co, x2: _ScalarLike_co, x3: _ScalarLike_co, /, *xs: _ScalarLike_co, out: EllipsisType | None = ..., **kwargs: Unpack[_PyFunc_Kwargs_Nargs4P]) -> _ReturnType_co:
        ...
    
    @overload
    def __call__(self, x1: ArrayLike, x2: ArrayLike, x3: ArrayLike, /, *xs: ArrayLike, out: EllipsisType | None = ..., **kwargs: Unpack[_PyFunc_Kwargs_Nargs4P]) -> _ReturnType_co | NDArray[np.object_]:
        ...
    
    @overload
    def __call__(self, x1: ArrayLike, x2: ArrayLike, x3: ArrayLike, /, *xs: ArrayLike, out: _ArrayT | tuple[_ArrayT], **kwargs: Unpack[_PyFunc_Kwargs_Nargs4P]) -> _ArrayT:
        ...
    
    @overload
    def __call__(self, x1: _SupportsArrayUFunc | ArrayLike, x2: _SupportsArrayUFunc | ArrayLike, x3: _SupportsArrayUFunc | ArrayLike, /, *xs: _SupportsArrayUFunc | ArrayLike, out: np.ndarray | tuple[np.ndarray] | EllipsisType | None = ..., **kwargs: Unpack[_PyFunc_Kwargs_Nargs4P]) -> Incomplete:
        ...
    
    def accumulate(self, array: Never, /) -> NoReturn:
        ...
    
    def reduce(self, array: Never, /) -> NoReturn:
        ...
    
    def reduceat(self, array: Never, /, indices: Never) -> NoReturn:
        ...
    
    def outer(self, A: Never, B: Never, /) -> NoReturn:
        ...
    
    def at(self, a: Never, indices: Never, /, *args: Never) -> NoReturn:
        ...
    


@type_check_only
class _PyFunc_Nin1P_Nout2P(ufunc, Generic[_ReturnType_co, _IDType, _NIn, _NOut]):
    @property
    def identity(self) -> _IDType:
        ...
    
    @property
    def nin(self) -> _NIn:
        ...
    
    @property
    def nout(self) -> _NOut:
        ...
    
    @property
    def ntypes(self) -> Literal[1]:
        ...
    
    @property
    def signature(self) -> None:
        ...
    
    @overload
    def __call__(self, x1: _ScalarLike_co, /, *xs: _ScalarLike_co, out: EllipsisType | None = ..., **kwargs: Unpack[_PyFunc_Kwargs_Nargs3P]) -> _2PTuple[_ReturnType_co]:
        ...
    
    @overload
    def __call__(self, x1: ArrayLike, /, *xs: ArrayLike, out: EllipsisType | None = ..., **kwargs: Unpack[_PyFunc_Kwargs_Nargs3P]) -> _2PTuple[_ReturnType_co | NDArray[np.object_]]:
        ...
    
    @overload
    def __call__(self, x1: ArrayLike, /, *xs: ArrayLike, out: _2PTuple[_ArrayT], **kwargs: Unpack[_PyFunc_Kwargs_Nargs3P]) -> _2PTuple[_ArrayT]:
        ...
    
    @overload
    def __call__(self, x1: _SupportsArrayUFunc | ArrayLike, /, *xs: _SupportsArrayUFunc | ArrayLike, out: _2PTuple[np.ndarray] | EllipsisType | None = ..., **kwargs: Unpack[_PyFunc_Kwargs_Nargs3P]) -> Incomplete:
        ...
    
    def accumulate(self, array: Never, /) -> NoReturn:
        ...
    
    def reduce(self, array: Never, /) -> NoReturn:
        ...
    
    def reduceat(self, array: Never, /, indices: Never) -> NoReturn:
        ...
    
    def outer(self, A: Never, B: Never, /) -> NoReturn:
        ...
    
    def at(self, a: Never, indices: Never, /, *args: Never) -> NoReturn:
        ...
    


