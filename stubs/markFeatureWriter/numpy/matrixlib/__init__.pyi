"""
This type stub file was generated by pyright.
"""

import numpy as np
from _typeshed import Incomplete
from collections.abc import Mapping, Sequence
from types import EllipsisType
from typing import Any, ClassVar, Literal as L, Self, SupportsIndex, TypeAlias, overload
from typing_extensions import TypeVar
from numpy._typing import ArrayLike, DTypeLike, NDArray, _AnyShape, _ArrayLikeInt_co, _NestedSequence, _ShapeLike

__all__ = ["asmatrix", "bmat", "matrix"]
_T = TypeVar("_T")
_ArrayT = TypeVar("_ArrayT", bound=np.ndarray)
_BoolOrIntArrayT = TypeVar("_BoolOrIntArrayT", bound=NDArray[np.integer | np.bool])
_ScalarT = TypeVar("_ScalarT", bound=np.generic)
_ShapeT_co = TypeVar("_ShapeT_co", bound=_2D, default=_2D, covariant=True)
_DTypeT_co = TypeVar("_DTypeT_co", bound=np.dtype, default=np.dtype, covariant=True)
_2D: TypeAlias = tuple[int, int]
_Matrix: TypeAlias = matrix[_2D, np.dtype[_ScalarT]]
_ToIndex1: TypeAlias = slice | EllipsisType | NDArray[np.integer | np.bool] | _NestedSequence[int] | None
_ToIndex2: TypeAlias = tuple[_ToIndex1, _ToIndex1 | SupportsIndex] | tuple[_ToIndex1 | SupportsIndex, _ToIndex1]
class matrix(np.ndarray[_ShapeT_co, _DTypeT_co]):
    __array_priority__: ClassVar[float] = ...
    def __new__(subtype, data: ArrayLike, dtype: DTypeLike | None = ..., copy: bool = ...) -> _Matrix[Incomplete]:
        ...
    
    @overload
    def __getitem__(self, key: SupportsIndex | _ArrayLikeInt_co | tuple[SupportsIndex | _ArrayLikeInt_co, ...], /) -> Incomplete:
        ...
    
    @overload
    def __getitem__(self, key: _ToIndex1 | _ToIndex2, /) -> matrix[_2D, _DTypeT_co]:
        ...
    
    @overload
    def __getitem__(self: _Matrix[np.void], key: str, /) -> _Matrix[Incomplete]:
        ...
    
    @overload
    def __getitem__(self: _Matrix[np.void], key: list[str], /) -> matrix[_2D, _DTypeT_co]:
        ...
    
    def __mul__(self, other: ArrayLike, /) -> _Matrix[Incomplete]:
        ...
    
    def __rmul__(self, other: ArrayLike, /) -> _Matrix[Incomplete]:
        ...
    
    def __pow__(self, other: ArrayLike, /) -> _Matrix[Incomplete]:
        ...
    
    def __rpow__(self, other: ArrayLike, /) -> _Matrix[Incomplete]:
        ...
    
    @overload
    def sum(self, axis: None = ..., dtype: DTypeLike | None = ..., out: None = ...) -> Incomplete:
        ...
    
    @overload
    def sum(self, axis: _ShapeLike, dtype: DTypeLike | None = ..., out: None = ...) -> _Matrix[Incomplete]:
        ...
    
    @overload
    def sum(self, axis: _ShapeLike | None, dtype: DTypeLike | None, out: _ArrayT) -> _ArrayT:
        ...
    
    @overload
    def sum(self, axis: _ShapeLike | None = ..., dtype: DTypeLike | None = ..., *, out: _ArrayT) -> _ArrayT:
        ...
    
    @overload
    def prod(self, axis: None = ..., dtype: DTypeLike | None = ..., out: None = ...) -> Incomplete:
        ...
    
    @overload
    def prod(self, axis: _ShapeLike, dtype: DTypeLike | None = ..., out: None = ...) -> _Matrix[Incomplete]:
        ...
    
    @overload
    def prod(self, axis: _ShapeLike | None, dtype: DTypeLike | None, out: _ArrayT) -> _ArrayT:
        ...
    
    @overload
    def prod(self, axis: _ShapeLike | None = ..., dtype: DTypeLike | None = ..., *, out: _ArrayT) -> _ArrayT:
        ...
    
    @overload
    def mean(self, axis: None = ..., dtype: DTypeLike | None = ..., out: None = ...) -> Incomplete:
        ...
    
    @overload
    def mean(self, axis: _ShapeLike, dtype: DTypeLike | None = ..., out: None = ...) -> _Matrix[Incomplete]:
        ...
    
    @overload
    def mean(self, axis: _ShapeLike | None, dtype: DTypeLike | None, out: _ArrayT) -> _ArrayT:
        ...
    
    @overload
    def mean(self, axis: _ShapeLike | None = ..., dtype: DTypeLike | None = ..., *, out: _ArrayT) -> _ArrayT:
        ...
    
    @overload
    def std(self, axis: None = ..., dtype: DTypeLike | None = ..., out: None = ..., ddof: float = ...) -> Incomplete:
        ...
    
    @overload
    def std(self, axis: _ShapeLike, dtype: DTypeLike | None = ..., out: None = ..., ddof: float = ...) -> _Matrix[Incomplete]:
        ...
    
    @overload
    def std(self, axis: _ShapeLike | None, dtype: DTypeLike | None, out: _ArrayT, ddof: float = ...) -> _ArrayT:
        ...
    
    @overload
    def std(self, axis: _ShapeLike | None = ..., dtype: DTypeLike | None = ..., *, out: _ArrayT, ddof: float = ...) -> _ArrayT:
        ...
    
    @overload
    def var(self, axis: None = ..., dtype: DTypeLike | None = ..., out: None = ..., ddof: float = ...) -> Incomplete:
        ...
    
    @overload
    def var(self, axis: _ShapeLike, dtype: DTypeLike | None = ..., out: None = ..., ddof: float = ...) -> _Matrix[Incomplete]:
        ...
    
    @overload
    def var(self, axis: _ShapeLike | None, dtype: DTypeLike | None, out: _ArrayT, ddof: float = ...) -> _ArrayT:
        ...
    
    @overload
    def var(self, axis: _ShapeLike | None = ..., dtype: DTypeLike | None = ..., *, out: _ArrayT, ddof: float = ...) -> _ArrayT:
        ...
    
    @overload
    def any(self, axis: None = ..., out: None = ...) -> np.bool:
        ...
    
    @overload
    def any(self, axis: _ShapeLike, out: None = ...) -> _Matrix[np.bool]:
        ...
    
    @overload
    def any(self, axis: _ShapeLike | None, out: _ArrayT) -> _ArrayT:
        ...
    
    @overload
    def any(self, axis: _ShapeLike | None = ..., *, out: _ArrayT) -> _ArrayT:
        ...
    
    @overload
    def all(self, axis: None = ..., out: None = ...) -> np.bool:
        ...
    
    @overload
    def all(self, axis: _ShapeLike, out: None = ...) -> _Matrix[np.bool]:
        ...
    
    @overload
    def all(self, axis: _ShapeLike | None, out: _ArrayT) -> _ArrayT:
        ...
    
    @overload
    def all(self, axis: _ShapeLike | None = ..., *, out: _ArrayT) -> _ArrayT:
        ...
    
    @overload
    def max(self: NDArray[_ScalarT], axis: None = ..., out: None = ...) -> _ScalarT:
        ...
    
    @overload
    def max(self, axis: _ShapeLike, out: None = ...) -> matrix[_2D, _DTypeT_co]:
        ...
    
    @overload
    def max(self, axis: _ShapeLike | None, out: _ArrayT) -> _ArrayT:
        ...
    
    @overload
    def max(self, axis: _ShapeLike | None = ..., *, out: _ArrayT) -> _ArrayT:
        ...
    
    @overload
    def min(self: NDArray[_ScalarT], axis: None = ..., out: None = ...) -> _ScalarT:
        ...
    
    @overload
    def min(self, axis: _ShapeLike, out: None = ...) -> matrix[_2D, _DTypeT_co]:
        ...
    
    @overload
    def min(self, axis: _ShapeLike | None, out: _ArrayT) -> _ArrayT:
        ...
    
    @overload
    def min(self, axis: _ShapeLike | None = ..., *, out: _ArrayT) -> _ArrayT:
        ...
    
    @overload
    def ptp(self: NDArray[_ScalarT], axis: None = ..., out: None = ...) -> _ScalarT:
        ...
    
    @overload
    def ptp(self, axis: _ShapeLike, out: None = ...) -> matrix[_2D, _DTypeT_co]:
        ...
    
    @overload
    def ptp(self, axis: _ShapeLike | None, out: _ArrayT) -> _ArrayT:
        ...
    
    @overload
    def ptp(self, axis: _ShapeLike | None = ..., *, out: _ArrayT) -> _ArrayT:
        ...
    
    @overload
    def argmax(self: NDArray[_ScalarT], axis: None = ..., out: None = ...) -> np.intp:
        ...
    
    @overload
    def argmax(self, axis: _ShapeLike, out: None = ...) -> _Matrix[np.intp]:
        ...
    
    @overload
    def argmax(self, axis: _ShapeLike | None, out: _BoolOrIntArrayT) -> _BoolOrIntArrayT:
        ...
    
    @overload
    def argmax(self, axis: _ShapeLike | None = ..., *, out: _BoolOrIntArrayT) -> _BoolOrIntArrayT:
        ...
    
    @overload
    def argmin(self: NDArray[_ScalarT], axis: None = ..., out: None = ...) -> np.intp:
        ...
    
    @overload
    def argmin(self, axis: _ShapeLike, out: None = ...) -> _Matrix[np.intp]:
        ...
    
    @overload
    def argmin(self, axis: _ShapeLike | None, out: _BoolOrIntArrayT) -> _BoolOrIntArrayT:
        ...
    
    @overload
    def argmin(self, axis: _ShapeLike | None = ..., *, out: _BoolOrIntArrayT) -> _BoolOrIntArrayT:
        ...
    
    @overload
    def tolist(self: _Matrix[np.generic[_T]]) -> list[list[_T]]:
        ...
    
    @overload
    def tolist(self) -> Incomplete:
        ...
    
    def squeeze(self, /, axis: _ShapeLike | None = ...) -> matrix[_2D, _DTypeT_co]:
        ...
    
    def ravel(self, /, order: L["K", "A", "C", "F"] | None = ...) -> matrix[_2D, _DTypeT_co]:
        ...
    
    def flatten(self, /, order: L["K", "A", "C", "F"] | None = ...) -> matrix[_2D, _DTypeT_co]:
        ...
    
    def getT(self) -> Self:
        ...
    
    @property
    def I(self) -> _Matrix[Incomplete]:
        ...
    
    def getI(self) -> _Matrix[Incomplete]:
        ...
    
    @property
    def A(self) -> np.ndarray[_2D, _DTypeT_co]:
        ...
    
    def getA(self) -> np.ndarray[_2D, _DTypeT_co]:
        ...
    
    @property
    def A1(self) -> np.ndarray[_AnyShape, _DTypeT_co]:
        ...
    
    def getA1(self) -> np.ndarray[_AnyShape, _DTypeT_co]:
        ...
    
    @property
    def H(self) -> matrix[_2D, _DTypeT_co]:
        ...
    
    def getH(self) -> matrix[_2D, _DTypeT_co]:
        ...
    


def bmat(obj: str | Sequence[ArrayLike] | NDArray[Any], ldict: Mapping[str, Any] | None = ..., gdict: Mapping[str, Any] | None = ...) -> _Matrix[Incomplete]:
    ...

def asmatrix(data: ArrayLike, dtype: DTypeLike | None = ...) -> _Matrix[Incomplete]:
    ...

