"""
This type stub file was generated by pyright.
"""

import argparse
import sys
from defcon import Font
from pathlib import Path

'''
This tool interprets glyphs and anchor points within a UFO to write a
`makeotf`-compatible GPOS mark feature file.

The input UFO file needs to have base glyphs and zero-width combining
marks. Base- and mark glyphs attach via anchor pairs (e.g. `above` and
`_above`, or `top`, and `_top`).
Combining marks must be members of a `COMBINING_MARKS` reference group.

#### Default functionality:

-   writing a `mark.fea` file, which contains mark classes/groups, and
    per-anchor mark-to-base positioning lookups (GPOS lookup type 4)
-   writing mark-to-ligature positioning lookups (GPOS lookup type 5).
    This requires anchor names to be suffixed with an ordinal (`1ST`, `2ND`,
    `3RD`, etc). For example – if a mark with an `_above` anchor is to be
    attached to a ligature, the ligature’s anchor names would be `above1ST`,
    `above2ND`, etc – depending on the amount of ligature elements.

#### Optional functionality:

-   writing `mkmk.fea`, for mark-to-mark positioning (GPOS lookup type 6)
-   writing `abvm.fea`/`blwm.fea` files, as used in Indic scripts (anchor pairs
    are `abvm`, `_abvm`, and `blwm`, `_blwm`, respectively)
-   writing mark classes into a separate file (in case classes need to be
    shared across multiple lookup types)
-   trimming casing tags (`UC`, `LC`, or `SC`)

    Trimming tags is a somewhat specific feature, but it is quite essential:
    In a UFO, anchors can be used to build composite glyphs – for example
    `aacute`, and `Aacute`. Since those glyphs would often receive a
    differently-shaped accent, the anchor pairs (on bases `a`/`A` and
    marks `acutecmb`/`acutecmb.cap`) would be `aboveLC`/`_aboveLC`, and
    `aboveUC/_aboveUC`, respectively.

    When writing the mark feature, we care more about which group of combining
    marks triggers a certain behavior, so removing those casing tags allows
    grouping all `_above` marks together, hence attaching to a base glyph –
    no matter if it is upper- or lowercase. The aesthetic substitution of the
    mark (e.g. smaller mark on the uppercase letter) can happen later, in the
    `ccmp` feature.

#### Usage:
```zsh

    # write a basic mark feature
    python markFeatureWriter.py font.ufo

    # write mark and mkmk feature files
    python markFeatureWriter.py -m font.ufo

    # trim casing tags
    python markFeatureWriter.py -t font.ufo

    # further usage information
    python markFeatureWriter.py -h

```
'''
ORDINALS = ...
class Defaults:
    """
    default values
    These can be overridden via argparse.
    """
    def __init__(self) -> None:
        ...
    


def check_input_file(parser, file_name):
    ...

def get_args(args=...): # -> Namespace:
    ...

def write_output(directory, file, line_list): # -> None:
    ...

def is_attaching(anchor_name):
    '''
    check if the anchor name in question is attaching or not
    '''
    ...

def split_liga_anchor_name(anchor_name): # -> tuple[int, Any] | None:
    '''
    if the anchor name ends with 1ST, 2ND, etc.; get the implied index,
    and the name without the suffix
    '''
    ...

def process_anchor_name(anchor_name, trim=...):
    ...

def round_coordinate(coordinate): # -> tuple[int, ...]:
    ...

class AnchorMate:
    '''
    AnchorMate lifts anchors from one or more glyphs and
    sorts them in a dictionary {a_position: gName}
    '''
    def __init__(self, anchor) -> None:
        ...
    


class MarkFeatureWriter:
    def __init__(self, args=...) -> None:
        ...
    
    def run(self, ufo_path): # -> None:
        ...
    
    def make_liga_anchor_dict(self, glyph_list, attachment_list=...): # -> dict[Any, Any]:
        '''
        create a nested dict mapping idealized anchor names to attachment
        points within a ligature (and their index, indicated by 1ST, 2ND, etc):
        'aboveAR': {
            'arSeenAlefMaksura': {
                0: (890, 390),
                1: (150, 260)},
            'arTahYehBarree.s': {
                0: (320, 820),
                1: (110, 250)},
            }
        '''
        ...
    
    def make_anchor_dict(self, glyph_list, attachment_list=...): # -> dict[Any, Any]:
        '''
        create a dict mapping anchor names to attachment points, which may
        be shared by various glyphs -- for example:

        'aboveLC': {
            (275, 495): ['oslash', 'o'],
            (251, 495): ['a']},
        'belowLC': {
            (250, -20): ['a'],
            (275, -20): ['o']}

        '''
        ...
    
    def sort_gnames(self, glyph_list):
        '''
        Sort list of glyph names based on the glyph order
        '''
        ...
    
    def make_mark_class(self, anchor_name, a_mate): # -> tuple[list[Any], list[Any], list[Any]]:
        ...
    
    def make_mark_classes_content(self, mark_class_list): # -> list[Any]:
        '''
        The make_mark_class method returns a three-list tuple per
        anchor. Here, those lists are organized in chunks:

        - first mark group definitions, like
            @mGC_above_0_495 = [ gravecmb acutecmb circumflexcmb ];
            @mGC_above_0_690 = [ gravecmb.cap acutecmb.cap circumflexcmb.cap ];

        - then, markClass attachments relating to those groups:
            markClass @mGC_above_0_495 <anchor 0 495> @MC_above;
            markClass @mGC_above_0_690 <anchor 0 690> @MC_above;

        - finally, markClass attachments relating to single glyphs:
            markClass cedillacmb <anchor 0 0> @MC_base;
            markClass horncmb <anchor 0 475> @MC_horn;

        '''
        ...
    
    def make_lookup_wrappers(self, anchor_name, lookup_prefix, mkmk=...): # -> tuple[str, str]:
        '''
        make the fences the lookup is surrounded by - something like
        lookup MARK_BASE_above {
        } MARK_BASE_above;
        '''
        ...
    
    def make_mark_lookup(self, anchor_name, a_mate): # -> str:
        ...
    
    def make_liga_lookup(self, anchor_name, gname_index_dict): # -> str:
        ...
    
    def make_mkmk_lookup(self, anchor_name, a_mate): # -> str:
        ...
    


def main(test_args=...): # -> None:
    ...

if __name__ == '__main__':
    ...
