"""
This type stub file was generated by pyright.
"""

import types
import sys
import numbers
import functools
import copy
import inspect
import __builtin__
import builtins

"""
A selection of cross-compatible functions for Python 2 and 3.

This module exports useful functions for 2/3 compatible code:

    * bind_method: binds functions to classes
    * ``native_str_to_bytes`` and ``bytes_to_native_str``
    * ``native_str``: always equal to the native platform string object (because
      this may be shadowed by imports from future.builtins)
    * lists: lrange(), lmap(), lzip(), lfilter()
    * iterable method compatibility:
        - iteritems, iterkeys, itervalues
        - viewitems, viewkeys, viewvalues

        These use the original method if available, otherwise they use items,
        keys, values.

    * types:

        * text_type: unicode in Python 2, str in Python 3
        * string_types: basestring in Python 2, str in Python 3
        * binary_type: str in Python 2, bytes in Python 3
        * integer_types: (int, long) in Python 2, int in Python 3
        * class_types: (type, types.ClassType) in Python 2, type in Python 3

    * bchr(c):
        Take an integer and make a 1-character byte string
    * bord(c)
        Take the result of indexing on a byte string and make an integer
    * tobytes(s)
        Take a text string, a byte string, or a sequence of characters taken
        from a byte string, and make a byte string.

    * raise_from()
    * raise_with_traceback()

This module also defines these decorators:

    * ``python_2_unicode_compatible``
    * ``with_metaclass``
    * ``implements_iterator``

Some of the functions in this module come from the following sources:

    * Jinja2 (BSD licensed: see
      https://github.com/mitsuhiko/jinja2/blob/master/LICENSE)
    * Pandas compatibility module pandas.compat
    * six.py by Benjamin Peterson
    * Django
"""
PY3 = ...
PY34_PLUS = ...
PY35_PLUS = ...
PY36_PLUS = ...
PY37_PLUS = ...
PY38_PLUS = ...
PY39_PLUS = ...
PY2 = ...
PY26 = ...
PY27 = ...
PYPY = ...
def python_2_unicode_compatible(cls):
    """
    A decorator that defines __unicode__ and __str__ methods under Python
    2. Under Python 3, this decorator is a no-op.

    To support Python 2 and 3 with a single code base, define a __str__
    method returning unicode text and apply this decorator to the class, like
    this::

    >>> from future.utils import python_2_unicode_compatible

    >>> @python_2_unicode_compatible
    ... class MyClass(object):
    ...     def __str__(self):
    ...         return u'Unicode string: \u5b54\u5b50'

    >>> a = MyClass()

    Then, after this import:

    >>> from future.builtins import str

    the following is ``True`` on both Python 3 and 2::

    >>> str(a) == a.encode('utf-8').decode('utf-8')
    True

    and, on a Unicode-enabled terminal with the right fonts, these both print the
    Chinese characters for Confucius::

    >>> print(a)
    >>> print(str(a))

    The implementation comes from django.utils.encoding.
    """
    ...

def with_metaclass(meta, *bases): # -> metaclass:
    """
    Function from jinja2/_compat.py. License: BSD.

    Use it like this::

        class BaseForm(object):
            pass

        class FormType(type):
            pass

        class Form(with_metaclass(FormType, BaseForm)):
            pass

    This requires a bit of explanation: the basic idea is to make a
    dummy metaclass for one level of class instantiation that replaces
    itself with the actual metaclass.  Because of internal type checks
    we also need to make sure that we downgrade the custom metaclass
    for one level to something closer to type (that's why __call__ and
    __init__ comes back from type etc.).

    This has the advantage over six.with_metaclass of not introducing
    dummy classes into the final MRO.
    """
    class metaclass(meta):
        ...
    
    

if PY3:
    def bchr(s): # -> bytes:
        ...
    
    def bstr(s): # -> bytes:
        ...
    
    def bord(s):
        ...
    
    string_types = ...
    integer_types = ...
    class_types = ...
    text_type = ...
    binary_type = ...
else:
    def bchr(s): # -> str:
        ...
    
    def bstr(s): # -> str:
        ...
    
    def bord(s): # -> int:
        ...
    
    string_types = ...
    integer_types = ...
    class_types = ...
    text_type = ...
    binary_type = ...
if PY3:
    def tobytes(s): # -> bytes:
        ...
    
else:
    def tobytes(s): # -> str:
        ...
    
if PY3:
    def native_str_to_bytes(s, encoding=...):
        ...
    
    def bytes_to_native_str(b, encoding=...):
        ...
    
    def text_to_native_str(t, encoding=...):
        ...
    
else:
    def native_str_to_bytes(s, encoding=...): # -> newbytes:
        ...
    
    def bytes_to_native_str(b, encoding=...):
        ...
    
    def text_to_native_str(t, encoding=...):
        """
        Use this to create a Py2 native string when "from __future__ import
        unicode_literals" is in effect.
        """
        ...
    
if PY3:
    def lrange(*args, **kwargs): # -> list[int]:
        ...
    
    def lzip(*args, **kwargs): # -> list[tuple[Any, ...]]:
        ...
    
    def lmap(*args, **kwargs): # -> list[Any]:
        ...
    
    def lfilter(*args, **kwargs): # -> list[Any]:
        ...
    
else:
    lrange = ...
    lzip = ...
    lmap = ...
    lfilter = ...
def isidentifier(s, dotted=...): # -> bool:
    '''
    A function equivalent to the str.isidentifier method on Py3
    '''
    ...

def viewitems(obj, **kwargs): # -> Any:
    """
    Function for iterating over dictionary items with the same set-like
    behaviour on Py2.7 as on Py3.

    Passes kwargs to method."""
    ...

def viewkeys(obj, **kwargs): # -> Any:
    """
    Function for iterating over dictionary keys with the same set-like
    behaviour on Py2.7 as on Py3.

    Passes kwargs to method."""
    ...

def viewvalues(obj, **kwargs): # -> Any:
    """
    Function for iterating over dictionary values with the same set-like
    behaviour on Py2.7 as on Py3.

    Passes kwargs to method."""
    ...

def iteritems(obj, **kwargs): # -> Any:
    """Use this only if compatibility with Python versions before 2.7 is
    required. Otherwise, prefer viewitems().
    """
    ...

def iterkeys(obj, **kwargs): # -> Any:
    """Use this only if compatibility with Python versions before 2.7 is
    required. Otherwise, prefer viewkeys().
    """
    ...

def itervalues(obj, **kwargs): # -> Any:
    """Use this only if compatibility with Python versions before 2.7 is
    required. Otherwise, prefer viewvalues().
    """
    ...

def bind_method(cls, name, func): # -> None:
    """Bind a method to class, python 2 and python 3 compatible.

    Parameters
    ----------

    cls : type
        class to receive bound method
    name : basestring
        name of method on class instance
    func : function
        function to be bound as method

    Returns
    -------
    None
    """
    ...

def getexception(): # -> BaseException | None:
    ...

if PY3:
    def raise_from(exc, cause): # -> None:
        """
        Equivalent to:

            raise EXCEPTION from CAUSE

        on Python 3. (See PEP 3134).
        """
        ...
    
    def raise_(tp, value=..., tb=...):
        """
        A function that matches the Python 2.x ``raise`` statement. This
        allows re-raising exceptions with the cls value and traceback on
        Python 2 and 3.
        """
        ...
    
    def raise_with_traceback(exc, traceback=...):
        ...
    
else:
    def raise_from(exc, cause):
        """
        Equivalent to:

            raise EXCEPTION from CAUSE

        on Python 3. (See PEP 3134).
        """
        ...
    
reraise = ...
def implements_iterator(cls):
    '''
    From jinja2/_compat.py. License: BSD.

    Use as a decorator like this::

        @implements_iterator
        class UppercasingIterator(object):
            def __init__(self, iterable):
                self._iter = iter(iterable)
            def __iter__(self):
                return self
            def __next__(self):
                return next(self._iter).upper()

    '''
    ...

if PY3:
    get_next = ...
else:
    get_next = ...
def encode_filename(filename):
    ...

def is_new_style(cls): # -> bool:
    """
    Python 2.7 has both new-style and old-style classes. Old-style classes can
    be pesky in some circumstances, such as when using inheritance.  Use this
    function to test for whether a class is new-style. (Python 3 only has
    new-style classes.)
    """
    ...

native_str = str
native_bytes = bytes
def istext(obj): # -> bool:
    """
    Deprecated. Use::
        >>> isinstance(obj, str)
    after this import:
        >>> from future.builtins import str
    """
    ...

def isbytes(obj): # -> bool:
    """
    Deprecated. Use::
        >>> isinstance(obj, bytes)
    after this import:
        >>> from future.builtins import bytes
    """
    ...

def isnewbytes(obj): # -> bool:
    """
    Equivalent to the result of ``type(obj)  == type(newbytes)``
    in other words, it is REALLY a newbytes instance, not a Py2 native str
    object?

    Note that this does not cover subclasses of newbytes, and it is not
    equivalent to ininstance(obj, newbytes)
    """
    ...

def isint(obj): # -> bool:
    """
    Deprecated. Tests whether an object is a Py3 ``int`` or either a Py2 ``int`` or
    ``long``.

    Instead of using this function, you can use:

        >>> from future.builtins import int
        >>> isinstance(obj, int)

    The following idiom is equivalent:

        >>> from numbers import Integral
        >>> isinstance(obj, Integral)
    """
    ...

def native(obj):
    """
    On Py3, this is a no-op: native(obj) -> obj

    On Py2, returns the corresponding native Py2 types that are
    superclasses for backported objects from Py3:

    >>> from builtins import str, bytes, int

    >>> native(str(u'ABC'))
    u'ABC'
    >>> type(native(str(u'ABC')))
    unicode

    >>> native(bytes(b'ABC'))
    b'ABC'
    >>> type(native(bytes(b'ABC')))
    bytes

    >>> native(int(10**20))
    100000000000000000000L
    >>> type(native(int(10**20)))
    long

    Existing native types on Py2 will be returned unchanged:

    >>> type(native(u'ABC'))
    unicode
    """
    ...

if PY3:
    exec_ = ...
else:
    def exec_(code, globs=..., locs=...): # -> None:
        """Execute code in a namespace."""
        ...
    
def old_div(a, b): # -> _RealLike:
    """
    DEPRECATED: import ``old_div`` from ``past.utils`` instead.

    Equivalent to ``a / b`` on Python 2 without ``from __future__ import
    division``.

    TODO: generalize this to other objects (like arrays etc.)
    """
    ...

def as_native_str(encoding=...): # -> Callable[..., Any] | Callable[..., _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any]]:
    '''
    A decorator to turn a function or method call that returns text, i.e.
    unicode, into one that returns a native platform str.

    Use it as a decorator like this::

        from __future__ import unicode_literals

        class MyClass(object):
            @as_native_str(encoding='ascii')
            def __repr__(self):
                return next(self._iter).upper()
    '''
    ...

if PY3:
    def ensure_new_type(obj):
        ...
    
else:
    def ensure_new_type(obj): # -> newbytes | newstr | newint | newdict:
        ...
    
__all__ = ['PY2', 'PY26', 'PY3', 'PYPY', 'as_native_str', 'binary_type', 'bind_method', 'bord', 'bstr', 'bytes_to_native_str', 'class_types', 'encode_filename', 'ensure_new_type', 'exec_', 'get_next', 'getexception', 'implements_iterator', 'integer_types', 'is_new_style', 'isbytes', 'isidentifier', 'isint', 'isnewbytes', 'istext', 'iteritems', 'iterkeys', 'itervalues', 'lfilter', 'listitems', 'listvalues', 'lmap', 'lrange', 'lzip', 'native', 'native_bytes', 'native_str', 'native_str_to_bytes', 'old_div', 'python_2_unicode_compatible', 'raise_', 'raise_with_traceback', 'reraise', 'string_types', 'text_to_native_str', 'text_type', 'tobytes', 'viewitems', 'viewkeys', 'viewvalues', 'with_metaclass']
