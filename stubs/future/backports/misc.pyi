"""
This type stub file was generated by pyright.
"""

import sys
from future.utils import PY2, PY26, PY3
from collections import ChainMap, Counter, MutableMapping, OrderedDict
from collections.abc import MutableMapping
from reprlib import recursive_repr

"""
Miscellaneous function (re)definitions from the Py3.4+ standard library
for Python 2.6/2.7.

- math.ceil                (for Python 2.7)
- collections.OrderedDict  (for Python 2.6)
- collections.Counter      (for Python 2.6)
- collections.ChainMap     (for all versions prior to Python 3.3)
- itertools.count          (for Python 2.6, with step parameter)
- subprocess.check_output  (for Python 2.6)
- reprlib.recursive_repr   (for Python 2.6+)
- functools.cmp_to_key     (for Python 2.6)
"""
if PY2:
    ...
else:
    ...
def ceil(x): # -> int:
    """
    Return the ceiling of x as an int.
    This is the smallest integral value >= x.
    """
    ...

if PY26:
    def count(start=..., step=...): # -> Generator[int, Any, NoReturn]:
        ...
    
else:
    ...
if PY3:
    ...
else:
    ...
def recursive_repr(fillvalue=...): # -> Callable[..., Callable[..., str | Any]]:
    'Decorator to make a repr function return fillvalue for a recursive call'
    ...

class _Link:
    __slots__ = ...


class OrderedDict(dict):
    'Dictionary that remembers insertion order'
    def __init__(*args, **kwds) -> None:
        '''Initialize an ordered dictionary.  The signature is the same as
        regular dictionaries, but keyword arguments are not recommended because
        their insertion order is arbitrary.

        '''
        ...
    
    def __setitem__(self, key, value, dict_setitem=..., proxy=..., Link=...): # -> None:
        'od.__setitem__(i, y) <==> od[i]=y'
        ...
    
    def __delitem__(self, key, dict_delitem=...): # -> None:
        'od.__delitem__(y) <==> del od[y]'
        ...
    
    def __iter__(self): # -> Generator[Any, Any, None]:
        'od.__iter__() <==> iter(od)'
        ...
    
    def __reversed__(self): # -> Generator[Any, Any, None]:
        'od.__reversed__() <==> reversed(od)'
        ...
    
    def clear(self): # -> None:
        'od.clear() -> None.  Remove all items from od.'
        ...
    
    def popitem(self, last=...): # -> tuple[Any, Any]:
        '''od.popitem() -> (k, v), return and remove a (key, value) pair.
        Pairs are returned in LIFO order if last is true or FIFO order if false.

        '''
        ...
    
    def move_to_end(self, key, last=...): # -> None:
        '''Move an existing element to the end (or beginning if last==False).

        Raises KeyError if the element does not exist.
        When last=True, acts like a fast version of self[key]=self.pop(key).

        '''
        ...
    
    def __sizeof__(self): # -> int:
        ...
    
    __update = ...
    keys = ...
    values = ...
    items = ...
    __ne__ = ...
    __marker = ...
    def pop(self, key, default=...): # -> object:
        '''od.pop(k[,d]) -> v, remove specified key and return the corresponding
        value.  If key is not found, d is returned if given, otherwise KeyError
        is raised.

        '''
        ...
    
    def setdefault(self, key, default=...): # -> None:
        'od.setdefault(k[,d]) -> od.get(k,d), also set od[k]=d if k not in od'
        ...
    
    @recursive_repr()
    def __repr__(self): # -> str:
        'od.__repr__() <==> repr(od)'
        ...
    
    def __reduce__(self): # -> tuple[type[Self], tuple[()], dict[str, Any] | None, None, Iterator[tuple[Any, Any]]]:
        'Return state information for pickling'
        ...
    
    def copy(self): # -> Self:
        'od.copy() -> a shallow copy of od'
        ...
    
    @classmethod
    def fromkeys(cls, iterable, value=...): # -> Self:
        '''OD.fromkeys(S[, v]) -> New ordered dictionary with keys from S.
        If not specified, the value defaults to None.

        '''
        ...
    
    def __eq__(self, other) -> bool:
        '''od.__eq__(y) <==> od==y.  Comparison to another OD is order-sensitive
        while comparison to a regular mapping is order-insensitive.

        '''
        ...
    


class Counter(dict):
    '''Dict subclass for counting hashable items.  Sometimes called a bag
    or multiset.  Elements are stored as dictionary keys and their counts
    are stored as dictionary values.

    >>> c = Counter('abcdeabcdabcaba')  # count elements from a string

    >>> c.most_common(3)                # three most common elements
    [('a', 5), ('b', 4), ('c', 3)]
    >>> sorted(c)                       # list all unique elements
    ['a', 'b', 'c', 'd', 'e']
    >>> ''.join(sorted(c.elements()))   # list elements with repetitions
    'aaaaabbbbcccdde'
    >>> sum(c.values())                 # total of all counts
    15

    >>> c['a']                          # count of letter 'a'
    5
    >>> for elem in 'shazam':           # update counts from an iterable
    ...     c[elem] += 1                # by adding 1 to each element's count
    >>> c['a']                          # now there are seven 'a'
    7
    >>> del c['b']                      # remove all 'b'
    >>> c['b']                          # now there are zero 'b'
    0

    >>> d = Counter('simsalabim')       # make another counter
    >>> c.update(d)                     # add in the second counter
    >>> c['a']                          # now there are nine 'a'
    9

    >>> c.clear()                       # empty the counter
    >>> c
    Counter()

    Note:  If a count is set to zero or reduced to zero, it will remain
    in the counter until the entry is deleted or the counter is cleared:

    >>> c = Counter('aaabbc')
    >>> c['b'] -= 2                     # reduce the count of 'b' by two
    >>> c.most_common()                 # 'b' is still in, but its count is zero
    [('a', 3), ('c', 1), ('b', 0)]

    '''
    def __init__(*args, **kwds) -> None:
        '''Create a new, empty Counter object.  And if given, count elements
        from an input iterable.  Or, initialize the count from another mapping
        of elements to their counts.

        >>> c = Counter()                           # a new, empty counter
        >>> c = Counter('gallahad')                 # a new counter from an iterable
        >>> c = Counter({'a': 4, 'b': 2})           # a new counter from a mapping
        >>> c = Counter(a=4, b=2)                   # a new counter from keyword args

        '''
        ...
    
    def __missing__(self, key): # -> Literal[0]:
        'The count of elements not in the Counter is zero.'
        ...
    
    def most_common(self, n=...): # -> list[tuple[Any, Any]]:
        '''List the n most common elements and their counts from the most
        common to the least.  If n is None, then list all element counts.

        >>> Counter('abcdeabcdabcaba').most_common(3)
        [('a', 5), ('b', 4), ('c', 3)]

        '''
        ...
    
    def elements(self): # -> chain[_T]:
        '''Iterator over elements repeating each as many times as its count.

        >>> c = Counter('ABCABC')
        >>> sorted(c.elements())
        ['A', 'A', 'B', 'B', 'C', 'C']

        # Knuth's example for prime factors of 1836:  2**2 * 3**3 * 17**1
        >>> prime_factors = Counter({2: 2, 3: 3, 17: 1})
        >>> product = 1
        >>> for factor in prime_factors.elements():     # loop over factors
        ...     product *= factor                       # and multiply them
        >>> product
        1836

        Note, if an element's count has been set to zero or is a negative
        number, elements() will ignore it.

        '''
        ...
    
    @classmethod
    def fromkeys(cls, iterable, v=...):
        ...
    
    def update(*args, **kwds): # -> None:
        '''Like dict.update() but add counts instead of replacing them.

        Source can be an iterable, a dictionary, or another Counter instance.

        >>> c = Counter('which')
        >>> c.update('witch')           # add elements from another iterable
        >>> d = Counter('watch')
        >>> c.update(d)                 # add elements from another counter
        >>> c['h']                      # four 'h' in which, witch, and watch
        4

        '''
        ...
    
    def subtract(*args, **kwds): # -> None:
        '''Like dict.update() but subtracts counts instead of replacing them.
        Counts can be reduced below zero.  Both the inputs and outputs are
        allowed to contain zero and negative counts.

        Source can be an iterable, a dictionary, or another Counter instance.

        >>> c = Counter('which')
        >>> c.subtract('witch')             # subtract elements from another iterable
        >>> c.subtract(Counter('watch'))    # subtract elements from another counter
        >>> c['h']                          # 2 in which, minus 1 in witch, minus 1 in watch
        0
        >>> c['w']                          # 1 in which, minus 1 in witch, minus 1 in watch
        -1

        '''
        ...
    
    def copy(self): # -> Self:
        'Return a shallow copy.'
        ...
    
    def __reduce__(self): # -> tuple[type[Self], tuple[dict[Any, Any]]]:
        ...
    
    def __delitem__(self, elem): # -> None:
        'Like dict.__delitem__() but does not raise KeyError for missing values.'
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __add__(self, other): # -> NotImplementedType | Counter:
        '''Add counts from two counters.

        >>> Counter('abbb') + Counter('bcc')
        Counter({'b': 4, 'c': 2, 'a': 1})

        '''
        ...
    
    def __sub__(self, other): # -> NotImplementedType | Counter:
        ''' Subtract count, but keep only results with positive counts.

        >>> Counter('abbbc') - Counter('bccd')
        Counter({'b': 2, 'a': 1})

        '''
        ...
    
    def __or__(self, other): # -> NotImplementedType | Counter:
        '''Union is the maximum of value in either of the input counters.

        >>> Counter('abbb') | Counter('bcc')
        Counter({'b': 3, 'c': 2, 'a': 1})

        '''
        ...
    
    def __and__(self, other): # -> NotImplementedType | Counter:
        ''' Intersection is the minimum of corresponding counts.

        >>> Counter('abbb') & Counter('bcc')
        Counter({'b': 1})

        '''
        ...
    
    def __pos__(self): # -> NotImplementedType | Counter:
        'Adds an empty counter, effectively stripping negative and zero counts'
        ...
    
    def __neg__(self): # -> NotImplementedType | Counter:
        '''Subtracts from an empty counter.  Strips positive and zero counts,
        and flips the sign on negative counts.

        '''
        ...
    
    def __iadd__(self, other): # -> Self:
        '''Inplace add from another counter, keeping only positive counts.

        >>> c = Counter('abbb')
        >>> c += Counter('bcc')
        >>> c
        Counter({'b': 4, 'c': 2, 'a': 1})

        '''
        ...
    
    def __isub__(self, other): # -> Self:
        '''Inplace subtract counter, but keep only results with positive counts.

        >>> c = Counter('abbbc')
        >>> c -= Counter('bccd')
        >>> c
        Counter({'b': 2, 'a': 1})

        '''
        ...
    
    def __ior__(self, other): # -> Self:
        '''Inplace union is the maximum of value from either counter.

        >>> c = Counter('abbb')
        >>> c |= Counter('bcc')
        >>> c
        Counter({'b': 3, 'c': 2, 'a': 1})

        '''
        ...
    
    def __iand__(self, other): # -> Self:
        '''Inplace intersection is the minimum of corresponding counts.

        >>> c = Counter('abbb')
        >>> c &= Counter('bcc')
        >>> c
        Counter({'b': 1})

        '''
        ...
    


def check_output(*popenargs, **kwargs): # -> str:
    """
    For Python 2.6 compatibility: see
    http://stackoverflow.com/questions/4814970/
    """
    ...

def count(start=..., step=...): # -> Generator[int, Any, NoReturn]:
    """
    ``itertools.count`` in Py 2.6 doesn't accept a step
    parameter. This is an enhanced version of ``itertools.count``
    for Py2.6 equivalent to ``itertools.count`` in Python 2.7+.
    """
    ...

class ChainMap(MutableMapping):
    ''' A ChainMap groups multiple dicts (or other mappings) together
    to create a single, updateable view.

    The underlying mappings are stored in a list.  That list is public and can
    accessed or updated using the *maps* attribute.  There is no other state.

    Lookups search the underlying mappings successively until a key is found.
    In contrast, writes, updates, and deletions only operate on the first
    mapping.

    '''
    def __init__(self, *maps) -> None:
        '''Initialize a ChainMap by setting *maps* to the given mappings.
        If no mappings are provided, a single empty dictionary is used.

        '''
        ...
    
    def __missing__(self, key):
        ...
    
    def __getitem__(self, key):
        ...
    
    def get(self, key, default=...): # -> None:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __iter__(self): # -> Iterator[Any]:
        ...
    
    def __contains__(self, key): # -> bool:
        ...
    
    def __bool__(self): # -> bool:
        ...
    
    __nonzero__ = ...
    @recursive_repr()
    def __repr__(self): # -> str:
        ...
    
    @classmethod
    def fromkeys(cls, iterable, *args): # -> Self:
        'Create a ChainMap with a single dict created from the iterable.'
        ...
    
    def copy(self): # -> Self:
        'New ChainMap or subclass with a new copy of maps[0] and refs to maps[1:]'
        ...
    
    __copy__ = ...
    def new_child(self, m=...): # -> Self:
        '''
        New ChainMap with a new map followed by all previous maps. If no
        map is provided, an empty dict is used.
        '''
        ...
    
    @property
    def parents(self): # -> Self:
        'New ChainMap from maps[1:].'
        ...
    
    def __setitem__(self, key, value): # -> None:
        ...
    
    def __delitem__(self, key): # -> None:
        ...
    
    def popitem(self):
        'Remove and return an item pair from maps[0]. Raise KeyError is maps[0] is empty.'
        ...
    
    def pop(self, key, *args):
        'Remove *key* from maps[0] and return its value. Raise KeyError if *key* not in maps[0].'
        ...
    
    def clear(self): # -> None:
        'Clear maps[0], leaving maps[1:] intact.'
        ...
    


def create_connection(address, timeout=..., source_address=...): # -> socket:
    """Backport of 3-argument create_connection() for Py2.6.

    Connect to *address* and return the socket object.

    Convenience function.  Connect to *address* (a 2-tuple ``(host,
    port)``) and return the socket object.  Passing the optional
    *timeout* parameter will set the timeout on the socket instance
    before attempting to connect.  If no *timeout* is supplied, the
    global default timeout setting returned by :func:`getdefaulttimeout`
    is used.  If *source_address* is set it must be a tuple of (host, port)
    for the socket to bind as a source address before making the connection.
    An host of '' or port 0 tells the OS to use the default.
    """
    ...

def cmp_to_key(mycmp): # -> type[K]:
    """Convert a cmp= function into a key= function"""
    class K:
        ...
    
    

_OrderedDict = OrderedDict
_Counter = Counter
_check_output = ...
_count = ...
_ceil = ...
__count_elements = ...
_recursive_repr = ...
_ChainMap = ChainMap
_create_connection = ...
_cmp_to_key = ...
if sys.version_info >= (2, 7):
    ...
if sys.version_info >= (3, 0):
    ...
if sys.version_info >= (3, 3):
    ...
