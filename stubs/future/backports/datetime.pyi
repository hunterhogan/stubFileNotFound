"""
This type stub file was generated by pyright.
"""

from _datetime import *

"""Concrete date/time and related types.

See http://www.iana.org/time-zones/repository/tz-link.html for
time zone and DST data sources.
"""
MINYEAR = ...
MAXYEAR = ...
_MAXORDINAL = ...
_DAYS_IN_MONTH = ...
_DAYS_BEFORE_MONTH = ...
dbm = ...
_DI400Y = ...
_DI100Y = ...
_DI4Y = ...
_MONTHNAMES = ...
_DAYNAMES = ...
class timedelta:
    """Represent the difference between two datetime objects.

    Supported operators:

    - add, subtract timedelta
    - unary plus, minus, abs
    - compare to timedelta
    - multiply, divide by int

    In addition, datetime supports subtraction of two datetime objects
    returning a timedelta, and addition or subtraction of a datetime
    and a timedelta giving a datetime.

    Representation: (days, seconds, microseconds).  Why?  Because I
    felt like it.
    """
    __slots__ = ...
    def __new__(cls, days=..., seconds=..., microseconds=..., milliseconds=..., minutes=..., hours=..., weeks=...): # -> Self:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __str__(self) -> str:
        ...
    
    def total_seconds(self):
        """Total seconds in the duration."""
        ...
    
    @property
    def days(self):
        """days"""
        ...
    
    @property
    def seconds(self):
        """seconds"""
        ...
    
    @property
    def microseconds(self):
        """microseconds"""
        ...
    
    def __add__(self, other): # -> timedelta | NotImplementedType:
        ...
    
    __radd__ = ...
    def __sub__(self, other): # -> timedelta | NotImplementedType:
        ...
    
    def __rsub__(self, other): # -> timedelta | NotImplementedType:
        ...
    
    def __neg__(self): # -> timedelta:
        ...
    
    def __pos__(self): # -> Self:
        ...
    
    def __abs__(self): # -> timedelta | Self:
        ...
    
    def __mul__(self, other): # -> timedelta | NotImplementedType | float | None:
        ...
    
    __rmul__ = ...
    def __floordiv__(self, other): # -> NotImplementedType | int | timedelta | None:
        ...
    
    def __truediv__(self, other): # -> NotImplementedType | float | timedelta | None:
        ...
    
    def __mod__(self, other): # -> timedelta | NotImplementedType:
        ...
    
    def __divmod__(self, other): # -> tuple[int, timedelta] | NotImplementedType:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    
    def __le__(self, other) -> bool:
        ...
    
    def __lt__(self, other) -> bool:
        ...
    
    def __ge__(self, other) -> bool:
        ...
    
    def __gt__(self, other) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __bool__(self): # -> bool:
        ...
    
    def __reduce__(self): # -> tuple[type[Self], tuple[Any, Any, Any]]:
        ...
    


class date:
    """Concrete date type.

    Constructors:

    __new__()
    fromtimestamp()
    today()
    fromordinal()

    Operators:

    __repr__, __str__
    __cmp__, __hash__
    __add__, __radd__, __sub__ (add/radd only with timedelta arg)

    Methods:

    timetuple()
    toordinal()
    weekday()
    isoweekday(), isocalendar(), isoformat()
    ctime()
    strftime()

    Properties (readonly):
    year, month, day
    """
    __slots__ = ...
    def __new__(cls, year, month=..., day=...): # -> Self:
        """Constructor.

        Arguments:

        year, month, day (required, base 1)
        """
        ...
    
    @classmethod
    def fromtimestamp(cls, t): # -> Self:
        "Construct a date from a POSIX timestamp (like time.time())."
        ...
    
    @classmethod
    def today(cls): # -> Self:
        "Construct a date from time.time()."
        ...
    
    @classmethod
    def fromordinal(cls, n): # -> Self:
        """Construct a date from a proleptic Gregorian ordinal.

        January 1 of year 1 is day 1.  Only the year, month and day are
        non-zero in the result.
        """
        ...
    
    def __repr__(self): # -> str:
        """Convert to formal string, for repr().

        >>> dt = datetime(2010, 1, 1)
        >>> repr(dt)
        'datetime.datetime(2010, 1, 1, 0, 0)'

        >>> dt = datetime(2010, 1, 1, tzinfo=timezone.utc)
        >>> repr(dt)
        'datetime.datetime(2010, 1, 1, 0, 0, tzinfo=datetime.timezone.utc)'
        """
        ...
    
    def ctime(self): # -> str:
        "Return ctime() style string."
        ...
    
    def strftime(self, fmt): # -> str:
        "Format using strftime()."
        ...
    
    def __format__(self, fmt): # -> str | newstr:
        ...
    
    def isoformat(self): # -> LiteralString:
        """Return the date formatted according to ISO.

        This is 'YYYY-MM-DD'.

        References:
        - http://www.w3.org/TR/NOTE-datetime
        - http://www.cl.cam.ac.uk/~mgk25/iso-time.html
        """
        ...
    
    __str__ = ...
    @property
    def year(self):
        """year (1-9999)"""
        ...
    
    @property
    def month(self):
        """month (1-12)"""
        ...
    
    @property
    def day(self):
        """day (1-31)"""
        ...
    
    def timetuple(self): # -> struct_time:
        "Return local time tuple compatible with time.localtime()."
        ...
    
    def toordinal(self):
        """Return proleptic Gregorian ordinal for the year, month and day.

        January 1 of year 1 is day 1.  Only the year, month and day values
        contribute to the result.
        """
        ...
    
    def replace(self, year=..., month=..., day=...): # -> date:
        """Return a new date with new values for the specified fields."""
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    
    def __le__(self, other) -> bool:
        ...
    
    def __lt__(self, other) -> bool:
        ...
    
    def __ge__(self, other) -> bool:
        ...
    
    def __gt__(self, other) -> bool:
        ...
    
    def __hash__(self) -> int:
        "Hash."
        ...
    
    def __add__(self, other): # -> date | NotImplementedType:
        "Add a date to a timedelta."
        ...
    
    __radd__ = ...
    def __sub__(self, other): # -> date | NotImplementedType | timedelta:
        """Subtract two dates, or a date and a timedelta."""
        ...
    
    def weekday(self):
        "Return day of the week, where Monday == 0 ... Sunday == 6."
        ...
    
    def isoweekday(self): # -> Literal[7]:
        "Return day of the week, where Monday == 1 ... Sunday == 7."
        ...
    
    def isocalendar(self): # -> tuple[Any, Any | int, Any]:
        """Return a 3-tuple containing ISO year, week number, and weekday.

        The first ISO week of the year is the (Mon-Sun) week
        containing the year's first Thursday; everything else derives
        from that.

        The first week is 1; Monday is 1 ... Sunday is 7.

        ISO calendar algorithm taken from
        http://www.phys.uu.nl/~vgent/calendar/isocalendar.htm
        """
        ...
    
    def __reduce__(self): # -> tuple[type[Self], tuple[Any | newbytes]]:
        ...
    


_date_class = date
class tzinfo:
    """Abstract base class for time zone info classes.

    Subclasses must override the name(), utcoffset() and dst() methods.
    """
    __slots__ = ...
    def tzname(self, dt):
        "datetime -> string name of time zone."
        ...
    
    def utcoffset(self, dt):
        "datetime -> minutes east of UTC (negative for west of UTC)"
        ...
    
    def dst(self, dt):
        """datetime -> DST offset in minutes east of UTC.

        Return 0 if DST not in effect.  utcoffset() must include the DST
        offset.
        """
        ...
    
    def fromutc(self, dt):
        "datetime in UTC -> datetime in local time."
        ...
    
    def __reduce__(self): # -> tuple[type[Self], Any | tuple[()]] | tuple[type[Self], Any | tuple[()], Any]:
        ...
    


_tzinfo_class = tzinfo
class time:
    """Time with time zone.

    Constructors:

    __new__()

    Operators:

    __repr__, __str__
    __cmp__, __hash__

    Methods:

    strftime()
    isoformat()
    utcoffset()
    tzname()
    dst()

    Properties (readonly):
    hour, minute, second, microsecond, tzinfo
    """
    def __new__(cls, hour=..., minute=..., second=..., microsecond=..., tzinfo=...): # -> Self:
        """Constructor.

        Arguments:

        hour, minute (required)
        second, microsecond (default to zero)
        tzinfo (default to None)
        """
        ...
    
    @property
    def hour(self):
        """hour (0-23)"""
        ...
    
    @property
    def minute(self):
        """minute (0-59)"""
        ...
    
    @property
    def second(self):
        """second (0-59)"""
        ...
    
    @property
    def microsecond(self):
        """microsecond (0-999999)"""
        ...
    
    @property
    def tzinfo(self): # -> _tzinfo_class:
        """timezone info object"""
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    
    def __le__(self, other) -> bool:
        ...
    
    def __lt__(self, other) -> bool:
        ...
    
    def __ge__(self, other) -> bool:
        ...
    
    def __gt__(self, other) -> bool:
        ...
    
    def __hash__(self) -> int:
        """Hash."""
        ...
    
    def __repr__(self): # -> str:
        """Convert to formal string, for repr()."""
        ...
    
    def isoformat(self): # -> str | LiteralString:
        """Return the time formatted according to ISO.

        This is 'HH:MM:SS.mmmmmm+zz:zz', or 'HH:MM:SS+zz:zz' if
        self.microsecond == 0.
        """
        ...
    
    __str__ = ...
    def strftime(self, fmt): # -> str:
        """Format using strftime().  The date part of the timestamp passed
        to underlying strftime should not be used.
        """
        ...
    
    def __format__(self, fmt): # -> str | newstr:
        ...
    
    def utcoffset(self): # -> None:
        """Return the timezone offset in minutes east of UTC (negative west of
        UTC)."""
        ...
    
    def tzname(self): # -> None:
        """Return the timezone name.

        Note that the name is 100% informational -- there's no requirement that
        it mean anything in particular. For example, "GMT", "UTC", "-500",
        "-5:00", "EDT", "US/Eastern", "America/New York" are all valid replies.
        """
        ...
    
    def dst(self): # -> None:
        """Return 0 if DST is not in effect, or the DST offset (in minutes
        eastward) if DST is in effect.

        This is purely informational; the DST offset has already been added to
        the UTC offset returned by utcoffset() if applicable, so there's no
        need to consult dst() unless you're interested in displaying the DST
        info.
        """
        ...
    
    def replace(self, hour=..., minute=..., second=..., microsecond=..., tzinfo=...): # -> time:
        """Return a new time with new values for the specified fields."""
        ...
    
    def __bool__(self): # -> bool:
        ...
    
    def __reduce__(self): # -> tuple[type[time], tuple[Any | newbytes] | tuple[Any | newbytes, Any | _tzinfo_class]]:
        ...
    


_time_class = time
class datetime(date):
    """datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])

    The year, month and day arguments are required. tzinfo may be None, or an
    instance of a tzinfo subclass. The remaining arguments may be ints.
    """
    __slots__ = ...
    def __new__(cls, year, month=..., day=..., hour=..., minute=..., second=..., microsecond=..., tzinfo=...): # -> Self:
        ...
    
    @property
    def hour(self):
        """hour (0-23)"""
        ...
    
    @property
    def minute(self):
        """minute (0-59)"""
        ...
    
    @property
    def second(self):
        """second (0-59)"""
        ...
    
    @property
    def microsecond(self):
        """microsecond (0-999999)"""
        ...
    
    @property
    def tzinfo(self): # -> _tzinfo_class:
        """timezone info object"""
        ...
    
    @classmethod
    def fromtimestamp(cls, t, tz=...): # -> Self:
        """Construct a datetime from a POSIX timestamp (like time.time()).

        A timezone info object may be passed in as well.
        """
        ...
    
    @classmethod
    def utcfromtimestamp(cls, t): # -> Self:
        "Construct a UTC datetime from a POSIX timestamp (like time.time())."
        ...
    
    @classmethod
    def now(cls, tz=...): # -> Self:
        "Construct a datetime from time.time() and optional time zone info."
        ...
    
    @classmethod
    def utcnow(cls): # -> Self:
        "Construct a UTC datetime from time.time()."
        ...
    
    @classmethod
    def combine(cls, date, time): # -> Self:
        "Construct a datetime from a given date and a given time."
        ...
    
    def timetuple(self): # -> struct_time:
        "Return local time tuple compatible with time.localtime()."
        ...
    
    def timestamp(self): # -> Any:
        "Return POSIX timestamp as float"
        ...
    
    def utctimetuple(self): # -> struct_time:
        "Return UTC time tuple compatible with time.gmtime()."
        ...
    
    def date(self): # -> date:
        "Return the date part."
        ...
    
    def time(self): # -> time:
        "Return the time part, with tzinfo None."
        ...
    
    def timetz(self): # -> time:
        "Return the time part, with same tzinfo."
        ...
    
    def replace(self, year=..., month=..., day=..., hour=..., minute=..., second=..., microsecond=..., tzinfo=...): # -> datetime:
        """Return a new datetime with new values for the specified fields."""
        ...
    
    def astimezone(self, tz=...): # -> Self | NotImplementedType | datetime:
        ...
    
    def ctime(self): # -> str:
        "Return ctime() style string."
        ...
    
    def isoformat(self, sep=...): # -> str:
        """Return the time formatted according to ISO.

        This is 'YYYY-MM-DD HH:MM:SS.mmmmmm', or 'YYYY-MM-DD HH:MM:SS' if
        self.microsecond == 0.

        If self.tzinfo is not None, the UTC offset is also attached, giving
        'YYYY-MM-DD HH:MM:SS.mmmmmm+HH:MM' or 'YYYY-MM-DD HH:MM:SS+HH:MM'.

        Optional argument sep specifies the separator between date and
        time, default 'T'.
        """
        ...
    
    def __repr__(self): # -> str:
        """Convert to formal string, for repr()."""
        ...
    
    def __str__(self) -> str:
        "Convert to string, for str()."
        ...
    
    @classmethod
    def strptime(cls, date_string, format):
        'string, format -> new datetime parsed from a string (like time.strptime()).'
        ...
    
    def utcoffset(self): # -> None:
        """Return the timezone offset in minutes east of UTC (negative west of
        UTC)."""
        ...
    
    def tzname(self): # -> Any | None:
        """Return the timezone name.

        Note that the name is 100% informational -- there's no requirement that
        it mean anything in particular. For example, "GMT", "UTC", "-500",
        "-5:00", "EDT", "US/Eastern", "America/New York" are all valid replies.
        """
        ...
    
    def dst(self): # -> None:
        """Return 0 if DST is not in effect, or the DST offset (in minutes
        eastward) if DST is in effect.

        This is purely informational; the DST offset has already been added to
        the UTC offset returned by utcoffset() if applicable, so there's no
        need to consult dst() unless you're interested in displaying the DST
        info.
        """
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    
    def __le__(self, other) -> bool:
        ...
    
    def __lt__(self, other) -> bool:
        ...
    
    def __ge__(self, other) -> bool:
        ...
    
    def __gt__(self, other) -> bool:
        ...
    
    def __add__(self, other): # -> NotImplementedType | datetime:
        "Add a datetime and a timedelta."
        ...
    
    __radd__ = ...
    def __sub__(self, other): # -> NotImplementedType | datetime | timedelta:
        "Subtract two datetimes, or a datetime and a timedelta."
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __reduce__(self): # -> tuple[type[Self], tuple[Any | newbytes] | tuple[Any | newbytes, Any | _tzinfo_class]]:
        ...
    


class timezone(tzinfo):
    __slots__ = ...
    _Omitted = ...
    def __new__(cls, offset, name=...): # -> Self:
        ...
    
    def __getinitargs__(self): # -> tuple[Any] | tuple[Any, Any]:
        """pickle support"""
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __repr__(self): # -> str:
        """Convert to formal string, for repr().

        >>> tz = timezone.utc
        >>> repr(tz)
        'datetime.timezone.utc'
        >>> tz = timezone(timedelta(hours=-5), 'EST')
        >>> repr(tz)
        "datetime.timezone(datetime.timedelta(-1, 68400), 'EST')"
        """
        ...
    
    def __str__(self) -> str:
        ...
    
    def utcoffset(self, dt):
        ...
    
    def tzname(self, dt): # -> str:
        ...
    
    def dst(self, dt): # -> None:
        ...
    
    def fromutc(self, dt): # -> NotImplementedType | datetime:
        ...
    
    _maxoffset = ...
    _minoffset = ...


_EPOCH = ...
