"""
This type stub file was generated by pyright.
"""

import io
from future.utils import PY2
from future.backports.email import message as email_message

"""HTTP/1.1 client library

A backport of the Python 3.3 http/client.py module for python-future.

<intro stuff goes here>
<other stuff, too>

HTTPConnection goes through a number of "states", which define when a client
may legally make another request or fetch the response for a particular
request. This diagram details these state transitions:

    (null)
      |
      | HTTPConnection()
      v
    Idle
      |
      | putrequest()
      v
    Request-started
      |
      | ( putheader() )*  endheaders()
      v
    Request-sent
      |
      | response = getresponse()
      v
    Unread-response   [Response-headers-read]
      |\____________________
      |                     |
      | response.read()     | putrequest()
      v                     v
    Idle                  Req-started-unread-response
                     ______/|
                   /        |
   response.read() |        | ( putheader() )*  endheaders()
                   v        v
       Request-started    Req-sent-unread-response
                            |
                            | response.read()
                            v
                          Request-sent

This diagram presents the following rules:
  -- a second request may not be started until {response-headers-read}
  -- a response [object] cannot be retrieved until {request-sent}
  -- there is no differentiation between an unread response body and a
     partially read response body

Note: this enforcement is applied by the HTTPConnection class. The
      HTTPResponse class does not enforce this state machine, which
      implies sophisticated clients may accelerate the request/response
      pipeline. Caution should be taken, though: accelerating the states
      beyond the above pattern may imply knowledge of the server's
      connection-close behavior for certain requests. For example, it
      is impossible to tell whether the server will close the connection
      UNTIL the response headers have been read; this means that further
      requests cannot be placed into the pipeline until it is known that
      the server will NOT be closing the connection.

Logical State                  __state            __response
-------------                  -------            ----------
Idle                           _CS_IDLE           None
Request-started                _CS_REQ_STARTED    None
Request-sent                   _CS_REQ_SENT       None
Unread-response                _CS_IDLE           <response_class>
Req-started-unread-response    _CS_REQ_STARTED    <response_class>
Req-sent-unread-response       _CS_REQ_SENT       <response_class>
"""
if PY2:
    ...
else:
    ...
__all__ = ["HTTPResponse", "HTTPConnection", "HTTPException", "NotConnected", "UnknownProtocol", "UnknownTransferEncoding", "UnimplementedFileMode", "IncompleteRead", "InvalidURL", "ImproperConnectionState", "CannotSendRequest", "CannotSendHeader", "ResponseNotReady", "BadStatusLine", "error", "responses"]
HTTP_PORT = ...
HTTPS_PORT = ...
_UNKNOWN = ...
_CS_IDLE = ...
_CS_REQ_STARTED = ...
_CS_REQ_SENT = ...
CONTINUE = ...
SWITCHING_PROTOCOLS = ...
PROCESSING = ...
OK = ...
CREATED = ...
ACCEPTED = ...
NON_AUTHORITATIVE_INFORMATION = ...
NO_CONTENT = ...
RESET_CONTENT = ...
PARTIAL_CONTENT = ...
MULTI_STATUS = ...
IM_USED = ...
MULTIPLE_CHOICES = ...
MOVED_PERMANENTLY = ...
FOUND = ...
SEE_OTHER = ...
NOT_MODIFIED = ...
USE_PROXY = ...
TEMPORARY_REDIRECT = ...
BAD_REQUEST = ...
UNAUTHORIZED = ...
PAYMENT_REQUIRED = ...
FORBIDDEN = ...
NOT_FOUND = ...
METHOD_NOT_ALLOWED = ...
NOT_ACCEPTABLE = ...
PROXY_AUTHENTICATION_REQUIRED = ...
REQUEST_TIMEOUT = ...
CONFLICT = ...
GONE = ...
LENGTH_REQUIRED = ...
PRECONDITION_FAILED = ...
REQUEST_ENTITY_TOO_LARGE = ...
REQUEST_URI_TOO_LONG = ...
UNSUPPORTED_MEDIA_TYPE = ...
REQUESTED_RANGE_NOT_SATISFIABLE = ...
EXPECTATION_FAILED = ...
UNPROCESSABLE_ENTITY = ...
LOCKED = ...
FAILED_DEPENDENCY = ...
UPGRADE_REQUIRED = ...
PRECONDITION_REQUIRED = ...
TOO_MANY_REQUESTS = ...
REQUEST_HEADER_FIELDS_TOO_LARGE = ...
INTERNAL_SERVER_ERROR = ...
NOT_IMPLEMENTED = ...
BAD_GATEWAY = ...
SERVICE_UNAVAILABLE = ...
GATEWAY_TIMEOUT = ...
HTTP_VERSION_NOT_SUPPORTED = ...
INSUFFICIENT_STORAGE = ...
NOT_EXTENDED = ...
NETWORK_AUTHENTICATION_REQUIRED = ...
responses = ...
MAXAMOUNT = ...
_MAXLINE = ...
_MAXHEADERS = ...
class HTTPMessage(email_message.Message):
    def getallmatchingheaders(self, name): # -> list[Any]:
        """Find all header lines matching a given header name.

        Look through the list of headers and find all lines matching a given
        header name (and their continuation lines).  A list of the lines is
        returned, without interpretation.  If the header does not occur, an
        empty list is returned.  If the header occurs multiple times, all
        occurrences are returned.  Case is not important in the header name.

        """
        ...
    


def parse_headers(fp, _class=...):
    """Parses only RFC2822 headers from a file pointer.

    email Parser wants to see strings rather than bytes.
    But a TextIOWrapper around self.rfile would buffer too many bytes
    from the stream, bytes which we later need to read as bytes.
    So we read the correct bytes here, as bytes, for email Parser
    to parse.

    """
    ...

_strict_sentinel = ...
class HTTPResponse(io.RawIOBase):
    def __init__(self, sock, debuglevel=..., strict=..., method=..., url=...) -> None:
        ...
    
    def begin(self): # -> None:
        ...
    
    def close(self): # -> None:
        ...
    
    def flush(self): # -> None:
        ...
    
    def readable(self): # -> Literal[True]:
        ...
    
    def isclosed(self): # -> bool:
        """True if the connection is closed."""
        ...
    
    def read(self, amt=...): # -> newbytes:
        ...
    
    def readinto(self, b): # -> int:
        ...
    
    def fileno(self):
        ...
    
    def getheader(self, name, default=...): # -> newstr | None:
        ...
    
    def getheaders(self): # -> list[Any]:
        """Return list of (header, value) tuples."""
        ...
    
    def __iter__(self): # -> Self:
        ...
    
    def info(self): # -> None:
        ...
    
    def geturl(self):
        ...
    
    def getcode(self): # -> str | newint:
        ...
    


class HTTPConnection:
    _http_vsn = ...
    _http_vsn_str = ...
    response_class = HTTPResponse
    default_port = ...
    auto_open = ...
    debuglevel = ...
    def __init__(self, host, port=..., strict=..., timeout=..., source_address=...) -> None:
        ...
    
    def set_tunnel(self, host, port=..., headers=...): # -> None:
        """ Sets up the host and the port for the HTTP CONNECT Tunnelling.

        The headers argument should be a mapping of extra HTTP headers
        to send with the CONNECT request.
        """
        ...
    
    def set_debuglevel(self, level): # -> None:
        ...
    
    def connect(self): # -> None:
        """Connect to the host and port specified in __init__."""
        ...
    
    def close(self): # -> None:
        """Close the connection to the HTTP server."""
        ...
    
    def send(self, data): # -> None:
        """Send `data' to the server.
        ``data`` can be a string object, a bytes object, an array object, a
        file-like object that supports a .read() method, or an iterable object.
        """
        ...
    
    def putrequest(self, method, url, skip_host=..., skip_accept_encoding=...): # -> None:
        """Send a request to the server.

        `method' specifies an HTTP request method, e.g. 'GET'.
        `url' specifies the object being requested, e.g. '/index.html'.
        `skip_host' if True does not add automatically a 'Host:' header
        `skip_accept_encoding' if True does not add automatically an
           'Accept-Encoding:' header
        """
        ...
    
    def putheader(self, header, *values): # -> None:
        """Send a request header line to the server.

        For example: h.putheader('Accept', 'text/html')
        """
        ...
    
    def endheaders(self, message_body=...): # -> None:
        """Indicate that the last header line has been sent to the server.

        This method sends the request to the server.  The optional message_body
        argument can be used to pass a message body associated with the
        request.  The message body will be sent in the same packet as the
        message headers if it is a string, otherwise it is sent as a separate
        packet.
        """
        ...
    
    def request(self, method, url, body=..., headers=...): # -> None:
        """Send a complete request to the server."""
        ...
    
    def getresponse(self): # -> response_class:
        """Get the response from the server.

        If the HTTPConnection is in the correct state, returns an
        instance of HTTPResponse or of whatever object is returned by
        class the response_class variable.

        If a request has not been sent or if a previous response has
        not be handled, ResponseNotReady is raised.  If the HTTP
        response indicates that the connection should be closed, then
        it will be closed before the response is returned.  When the
        connection is closed, the underlying socket is closed.
        """
        ...
    


class HTTPException(Exception):
    ...


class NotConnected(HTTPException):
    ...


class InvalidURL(HTTPException):
    ...


class UnknownProtocol(HTTPException):
    def __init__(self, version) -> None:
        ...
    


class UnknownTransferEncoding(HTTPException):
    ...


class UnimplementedFileMode(HTTPException):
    ...


class IncompleteRead(HTTPException):
    def __init__(self, partial, expected=...) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __str__(self) -> str:
        ...
    


class ImproperConnectionState(HTTPException):
    ...


class CannotSendRequest(ImproperConnectionState):
    ...


class CannotSendHeader(ImproperConnectionState):
    ...


class ResponseNotReady(ImproperConnectionState):
    ...


class BadStatusLine(HTTPException):
    def __init__(self, line) -> None:
        ...
    


class LineTooLong(HTTPException):
    def __init__(self, line_type) -> None:
        ...
    


error = HTTPException
