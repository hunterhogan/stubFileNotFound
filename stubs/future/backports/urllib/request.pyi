"""
This type stub file was generated by pyright.
"""

import os
import sys
from future.utils import PY2, PY3
from future.backports.http import client as http_client

"""
Ported using Python-Future from the Python 3.3 standard library.

An extensible library for opening URLs using a variety of protocols

The simplest way to use this module is to call the urlopen function,
which accepts a string containing a URL or a Request object (described
below).  It opens the URL and returns the results as file-like
object; the returned object has some extra methods described below.

The OpenerDirector manages a collection of Handler objects that do
all the actual work.  Each Handler implements a particular protocol or
option.  The OpenerDirector is a composite object that invokes the
Handlers needed to open the requested URL.  For example, the
HTTPHandler performs HTTP GET and POST requests and deals with
non-error returns.  The HTTPRedirectHandler automatically deals with
HTTP 301, 302, 303 and 307 redirect errors, and the HTTPDigestAuthHandler
deals with digest authentication.

urlopen(url, data=None) -- Basic usage is the same as original
urllib.  pass the url and optionally data to post to an HTTP URL, and
get a file-like object back.  One difference is that you can also pass
a Request instance instead of URL.  Raises a URLError (subclass of
IOError); for HTTP errors, raises an HTTPError, which can also be
treated as a valid response.

build_opener -- Function that creates a new OpenerDirector instance.
Will install the default handlers.  Accepts one or more Handlers as
arguments, either instances or Handler classes that it will
instantiate.  If one of the argument is a subclass of the default
handler, the argument will be installed instead of the default.

install_opener -- Installs a new opener as the default opener.

objects of interest:

OpenerDirector -- Sets up the User Agent as the Python-urllib client and manages
the Handler classes, while dealing with requests and responses.

Request -- An object that encapsulates the state of a request.  The
state can be as simple as the URL.  It can also include extra HTTP
headers, e.g. a User-Agent.

BaseHandler --

internals:
BaseHandler and parent
_call_chain conventions

Example usage:

import urllib.request

# set up authentication info
authinfo = urllib.request.HTTPBasicAuthHandler()
authinfo.add_password(realm='PDQ Application',
                      uri='https://mahler:8092/site-updates.py',
                      user='klem',
                      passwd='geheim$parole')

proxy_support = urllib.request.ProxyHandler({"http" : "http://ahad-haam:3128"})

# build a new opener that adds authentication and caching FTP handlers
opener = urllib.request.build_opener(proxy_support, authinfo,
                                     urllib.request.CacheFTPHandler)

# install it
urllib.request.install_opener(opener)

f = urllib.request.urlopen('http://www.python.org/')
"""
if PY2:
    ...
else:
    ...
__all__ = ['Request', 'OpenerDirector', 'BaseHandler', 'HTTPDefaultErrorHandler', 'HTTPRedirectHandler', 'HTTPCookieProcessor', 'ProxyHandler', 'HTTPPasswordMgr', 'HTTPPasswordMgrWithDefaultRealm', 'AbstractBasicAuthHandler', 'HTTPBasicAuthHandler', 'ProxyBasicAuthHandler', 'AbstractDigestAuthHandler', 'HTTPDigestAuthHandler', 'ProxyDigestAuthHandler', 'HTTPHandler', 'FileHandler', 'FTPHandler', 'CacheFTPHandler', 'UnknownHandler', 'HTTPErrorProcessor', 'urlopen', 'install_opener', 'build_opener', 'pathname2url', 'url2pathname', 'getproxies', 'urlretrieve', 'urlcleanup', 'URLopener', 'FancyURLopener']
__version__ = ...
_opener = ...
def urlopen(url, data=..., timeout=..., **_3to2kwargs): # -> Any | None:
    ...

def install_opener(opener): # -> None:
    ...

_url_tempfiles = ...
def urlretrieve(url, filename=..., reporthook=..., data=...): # -> tuple[Any, Any] | tuple[Any | str, Any]:
    """
    Retrieve a URL into a temporary location on disk.

    Requires a URL argument. If a filename is passed, it is used as
    the temporary file location. The reporthook argument should be
    a callable that accepts a block number, a read size, and the
    total file size of the URL target. The data argument should be
    valid URL encoded data.

    If a filename is passed and the URL points to a local resource,
    the result is a copy from local file to new file.

    Returns a tuple containing the path to the newly created
    data file as well as the resulting HTTPMessage object.
    """
    ...

def urlcleanup(): # -> None:
    ...

if PY3:
    _cut_port_re = ...
else:
    _cut_port_re = ...
def request_host(request): # -> str:
    """Return request-host, as defined by RFC 2965.

    Variation from RFC: returned value is lowercased, for convenient
    comparison.

    """
    ...

class Request:
    def __init__(self, url, data=..., headers=..., origin_req_host=..., unverifiable=..., method=...) -> None:
        ...
    
    def get_method(self): # -> Literal['POST', 'GET']:
        """Return a string indicating the HTTP request method."""
        ...
    
    def get_full_url(self): # -> str | Any:
        ...
    
    def add_data(self, data): # -> None:
        ...
    
    def has_data(self): # -> bool:
        ...
    
    def get_data(self): # -> None:
        ...
    
    def get_type(self): # -> str | Any | None:
        ...
    
    def get_host(self): # -> str | Any | None:
        ...
    
    def get_selector(self): # -> str | Any:
        ...
    
    def is_unverifiable(self): # -> bool:
        ...
    
    def get_origin_req_host(self): # -> str:
        ...
    
    def set_proxy(self, host, type): # -> None:
        ...
    
    def has_proxy(self): # -> bool | Any:
        ...
    
    def add_header(self, key, val): # -> None:
        ...
    
    def add_unredirected_header(self, key, val): # -> None:
        ...
    
    def has_header(self, header_name): # -> bool:
        ...
    
    def get_header(self, header_name, default=...): # -> None:
        ...
    
    def header_items(self): # -> list[tuple[Any, Any]]:
        ...
    


class OpenerDirector:
    def __init__(self) -> None:
        ...
    
    def add_handler(self, handler): # -> None:
        ...
    
    def close(self): # -> None:
        ...
    
    def open(self, fullurl, data=..., timeout=...): # -> Any | None:
        """
        Accept a URL or a Request object

        Python-Future: if the URL is passed as a byte-string, decode it first.
        """
        ...
    
    def error(self, proto, *args): # -> Any | None:
        ...
    


def build_opener(*handlers): # -> OpenerDirector:
    """Create an opener object from a list of handlers.

    The opener will use several default handlers, including support
    for HTTP, FTP and when applicable HTTPS.

    If any of the handlers passed as arguments are subclasses of the
    default handlers, the default handlers will not be used.
    """
    ...

class BaseHandler:
    handler_order = ...
    def add_parent(self, parent): # -> None:
        ...
    
    def close(self): # -> None:
        ...
    
    def __lt__(self, other) -> bool:
        ...
    


class HTTPErrorProcessor(BaseHandler):
    """Process HTTP error responses."""
    handler_order = ...
    def http_response(self, request, response):
        ...
    
    https_response = ...


class HTTPDefaultErrorHandler(BaseHandler):
    def http_error_default(self, req, fp, code, msg, hdrs):
        ...
    


class HTTPRedirectHandler(BaseHandler):
    max_repeats = ...
    max_redirections = ...
    def redirect_request(self, req, fp, code, msg, headers, newurl): # -> Request:
        """Return a Request or None in response to a redirect.

        This is called by the http_error_30x methods when a
        redirection response is received.  If a redirection should
        take place, return a new Request to allow http_error_30x to
        perform the redirect.  Otherwise, raise HTTPError if no-one
        else should try to handle this url.  Return None if you can't
        but another Handler might.
        """
        ...
    
    def http_error_302(self, req, fp, code, msg, headers): # -> None:
        ...
    
    http_error_307 = ...
    inf_msg = ...


class ProxyHandler(BaseHandler):
    handler_order = ...
    def __init__(self, proxies=...) -> None:
        ...
    
    def proxy_open(self, req, proxy, type): # -> None:
        ...
    


class HTTPPasswordMgr:
    def __init__(self) -> None:
        ...
    
    def add_password(self, realm, uri, user, passwd): # -> None:
        ...
    
    def find_user_password(self, realm, authuri): # -> tuple[None, None]:
        ...
    
    def reduce_uri(self, uri, default_port=...): # -> tuple[str | Any, Any | Literal['/']]:
        """Accept authority or URI and extract only the authority and path."""
        ...
    
    def is_suburi(self, base, test): # -> bool:
        """Check if test is below base in a URI tree

        Both args must be URIs in reduced form.
        """
        ...
    


class HTTPPasswordMgrWithDefaultRealm(HTTPPasswordMgr):
    def find_user_password(self, realm, authuri): # -> tuple[Any, Any | None] | tuple[None, None]:
        ...
    


class AbstractBasicAuthHandler:
    rx = ...
    def __init__(self, password_mgr=...) -> None:
        ...
    
    def reset_retry_count(self): # -> None:
        ...
    
    def http_error_auth_reqed(self, authreq, host, req, headers): # -> None:
        ...
    
    def retry_http_basic_auth(self, host, req, realm): # -> None:
        ...
    


class HTTPBasicAuthHandler(AbstractBasicAuthHandler, BaseHandler):
    auth_header = ...
    def http_error_401(self, req, fp, code, msg, headers): # -> None:
        ...
    


class ProxyBasicAuthHandler(AbstractBasicAuthHandler, BaseHandler):
    auth_header = ...
    def http_error_407(self, req, fp, code, msg, headers): # -> None:
        ...
    


_randombytes = ...
class AbstractDigestAuthHandler:
    def __init__(self, passwd=...) -> None:
        ...
    
    def reset_retry_count(self): # -> None:
        ...
    
    def http_error_auth_reqed(self, auth_header, host, req, headers): # -> None:
        ...
    
    def retry_http_digest_auth(self, req, auth): # -> None:
        ...
    
    def get_cnonce(self, nonce): # -> str:
        ...
    
    def get_authorization(self, req, chal): # -> None:
        ...
    
    def get_algorithm_impls(self, algorithm): # -> tuple[Callable[..., str] | Any, Callable[..., str]]:
        ...
    
    def get_entity_digest(self, data, chal): # -> None:
        ...
    


class HTTPDigestAuthHandler(BaseHandler, AbstractDigestAuthHandler):
    """An authentication protocol defined by RFC 2069

    Digest authentication improves on basic authentication because it
    does not transmit passwords in the clear.
    """
    auth_header = ...
    handler_order = ...
    def http_error_401(self, req, fp, code, msg, headers): # -> None:
        ...
    


class ProxyDigestAuthHandler(BaseHandler, AbstractDigestAuthHandler):
    auth_header = ...
    handler_order = ...
    def http_error_407(self, req, fp, code, msg, headers): # -> None:
        ...
    


class AbstractHTTPHandler(BaseHandler):
    def __init__(self, debuglevel=...) -> None:
        ...
    
    def set_http_debuglevel(self, level): # -> None:
        ...
    
    def do_request_(self, request):
        ...
    
    def do_open(self, http_class, req, **http_conn_args):
        """Return an HTTPResponse object for the request, using http_class.

        http_class must implement the HTTPConnection API from http.client.
        """
        ...
    


class HTTPHandler(AbstractHTTPHandler):
    def http_open(self, req): # -> response_class:
        ...
    
    http_request = ...


if hasattr(http_client, 'HTTPSConnection'):
    class HTTPSHandler(AbstractHTTPHandler):
        def __init__(self, debuglevel=..., context=..., check_hostname=...) -> None:
            ...
        
        def https_open(self, req): # -> response_class:
            ...
        
        https_request = ...
    
    
class HTTPCookieProcessor(BaseHandler):
    def __init__(self, cookiejar=...) -> None:
        ...
    
    def http_request(self, request):
        ...
    
    def http_response(self, request, response):
        ...
    
    https_request = ...
    https_response = ...


class UnknownHandler(BaseHandler):
    def unknown_open(self, req):
        ...
    


def parse_keqv_list(l): # -> dict[Any, Any]:
    """Parse list of key=value strings where keys are not duplicated."""
    ...

def parse_http_list(s): # -> list[Any]:
    """Parse lists as described by RFC 2068 Section 2.

    In particular, parse comma-separated lists where the elements of
    the list may include quoted-strings.  A quoted-string could
    contain a comma.  A non-quoted string could have quotes in the
    middle.  Neither commas nor quotes count if they are escaped.
    Only double-quotes count, not single-quotes.
    """
    ...

class FileHandler(BaseHandler):
    def file_open(self, req): # -> addinfourl | None:
        ...
    
    names = ...
    def get_names(self): # -> tuple[str, ...] | tuple[str]:
        ...
    
    def open_local_file(self, req): # -> addinfourl:
        ...
    


class FTPHandler(BaseHandler):
    def ftp_open(self, req):
        ...
    
    def connect_ftp(self, user, passwd, host, port, dirs, timeout): # -> ftpwrapper:
        ...
    


class CacheFTPHandler(FTPHandler):
    def __init__(self) -> None:
        ...
    
    def setTimeout(self, t): # -> None:
        ...
    
    def setMaxConns(self, m): # -> None:
        ...
    
    def connect_ftp(self, user, passwd, host, port, dirs, timeout):
        ...
    
    def check_cache(self): # -> None:
        ...
    
    def clear_cache(self): # -> None:
        ...
    


MAXFTPCACHE = ...
if os.name == 'nt':
    ...
else:
    ...
ftpcache = ...
class URLopener:
    """Class to open URLs.
    This is a class rather than just a subroutine because we may need
    more than one set of global protocol-specific options.
    Note -- this is a base class for those who don't want the
    automatic handling of errors type 302 (relocated) and 401
    (authorization needed)."""
    __tempfiles = ...
    version = ...
    def __init__(self, proxies=..., **x509) -> None:
        ...
    
    def __del__(self): # -> None:
        ...
    
    def close(self): # -> None:
        ...
    
    def cleanup(self): # -> None:
        ...
    
    def addheader(self, *args): # -> None:
        """Add a header to be used by the HTTP interface only
        e.g. u.addheader('Accept', 'sound/basic')"""
        ...
    
    def open(self, fullurl, data=...): # -> addinfourl | Any | None:
        """Use URLopener().open(file) instead of open(file, 'r')."""
        ...
    
    def open_unknown(self, fullurl, data=...):
        """Overridable interface to open unknown URL type."""
        ...
    
    def open_unknown_proxy(self, proxy, fullurl, data=...):
        """Overridable interface to open unknown URL type."""
        ...
    
    def retrieve(self, url, filename=..., reporthook=..., data=...): # -> tuple[str, Any] | tuple[Any | str, Any]:
        """retrieve(url) returns (filename, headers) for a local object
        or (tempfilename, headers) for a remote object."""
        ...
    
    def open_http(self, url, data=...): # -> addinfourl | Any:
        """Use HTTP protocol."""
        ...
    
    def http_error(self, url, fp, errcode, errmsg, headers, data=...): # -> Any:
        """Handle http errors.

        Derived class can override this, or provide specific handlers
        named http_error_DDD where DDD is the 3-digit error code."""
        ...
    
    def http_error_default(self, url, fp, errcode, errmsg, headers):
        """Default error handler: close the connection and raise IOError."""
        ...
    
    if _have_ssl:
        def open_https(self, url, data=...): # -> addinfourl | Any:
            """Use HTTPS protocol."""
            ...
        
    def open_file(self, url): # -> addinfourl:
        """Use local file or FTP depending on form of URL."""
        ...
    
    def open_local_file(self, url): # -> addinfourl:
        """Use local file."""
        ...
    
    def open_ftp(self, url):
        """Use FTP protocol."""
        ...
    
    def open_data(self, url, data=...): # -> addinfourl:
        """Use "data" URL."""
        ...
    


class FancyURLopener(URLopener):
    """Derived class with handlers for errors we can handle (perhaps)."""
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def http_error_default(self, url, fp, errcode, errmsg, headers): # -> addinfourl:
        """Default error handling -- don't raise an exception."""
        ...
    
    def http_error_302(self, url, fp, errcode, errmsg, headers, data=...): # -> addinfourl | Any | None:
        """Error 302 -- relocated (temporarily)."""
        ...
    
    def redirect_internal(self, url, fp, errcode, errmsg, headers, data): # -> addinfourl | Any | None:
        ...
    
    def http_error_301(self, url, fp, errcode, errmsg, headers, data=...): # -> addinfourl | Any | None:
        """Error 301 -- also relocated (permanently)."""
        ...
    
    def http_error_303(self, url, fp, errcode, errmsg, headers, data=...): # -> addinfourl | Any | None:
        """Error 303 -- also relocated (essentially identical to 302)."""
        ...
    
    def http_error_307(self, url, fp, errcode, errmsg, headers, data=...): # -> addinfourl | Any | None:
        """Error 307 -- relocated, but turn POST into error."""
        ...
    
    def http_error_401(self, url, fp, errcode, errmsg, headers, data=..., retry=...): # -> Any:
        """Error 401 -- authentication required.
        This function supports Basic authentication only."""
        ...
    
    def http_error_407(self, url, fp, errcode, errmsg, headers, data=..., retry=...): # -> Any:
        """Error 407 -- proxy authentication required.
        This function supports Basic authentication only."""
        ...
    
    def retry_proxy_http_basic_auth(self, url, realm, data=...): # -> addinfourl | Any | None:
        ...
    
    def retry_proxy_https_basic_auth(self, url, realm, data=...): # -> addinfourl | Any | None:
        ...
    
    def retry_http_basic_auth(self, url, realm, data=...): # -> addinfourl | Any | None:
        ...
    
    def retry_https_basic_auth(self, url, realm, data=...): # -> addinfourl | Any | None:
        ...
    
    def get_user_passwd(self, host, realm, clear_cache=...): # -> tuple[str | None, str | None]:
        ...
    
    def prompt_user_passwd(self, host, realm): # -> tuple[str, str] | tuple[None, None]:
        """Override this in a GUI environment!"""
        ...
    


_localhost = ...
def localhost(): # -> str:
    """Return the IP address of the magic hostname 'localhost'."""
    ...

_thishost = ...
def thishost(): # -> tuple[str, ...]:
    """Return the IP addresses of the current host."""
    ...

_ftperrors = ...
def ftperrors(): # -> tuple[type[Exception], ...]:
    """Return the set of errors raised by the FTP class."""
    ...

_noheaders = ...
def noheaders():
    """Return an empty email Message object."""
    ...

class ftpwrapper:
    """Class used by open_ftp() for cache of open FTP connections."""
    def __init__(self, user, passwd, host, port, dirs, timeout=..., persistent=...) -> None:
        ...
    
    def init(self): # -> None:
        ...
    
    def retrfile(self, file, type): # -> tuple[addclosehook, int | Any | None]:
        ...
    
    def endtransfer(self): # -> None:
        ...
    
    def close(self): # -> None:
        ...
    
    def file_close(self): # -> None:
        ...
    
    def real_close(self): # -> None:
        ...
    


def getproxies_environment(): # -> dict[Any, Any]:
    """Return a dictionary of scheme -> proxy server URL mappings.

    Scan the environment for variables named <scheme>_proxy;
    this seems to be the standard convention.  If you need a
    different way, you can pass a proxies dictionary to the
    [Fancy]URLopener constructor.

    """
    ...

def proxy_bypass_environment(host): # -> Literal[1, 0]:
    """Test if proxies should not be used for a particular host.

    Checks the environment for a variable named no_proxy, which should
    be a list of DNS suffixes separated by commas, or '*' for all hosts.
    """
    ...

if sys.platform == 'darwin':
    ...
else:
    def getproxies_registry(): # -> dict[Any, Any]:
        """Return a dictionary of scheme -> proxy server URL mappings.

        Win32 uses the registry to store proxies.

        """
        ...
    
    def getproxies(): # -> dict[Any, Any]:
        """Return a dictionary of scheme -> proxy server URL mappings.

        Returns settings gathered from the environment, if specified,
        or the registry.

        """
        ...
    
    def proxy_bypass_registry(host): # -> Literal[0, 1]:
        ...
    
    def proxy_bypass(host): # -> Literal[1, 0]:
        """Return a dictionary of scheme -> proxy server URL mappings.

        Returns settings gathered from the environment, if specified,
        or the registry.

        """
        ...
    
