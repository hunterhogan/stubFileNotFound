"""
This type stub file was generated by pyright.
"""

import collections

"""
Ported using Python-Future from the Python 3.3 standard library.

Parse (absolute and relative) URLs.

urlparse module is based upon the following RFC specifications.

RFC 3986 (STD66): "Uniform Resource Identifiers" by T. Berners-Lee, R. Fielding
and L.  Masinter, January 2005.

RFC 2732 : "Format for Literal IPv6 Addresses in URL's by R.Hinden, B.Carpenter
and L.Masinter, December 1999.

RFC 2396:  "Uniform Resource Identifiers (URI)": Generic Syntax by T.
Berners-Lee, R. Fielding, and L. Masinter, August 1998.

RFC 2368: "The mailto URL scheme", by P.Hoffman , L Masinter, J. Zawinski, July 1998.

RFC 1808: "Relative Uniform Resource Locators", by R. Fielding, UC Irvine, June
1995.

RFC 1738: "Uniform Resource Locators (URL)" by T. Berners-Lee, L. Masinter, M.
McCahill, December 1994

RFC 3986 is considered the current standard and any future changes to
urlparse module should conform with it.  The urlparse module is
currently not entirely compliant with this RFC due to defacto
scenarios for parsing, and for backward compatibility purposes, some
parsing quirks from older RFCs are retained. The testcases in
test_urlparse.py provides a good indicator of parsing behavior.
"""
__all__ = ["urlparse", "urlunparse", "urljoin", "urldefrag", "urlsplit", "urlunsplit", "urlencode", "parse_qs", "parse_qsl", "quote", "quote_plus", "quote_from_bytes", "unquote", "unquote_plus", "unquote_to_bytes"]
uses_relative = ...
uses_netloc = ...
uses_params = ...
non_hierarchical = ...
uses_query = ...
uses_fragment = ...
scheme_chars = ...
MAX_CACHE_SIZE = ...
_parse_cache = ...
def clear_cache(): # -> None:
    """Clear the parse cache and the quoters cache."""
    ...

_implicit_encoding = ...
_implicit_errors = ...
class _ResultMixinStr:
    """Standard approach to encoding parsed results from str to bytes"""
    __slots__ = ...
    def encode(self, encoding=..., errors=...):
        ...
    


class _ResultMixinBytes:
    """Standard approach to decoding parsed results from bytes to str"""
    __slots__ = ...
    def decode(self, encoding=..., errors=...):
        ...
    


class _NetlocResultMixinBase:
    """Shared methods for the parsed result objects containing a netloc element"""
    __slots__ = ...
    @property
    def username(self):
        ...
    
    @property
    def password(self):
        ...
    
    @property
    def hostname(self): # -> None:
        ...
    
    @property
    def port(self): # -> newint | None:
        ...
    


class _NetlocResultMixinStr(_NetlocResultMixinBase, _ResultMixinStr):
    __slots__ = ...


class _NetlocResultMixinBytes(_NetlocResultMixinBase, _ResultMixinBytes):
    __slots__ = ...


_DefragResultBase = ...
_SplitResultBase = ...
_ParseResultBase = ...
ResultBase = _NetlocResultMixinStr
class DefragResult(_DefragResultBase, _ResultMixinStr):
    __slots__ = ...
    def geturl(self):
        ...
    


class SplitResult(_SplitResultBase, _NetlocResultMixinStr):
    __slots__ = ...
    def geturl(self): # -> bytes | str:
        ...
    


class ParseResult(_ParseResultBase, _NetlocResultMixinStr):
    __slots__ = ...
    def geturl(self): # -> bytes | str:
        ...
    


class DefragResultBytes(_DefragResultBase, _ResultMixinBytes):
    __slots__ = ...
    def geturl(self):
        ...
    


class SplitResultBytes(_SplitResultBase, _NetlocResultMixinBytes):
    __slots__ = ...
    def geturl(self): # -> bytes | str:
        ...
    


class ParseResultBytes(_ParseResultBase, _NetlocResultMixinBytes):
    __slots__ = ...
    def geturl(self): # -> bytes | str:
        ...
    


def urlparse(url, scheme=..., allow_fragments=...): # -> ParseResult:
    """Parse a URL into 6 components:
    <scheme>://<netloc>/<path>;<params>?<query>#<fragment>
    Return a 6-tuple: (scheme, netloc, path, params, query, fragment).
    Note that we don't break the components up in smaller bits
    (e.g. netloc is a single string) and we don't expand % escapes."""
    ...

def urlsplit(url, scheme=..., allow_fragments=...): # -> SplitResult:
    """Parse a URL into 5 components:
    <scheme>://<netloc>/<path>?<query>#<fragment>
    Return a 5-tuple: (scheme, netloc, path, query, fragment).
    Note that we don't break the components up in smaller bits
    (e.g. netloc is a single string) and we don't expand % escapes."""
    ...

def urlunparse(components): # -> bytes | str:
    """Put a parsed URL back together again.  This may result in a
    slightly different, but equivalent URL, if the URL that was parsed
    originally had redundant delimiters, e.g. a ? with an empty query
    (the draft states that these are equivalent)."""
    ...

def urlunsplit(components): # -> bytes | str:
    """Combine the elements of a tuple as returned by urlsplit() into a
    complete URL as a string. The data argument can be any five-item iterable.
    This may result in a slightly different, but equivalent URL, if the URL that
    was parsed originally had unnecessary delimiters (for example, a ? with an
    empty query; the RFC states that these are equivalent)."""
    ...

def urljoin(base, url, allow_fragments=...): # -> bytes | str:
    """Join a base URL and a possibly relative URL to form an absolute
    interpretation of the latter."""
    ...

def urldefrag(url): # -> DefragResult:
    """Removes any existing fragment from URL.

    Returns a tuple of the defragmented URL and the fragment.  If
    the URL contained no fragments, the second element is the
    empty string.
    """
    ...

_hexdig = ...
_hextobyte = ...
def unquote_to_bytes(string): # -> newbytes:
    """unquote_to_bytes('abc%20def') -> b'abc def'."""
    ...

_asciire = ...
def unquote(string, encoding=..., errors=...): # -> str:
    """Replace %xx escapes by their single-character equivalent. The optional
    encoding and errors parameters specify how to decode percent-encoded
    sequences into Unicode characters, as accepted by the bytes.decode()
    method.
    By default, percent-encoded sequences are decoded with UTF-8, and invalid
    sequences are replaced by a placeholder character.

    unquote('abc%20def') -> 'abc def'.
    """
    ...

def parse_qs(qs, keep_blank_values=..., strict_parsing=..., encoding=..., errors=...): # -> dict[Any, Any]:
    """Parse a query given as a string argument.

        Arguments:

        qs: percent-encoded query string to be parsed

        keep_blank_values: flag indicating whether blank values in
            percent-encoded queries should be treated as blank strings.
            A true value indicates that blanks should be retained as
            blank strings.  The default false value indicates that
            blank values are to be ignored and treated as if they were
            not included.

        strict_parsing: flag indicating what to do with parsing errors.
            If false (the default), errors are silently ignored.
            If true, errors raise a ValueError exception.

        encoding and errors: specify how to decode percent-encoded sequences
            into Unicode characters, as accepted by the bytes.decode() method.
    """
    ...

def parse_qsl(qs, keep_blank_values=..., strict_parsing=..., encoding=..., errors=...): # -> list[Any]:
    """Parse a query given as a string argument.

    Arguments:

    qs: percent-encoded query string to be parsed

    keep_blank_values: flag indicating whether blank values in
        percent-encoded queries should be treated as blank strings.  A
        true value indicates that blanks should be retained as blank
        strings.  The default false value indicates that blank values
        are to be ignored and treated as if they were  not included.

    strict_parsing: flag indicating what to do with parsing errors. If
        false (the default), errors are silently ignored. If true,
        errors raise a ValueError exception.

    encoding and errors: specify how to decode percent-encoded sequences
        into Unicode characters, as accepted by the bytes.decode() method.

    Returns a list, as G-d intended.
    """
    ...

def unquote_plus(string, encoding=..., errors=...): # -> str:
    """Like unquote(), but also replace plus signs by spaces, as required for
    unquoting HTML form values.

    unquote_plus('%7e/abc+def') -> '~/abc def'
    """
    ...

_ALWAYS_SAFE = ...
_ALWAYS_SAFE_BYTES = ...
_safe_quoters = ...
class Quoter(collections.defaultdict):
    """A mapping from bytes (in range(0,256)) to strings.

    String values are percent-encoded byte values, unless the key < 128, and
    in the "safe" set (either the specified safe set, or default set).
    """
    def __init__(self, safe) -> None:
        """safe: bytes object."""
        ...
    
    def __repr__(self): # -> LiteralString:
        ...
    
    def __missing__(self, b): # -> str:
        ...
    


def quote(string, safe=..., encoding=..., errors=...): # -> newstr:
    """quote('abc def') -> 'abc%20def'

    Each part of a URL, e.g. the path info, the query, etc., has a
    different set of reserved characters that must be quoted.

    RFC 2396 Uniform Resource Identifiers (URI): Generic Syntax lists
    the following reserved characters.

    reserved    = ";" | "/" | "?" | ":" | "@" | "&" | "=" | "+" |
                  "$" | ","

    Each of these characters is reserved in some component of a URL,
    but not necessarily in all of them.

    By default, the quote function is intended for quoting the path
    section of a URL.  Thus, it will not encode '/'.  This character
    is reserved, but in typical usage the quote function is being
    called on a path where the existing slash characters are used as
    reserved characters.

    string and safe may be either str or bytes objects. encoding must
    not be specified if string is a str.

    The optional encoding and errors parameters specify how to deal with
    non-ASCII characters, as accepted by the str.encode method.
    By default, encoding='utf-8' (characters are encoded with UTF-8), and
    errors='strict' (unsupported characters raise a UnicodeEncodeError).
    """
    ...

def quote_plus(string, safe=..., encoding=..., errors=...): # -> newstr | newbytes:
    """Like quote(), but also replace ' ' with '+', as required for quoting
    HTML form values. Plus signs in the original string are escaped unless
    they are included in safe. It also does not have safe default to '/'.
    """
    ...

def quote_from_bytes(bs, safe=...): # -> newstr:
    """Like quote(), but accepts a bytes object rather than a str, and does
    not perform string-to-bytes encoding.  It always returns an ASCII string.
    quote_from_bytes(b'abc def\x3f') -> 'abc%20def%3f'
    """
    ...

def urlencode(query, doseq=..., safe=..., encoding=..., errors=...): # -> newstr:
    """Encode a sequence of two-element tuples or dictionary into a URL query string.

    If any values in the query arg are sequences and doseq is true, each
    sequence element is converted to a separate parameter.

    If the query arg is a sequence of two-element tuples, the order of the
    parameters in the output will match the order of parameters in the
    input.

    The query arg may be either a string or a bytes type. When query arg is a
    string, the safe, encoding and error parameters are sent the quote_plus for
    encoding.
    """
    ...

def to_bytes(url): # -> newstr:
    """to_bytes(u"URL") --> 'URL'."""
    ...

def unwrap(url):
    """unwrap('<URL:type://host/path>') --> 'type://host/path'."""
    ...

_typeprog = ...
def splittype(url): # -> tuple[str | Any, Any] | tuple[None, Any]:
    """splittype('type:opaquestring') --> 'type', 'opaquestring'."""
    ...

_hostprog = ...
def splithost(url): # -> tuple[str | Any, str | Any] | tuple[None, Any]:
    """splithost('//host[:port]/path') --> 'host[:port]', '/path'."""
    ...

_userprog = ...
def splituser(host): # -> tuple[str | Any, ...] | tuple[None, Any]:
    """splituser('user[:passwd]@host[:port]') --> 'user[:passwd]', 'host[:port]'."""
    ...

_passwdprog = ...
def splitpasswd(user): # -> tuple[str | Any, ...] | tuple[Any, None]:
    """splitpasswd('user:passwd') -> 'user', 'passwd'."""
    ...

_portprog = ...
def splitport(host): # -> tuple[str | Any, ...] | tuple[Any, None]:
    """splitport('host:port') --> 'host', 'port'."""
    ...

_nportprog = ...
def splitnport(host, defport=...): # -> tuple[str | Any, newint | None] | tuple[Any, int]:
    """Split host and port, returning numeric port.
    Return given default port if no ':' found; defaults to -1.
    Return numerical port if a valid number are found after ':'.
    Return None if ':' but not a valid number."""
    ...

_queryprog = ...
def splitquery(url): # -> tuple[str | Any, ...] | tuple[Any, None]:
    """splitquery('/path?query') --> '/path', 'query'."""
    ...

_tagprog = ...
def splittag(url): # -> tuple[str | Any, ...] | tuple[Any, None]:
    """splittag('/path#tag') --> '/path', 'tag'."""
    ...

def splitattr(url): # -> tuple[Any, Any]:
    """splitattr('/path;attr1=value1;attr2=value2;...') ->
        '/path', ['attr1=value1', 'attr2=value2', ...]."""
    ...

_valueprog = ...
def splitvalue(attr): # -> tuple[str | Any, ...] | tuple[Any, None]:
    """splitvalue('attr=value') --> 'attr', 'value'."""
    ...

