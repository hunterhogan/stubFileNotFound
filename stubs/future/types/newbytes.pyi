"""
This type stub file was generated by pyright.
"""

from future.utils import PY2, PY3, with_metaclass
from future.types import no

"""
Pure-Python implementation of a Python 3-like bytes object for Python 2.

Why do this? Without it, the Python 2 bytes object is a very, very
different beast to the Python 3 bytes object.
"""
if PY2:
    ...
else:
    ...
_builtin_bytes = bytes
if PY3:
    unicode = str
class BaseNewBytes(type):
    def __instancecheck__(cls, instance): # -> bool:
        ...
    


class newbytes(with_metaclass(BaseNewBytes, _builtin_bytes)):
    """
    A backport of the Python 3 bytes object to Py2
    """
    def __new__(cls, *args, **kwargs): # -> newbytes:
        """
        From the Py3 bytes docstring:

        bytes(iterable_of_ints) -> bytes
        bytes(string, encoding[, errors]) -> bytes
        bytes(bytes_or_buffer) -> immutable copy of bytes_or_buffer
        bytes(int) -> bytes object of size given by the parameter initialized with null bytes
        bytes() -> empty bytes object

        Construct an immutable array of bytes from:
          - an iterable yielding integers in range(256)
          - a text string encoded using the specified encoding
          - any object implementing the buffer API.
          - an integer
        """
        ...
    
    def __repr__(self):
        ...
    
    def __str__(self) -> str:
        ...
    
    def __getitem__(self, y): # -> int | newbytes:
        ...
    
    def __getslice__(self, *args): # -> int | newbytes:
        ...
    
    def __contains__(self, key): # -> bool:
        ...
    
    @no(unicode)
    def __add__(self, other): # -> newbytes:
        ...
    
    @no(unicode)
    def __radd__(self, left): # -> newbytes:
        ...
    
    @no(unicode)
    def __mul__(self, other): # -> newbytes:
        ...
    
    @no(unicode)
    def __rmul__(self, other): # -> newbytes:
        ...
    
    def __mod__(self, vals): # -> bytes:
        ...
    
    def __imod__(self, other): # -> bytes:
        ...
    
    def join(self, iterable_of_bytes): # -> newbytes:
        ...
    
    @classmethod
    def fromhex(cls, string): # -> Self:
        ...
    
    @no(unicode)
    def find(self, sub, *args):
        ...
    
    @no(unicode)
    def rfind(self, sub, *args):
        ...
    
    @no(unicode, (1, 2))
    def replace(self, old, new, *args): # -> newbytes:
        ...
    
    def encode(self, *args):
        ...
    
    def decode(self, encoding=..., errors=...): # -> newstr:
        """
        Returns a newstr (i.e. unicode subclass)

        Decode B using the codec registered for encoding. Default encoding
        is 'utf-8'. errors may be given to set a different error
        handling scheme.  Default is 'strict' meaning that encoding errors raise
        a UnicodeDecodeError.  Other possible values are 'ignore' and 'replace'
        as well as any other name registered with codecs.register_error that is
        able to handle UnicodeDecodeErrors.
        """
        ...
    
    @no(unicode)
    def startswith(self, prefix, *args):
        ...
    
    @no(unicode)
    def endswith(self, prefix, *args):
        ...
    
    @no(unicode)
    def split(self, sep=..., maxsplit=...): # -> list[Any | newbytes]:
        ...
    
    def splitlines(self, keepends=...): # -> list[Any | newbytes]:
        """
        B.splitlines([keepends]) -> list of lines

        Return a list of the lines in B, breaking at line boundaries.
        Line breaks are not included in the resulting list unless keepends
        is given and true.
        """
        ...
    
    @no(unicode)
    def rsplit(self, sep=..., maxsplit=...): # -> list[Any | newbytes]:
        ...
    
    @no(unicode)
    def partition(self, sep): # -> tuple[Any | newbytes, ...]:
        ...
    
    @no(unicode)
    def rpartition(self, sep): # -> tuple[Any | newbytes, ...]:
        ...
    
    @no(unicode, (1, ))
    def rindex(self, sub, *args): # -> None:
        '''
        S.rindex(sub [,start [,end]]) -> int

        Like S.rfind() but raise ValueError when the substring is not found.
        '''
        ...
    
    @no(unicode)
    def index(self, sub, *args): # -> int:
        '''
        Returns index of sub in bytes.
        Raises ValueError if byte is not in bytes and TypeError if can't
        be converted bytes or its length is not 1.
        '''
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    
    unorderable_err = ...
    def __lt__(self, other) -> bool:
        ...
    
    def __le__(self, other) -> bool:
        ...
    
    def __gt__(self, other) -> bool:
        ...
    
    def __ge__(self, other) -> bool:
        ...
    
    def __native__(self):
        ...
    
    def __getattribute__(self, name):
        """
        A trick to cause the ``hasattr`` builtin-fn to return False for
        the 'encode' method on Py2.
        """
        ...
    
    @no(unicode)
    def rstrip(self, bytes_to_strip=...): # -> newbytes:
        """
        Strip trailing bytes contained in the argument.
        If the argument is omitted, strip trailing ASCII whitespace.
        """
        ...
    
    @no(unicode)
    def strip(self, bytes_to_strip=...): # -> newbytes:
        """
        Strip leading and trailing bytes contained in the argument.
        If the argument is omitted, strip trailing ASCII whitespace.
        """
        ...
    
    def lower(self): # -> newbytes:
        """
        b.lower() -> copy of b

        Return a copy of b with all ASCII characters converted to lowercase.
        """
        ...
    
    @no(unicode)
    def upper(self): # -> newbytes:
        """
        b.upper() -> copy of b

        Return a copy of b with all ASCII characters converted to uppercase.
        """
        ...
    
    @classmethod
    @no(unicode)
    def maketrans(cls, frm, to): # -> newbytes:
        """
        B.maketrans(frm, to) -> translation table

        Return a translation table (a bytes object of length 256) suitable
        for use in the bytes or bytearray translate method where each byte
        in frm is mapped to the byte at the same position in to.
        The bytes objects frm and to must be of the same length.
        """
        ...
    


__all__ = ['newbytes']
