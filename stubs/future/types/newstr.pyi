"""
This type stub file was generated by pyright.
"""

from future.utils import PY3, with_metaclass
from future.types import no

"""
This module redefines ``str`` on Python 2.x to be a subclass of the Py2
``unicode`` type that behaves like the Python 3.x ``str``.

The main differences between ``newstr`` and Python 2.x's ``unicode`` type are
the stricter type-checking and absence of a `u''` prefix in the representation.

It is designed to be used together with the ``unicode_literals`` import
as follows:

    >>> from __future__ import unicode_literals
    >>> from builtins import str, isinstance

On Python 3.x and normally on Python 2.x, these expressions hold

    >>> str('blah') is 'blah'
    True
    >>> isinstance('blah', str)
    True

However, on Python 2.x, with this import:

    >>> from __future__ import unicode_literals

the same expressions are False:

    >>> str('blah') is 'blah'
    False
    >>> isinstance('blah', str)
    False

This module is designed to be imported together with ``unicode_literals`` on
Python 2 to bring the meaning of ``str`` back into alignment with unprefixed
string literals (i.e. ``unicode`` subclasses).

Note that ``str()`` (and ``print()``) would then normally call the
``__unicode__`` method on objects in Python 2. To define string
representations of your objects portably across Py3 and Py2, use the
:func:`python_2_unicode_compatible` decorator in  :mod:`future.utils`.

"""
if PY3:
    unicode = str
else:
    ...
class BaseNewStr(type):
    def __instancecheck__(cls, instance): # -> bool:
        ...
    


class newstr(with_metaclass(BaseNewStr, unicode)):
    """
    A backport of the Python 3 str object to Py2
    """
    no_convert_msg = ...
    def __new__(cls, *args, **kwargs): # -> newstr:
        """
        From the Py3 str docstring:

          str(object='') -> str
          str(bytes_or_buffer[, encoding[, errors]]) -> str

          Create a new string object from the given object. If encoding or
          errors is specified, then the object must expose a data buffer
          that will be decoded using the given encoding and error handler.
          Otherwise, returns the result of object.__str__() (if defined)
          or repr(object).
          encoding defaults to sys.getdefaultencoding().
          errors defaults to 'strict'.

        """
        ...
    
    def __repr__(self):
        """
        Without the u prefix
        """
        ...
    
    def __getitem__(self, y): # -> newstr:
        """
        Warning: Python <= 2.7.6 has a bug that causes this method never to be called
        when y is a slice object. Therefore the type of newstr()[:2] is wrong
        (unicode instead of newstr).
        """
        ...
    
    def __contains__(self, key): # -> bool:
        ...
    
    @no('newbytes')
    def __add__(self, other): # -> newstr:
        ...
    
    @no('newbytes')
    def __radd__(self, left): # -> newstr | NotImplementedType:
        " left + self "
        ...
    
    def __mul__(self, other): # -> newstr:
        ...
    
    def __rmul__(self, other): # -> newstr:
        ...
    
    def join(self, iterable): # -> newstr:
        ...
    
    @no('newbytes')
    def find(self, sub, *args):
        ...
    
    @no('newbytes')
    def rfind(self, sub, *args):
        ...
    
    @no('newbytes', (1, 2))
    def replace(self, old, new, *args): # -> newstr:
        ...
    
    def decode(self, *args):
        ...
    
    def encode(self, encoding=..., errors=...): # -> newbytes:
        """
        Returns bytes

        Encode S using the codec registered for encoding. Default encoding
        is 'utf-8'. errors may be given to set a different error
        handling scheme. Default is 'strict' meaning that encoding errors raise
        a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and
        'xmlcharrefreplace' as well as any other name registered with
        codecs.register_error that can handle UnicodeEncodeErrors.
        """
        ...
    
    @no('newbytes', 1)
    def startswith(self, prefix, *args):
        ...
    
    @no('newbytes', 1)
    def endswith(self, prefix, *args):
        ...
    
    @no('newbytes', 1)
    def split(self, sep=..., maxsplit=...): # -> list[Any | newstr]:
        ...
    
    @no('newbytes', 1)
    def rsplit(self, sep=..., maxsplit=...): # -> list[Any | newstr]:
        ...
    
    @no('newbytes', 1)
    def partition(self, sep): # -> tuple[Any | newstr, ...]:
        ...
    
    @no('newbytes', 1)
    def rpartition(self, sep): # -> tuple[Any | newstr, ...]:
        ...
    
    @no('newbytes', 1)
    def index(self, sub, *args):
        """
        Like newstr.find() but raise ValueError when the substring is not
        found.
        """
        ...
    
    def splitlines(self, keepends=...): # -> list[Any | newstr]:
        """
        S.splitlines(keepends=False) -> list of strings

        Return a list of the lines in S, breaking at line boundaries.
        Line breaks are not included in the resulting list unless keepends
        is given and true.
        """
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    
    unorderable_err = ...
    def __lt__(self, other) -> bool:
        ...
    
    def __le__(self, other) -> bool:
        ...
    
    def __gt__(self, other) -> bool:
        ...
    
    def __ge__(self, other) -> bool:
        ...
    
    def __getattribute__(self, name):
        """
        A trick to cause the ``hasattr`` builtin-fn to return False for
        the 'decode' method on Py2.
        """
        ...
    
    def __native__(self): # -> str:
        """
        A hook for the future.utils.native() function.
        """
        ...
    
    @staticmethod
    def maketrans(x, y=..., z=...): # -> dict[Any, Any]:
        """
        Return a translation table usable for str.translate().

        If there is only one argument, it must be a dictionary mapping Unicode
        ordinals (integers) or characters to Unicode ordinals, strings or None.
        Character keys will be then converted to ordinals.
        If there are two arguments, they must be strings of equal length, and
        in the resulting dictionary, each character in x will be mapped to the
        character at the same position in y. If there is a third argument, it
        must be a string, whose characters will be mapped to None in the result.
        """
        ...
    
    def translate(self, table): # -> LiteralString:
        """
        S.translate(table) -> str

        Return a copy of the string S, where all characters have been mapped
        through the given translation table, which must be a mapping of
        Unicode ordinals to Unicode ordinals, strings, or None.
        Unmapped characters are left untouched. Characters mapped to None
        are deleted.
        """
        ...
    
    def isprintable(self):
        ...
    
    def isidentifier(self):
        ...
    
    def format_map(self):
        ...
    


__all__ = ['newstr']
