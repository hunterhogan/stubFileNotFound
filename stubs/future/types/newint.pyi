"""
This type stub file was generated by pyright.
"""

from future.utils import PY3, with_metaclass

"""
Backport of Python 3's int, based on Py2's long.

They are very similar. The most notable difference is:

- representation: trailing L in Python 2 removed in Python 3
"""
if PY3:
    long = int
else:
    ...
class BaseNewInt(type):
    def __instancecheck__(cls, instance): # -> bool:
        ...
    


class newint(with_metaclass(BaseNewInt, long)):
    """
    A backport of the Python 3 int object to Py2
    """
    def __new__(cls, x=..., base=...):
        """
        From the Py3 int docstring:

        |  int(x=0) -> integer
        |  int(x, base=10) -> integer
        |
        |  Convert a number or string to an integer, or return 0 if no
        |  arguments are given.  If x is a number, return x.__int__().  For
        |  floating point numbers, this truncates towards zero.
        |
        |  If x is not a number or if base is given, then x must be a string,
        |  bytes, or bytearray instance representing an integer literal in the
        |  given base.  The literal can be preceded by '+' or '-' and be
        |  surrounded by whitespace.  The base defaults to 10.  Valid bases are
        |  0 and 2-36. Base 0 means to interpret the base from the string as an
        |  integer literal.
        |  >>> int('0b100', base=0)
        |  4

        """
        ...
    
    def __repr__(self):
        """
        Without the L suffix
        """
        ...
    
    def __add__(self, other): # -> newint:
        ...
    
    def __radd__(self, other): # -> newint:
        ...
    
    def __sub__(self, other): # -> newint:
        ...
    
    def __rsub__(self, other): # -> newint:
        ...
    
    def __mul__(self, other): # -> newint:
        ...
    
    def __rmul__(self, other): # -> newint:
        ...
    
    def __div__(self, other): # -> newint:
        ...
    
    def __rdiv__(self, other): # -> newint:
        ...
    
    def __idiv__(self, other): # -> newint:
        ...
    
    def __truediv__(self, other):
        ...
    
    def __rtruediv__(self, other):
        ...
    
    def __itruediv__(self, other):
        ...
    
    def __floordiv__(self, other): # -> newint:
        ...
    
    def __rfloordiv__(self, other): # -> newint:
        ...
    
    def __ifloordiv__(self, other): # -> newint:
        ...
    
    def __mod__(self, other): # -> newint:
        ...
    
    def __rmod__(self, other): # -> newint:
        ...
    
    def __divmod__(self, other): # -> tuple[Any, Any] | tuple[newint, newint]:
        ...
    
    def __rdivmod__(self, other): # -> tuple[Any, Any] | tuple[newint, newint]:
        ...
    
    def __pow__(self, other): # -> newint:
        ...
    
    def __rpow__(self, other): # -> newint:
        ...
    
    def __lshift__(self, other): # -> newint:
        ...
    
    def __rshift__(self, other): # -> newint:
        ...
    
    def __and__(self, other): # -> newint:
        ...
    
    def __or__(self, other): # -> newint:
        ...
    
    def __xor__(self, other): # -> newint:
        ...
    
    def __neg__(self): # -> newint:
        ...
    
    def __pos__(self): # -> newint:
        ...
    
    def __abs__(self): # -> newint:
        ...
    
    def __invert__(self): # -> newint:
        ...
    
    def __int__(self) -> int:
        ...
    
    def __nonzero__(self):
        ...
    
    def __bool__(self):
        """
        So subclasses can override this, Py3-style
        """
        ...
    
    def __native__(self): # -> int:
        ...
    
    def to_bytes(self, length, byteorder=..., signed=...): # -> newbytes | int:
        """
        Return an array of bytes representing an integer.

        The integer is represented using length bytes.  An OverflowError is
        raised if the integer is not representable with the given number of
        bytes.

        The byteorder argument determines the byte order used to represent the
        integer.  If byteorder is 'big', the most significant byte is at the
        beginning of the byte array.  If byteorder is 'little', the most
        significant byte is at the end of the byte array.  To request the native
        byte order of the host system, use `sys.byteorder' as the byte order value.

        The signed keyword-only argument determines whether two's complement is
        used to represent the integer.  If signed is False and a negative integer
        is given, an OverflowError is raised.
        """
        ...
    
    @classmethod
    def from_bytes(cls, mybytes, byteorder=..., signed=...): # -> Self:
        """
        Return the integer represented by the given array of bytes.

        The mybytes argument must either support the buffer protocol or be an
        iterable object producing bytes.  Bytes and bytearray are examples of
        built-in objects that support the buffer protocol.

        The byteorder argument determines the byte order used to represent the
        integer.  If byteorder is 'big', the most significant byte is at the
        beginning of the byte array.  If byteorder is 'little', the most
        significant byte is at the end of the byte array.  To request the native
        byte order of the host system, use `sys.byteorder' as the byte order value.

        The signed keyword-only argument indicates whether two's complement is
        used to represent the integer.
        """
        ...
    


__all__ = ['newint']
