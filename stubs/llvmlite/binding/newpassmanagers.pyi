from _typeshed import Incomplete
from enum import IntFlag
from llvmlite.binding import ffi as ffi

def create_new_module_pass_manager(): ...
def create_new_function_pass_manager(): ...
def create_pass_builder(tm, pto): ...
def create_pipeline_tuning_options(speed_level: int = 2, size_level: int = 0): ...

class RefPruneSubpasses(IntFlag):
    PER_BB = 1
    DIAMOND = 2
    FANOUT = 4
    FANOUT_RAISE = 8
    ALL = PER_BB | DIAMOND | FANOUT | FANOUT_RAISE

class ModulePassManager(ffi.ObjectRef):
    def __init__(self, ptr: Incomplete | None = None) -> None: ...
    def run(self, module, pb) -> None: ...
    def add_verifier(self) -> None: ...
    def add_aa_eval_pass(self) -> None: ...
    def add_simplify_cfg_pass(self) -> None: ...
    def add_loop_unroll_pass(self) -> None: ...
    def add_loop_rotate_pass(self) -> None: ...
    def add_instruction_combine_pass(self) -> None: ...
    def add_jump_threading_pass(self, threshold: int = -1) -> None: ...
    def _dispose(self) -> None: ...
    def add_refprune_pass(self, subpasses_flags=..., subgraph_limit: int = 1000) -> None:
        """Add Numba specific Reference count pruning pass.

        Parameters
        ----------
        subpasses_flags : RefPruneSubpasses
            A bitmask to control the subpasses to be enabled.
        subgraph_limit : int
            Limit the fanout pruners to working on a subgraph no bigger than
            this number of basic-blocks to avoid spending too much time in very
            large graphs. Default is 1000. Subject to change in future
            versions.
        """

class FunctionPassManager(ffi.ObjectRef):
    def __init__(self, ptr: Incomplete | None = None) -> None: ...
    def run(self, fun, pb) -> None: ...
    def add_aa_eval_pass(self) -> None: ...
    def add_simplify_cfg_pass(self) -> None: ...
    def add_loop_unroll_pass(self) -> None: ...
    def add_loop_rotate_pass(self) -> None: ...
    def add_instruction_combine_pass(self) -> None: ...
    def add_jump_threading_pass(self, threshold: int = -1) -> None: ...
    def _dispose(self) -> None: ...
    def add_refprune_pass(self, subpasses_flags=..., subgraph_limit: int = 1000) -> None:
        """Add Numba specific Reference count pruning pass.

        Parameters
        ----------
        subpasses_flags : RefPruneSubpasses
            A bitmask to control the subpasses to be enabled.
        subgraph_limit : int
            Limit the fanout pruners to working on a subgraph no bigger than
            this number of basic-blocks to avoid spending too much time in very
            large graphs. Default is 1000. Subject to change in future
            versions.
        """

class PipelineTuningOptions(ffi.ObjectRef):
    _speed_level: Incomplete
    _size_level: Incomplete
    def __init__(self, speed_level: int = 2, size_level: int = 0) -> None: ...
    @property
    def speed_level(self): ...
    @speed_level.setter
    def speed_level(self, value) -> None: ...
    @property
    def size_level(self): ...
    @size_level.setter
    def size_level(self, value) -> None: ...
    @property
    def loop_interleaving(self): ...
    @loop_interleaving.setter
    def loop_interleaving(self, value) -> None: ...
    @property
    def loop_vectorization(self): ...
    @loop_vectorization.setter
    def loop_vectorization(self, value) -> None: ...
    @property
    def slp_vectorization(self): ...
    @slp_vectorization.setter
    def slp_vectorization(self, value) -> None: ...
    @property
    def loop_unrolling(self): ...
    @loop_unrolling.setter
    def loop_unrolling(self, value) -> None: ...
    def _dispose(self) -> None: ...

class PassBuilder(ffi.ObjectRef):
    _pto: Incomplete
    _tm: Incomplete
    def __init__(self, tm, pto) -> None: ...
    def getModulePassManager(self): ...
    def getFunctionPassManager(self): ...
    def _dispose(self) -> None: ...
