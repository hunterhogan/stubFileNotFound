"""
This type stub file was generated by pyright.
"""

import struct
import logging
import re
from fontTools.misc import psCharStrings, sstruct
from fontTools.misc.arrayTools import intRect, unionRect
from fontTools.misc.textTools import bytechr, byteord, bytesjoin, safeEval, tobytes, tostr
from fontTools.ttLib import TTFont
from fontTools.ttLib.tables.otBase import OTTableReader, OTTableWriter
from fontTools.ttLib.tables import otTables as ot
from io import BytesIO

"""cffLib: read/write Adobe CFF fonts

OpenType fonts with PostScript outlines embed a completely independent
font file in Adobe's *Compact Font Format*. So dealing with OpenType fonts
requires also dealing with CFF. This module allows you to read and write
fonts written in the CFF format.

In 2016, OpenType 1.8 introduced the `CFF2 <https://docs.microsoft.com/en-us/typography/opentype/spec/cff2>`_
format which, along with other changes, extended the CFF format to deal with
the demands of variable fonts. This module parses both original CFF and CFF2.

"""
DEBUG = ...
log = ...
cffHeaderFormat = ...
maxStackLimit = ...
class CFFFontSet:
    """A CFF font "file" can contain more than one font, although this is
    extremely rare (and not allowed within OpenType fonts).

    This class is the entry point for parsing a CFF table. To actually
    manipulate the data inside the CFF font, you will want to access the
    ``CFFFontSet``'s :class:`TopDict` object. To do this, a ``CFFFontSet``
    object can either be treated as a dictionary (with appropriate
    ``keys()`` and ``values()`` methods) mapping font names to :class:`TopDict`
    objects, or as a list.

    .. code:: python

            from fontTools import ttLib
            tt = ttLib.TTFont("Tests/cffLib/data/LinLibertine_RBI.otf")
            tt["CFF "].cff
            # <fontTools.cffLib.CFFFontSet object at 0x101e24c90>
            tt["CFF "].cff[0] # Here's your actual font data
            # <fontTools.cffLib.TopDict object at 0x1020f1fd0>

    """
    def decompile(self, file, otFont, isCFF2=...): # -> None:
        """Parse a binary CFF file into an internal representation. ``file``
        should be a file handle object. ``otFont`` is the top-level
        :py:class:`fontTools.ttLib.ttFont.TTFont` object containing this CFF file.

        If ``isCFF2`` is passed and set to ``True`` or ``False``, then the
        library makes an assertion that the CFF header is of the appropriate
        version.
        """
        ...
    
    def __len__(self): # -> int:
        ...
    
    def keys(self): # -> list[str]:
        ...
    
    def values(self): # -> TopDictIndex:
        ...
    
    def __getitem__(self, nameOrIndex): # -> Any:
        """Return TopDict instance identified by name (str) or index (int
        or any object that implements `__index__`).
        """
        ...
    
    def compile(self, file, otFont, isCFF2=...): # -> None:
        """Write the object back into binary representation onto the given file.
        ``file`` should be a file handle object. ``otFont`` is the top-level
        :py:class:`fontTools.ttLib.ttFont.TTFont` object containing this CFF file.

        If ``isCFF2`` is passed and set to ``True`` or ``False``, then the
        library makes an assertion that the CFF header is of the appropriate
        version.
        """
        ...
    
    def toXML(self, xmlWriter): # -> None:
        """Write the object into XML representation onto the given
        :class:`fontTools.misc.xmlWriter.XMLWriter`.

        .. code:: python

                writer = xmlWriter.XMLWriter(sys.stdout)
                tt["CFF "].cff.toXML(writer)

        """
        ...
    
    def fromXML(self, name, attrs, content, otFont=...): # -> None:
        """Reads data from the XML element into the ``CFFFontSet`` object."""
        ...
    
    def convertCFFToCFF2(self, otFont): # -> None:
        ...
    
    def convertCFF2ToCFF(self, otFont): # -> None:
        ...
    
    def desubroutinize(self): # -> None:
        ...
    
    def remove_hints(self): # -> None:
        ...
    
    def remove_unused_subroutines(self): # -> None:
        ...
    


class CFFWriter:
    """Helper class for serializing CFF data to binary. Used by
    :meth:`CFFFontSet.compile`."""
    def __init__(self, isCFF2) -> None:
        ...
    
    def add(self, table): # -> None:
        ...
    
    def toFile(self, file): # -> None:
        ...
    


def calcOffSize(largestOffset): # -> Literal[1, 2, 3, 4]:
    ...

class IndexCompiler:
    """Base class for writing CFF `INDEX data <https://docs.microsoft.com/en-us/typography/opentype/spec/cff2#5-index-data>`_
    to binary."""
    def __init__(self, items, strings, parent, isCFF2=...) -> None:
        ...
    
    def getItems(self, items, strings):
        ...
    
    def getOffsets(self): # -> list[int]:
        ...
    
    def getDataLength(self): # -> int:
        ...
    
    def toFile(self, file): # -> None:
        ...
    


class IndexedStringsCompiler(IndexCompiler):
    def getItems(self, items, strings):
        ...
    


class TopDictIndexCompiler(IndexCompiler):
    """Helper class for writing the TopDict to binary."""
    def getItems(self, items, strings): # -> list[Any]:
        ...
    
    def getChildren(self, strings): # -> list[Any]:
        ...
    
    def getOffsets(self): # -> list[int | Any] | list[int]:
        ...
    
    def getDataLength(self): # -> int:
        ...
    
    def toFile(self, file): # -> None:
        ...
    


class FDArrayIndexCompiler(IndexCompiler):
    """Helper class for writing the
    `Font DICT INDEX <https://docs.microsoft.com/en-us/typography/opentype/spec/cff2#10-font-dict-index-font-dicts-and-fdselect>`_
    to binary."""
    def getItems(self, items, strings): # -> list[Any]:
        ...
    
    def getChildren(self, strings): # -> list[Any]:
        ...
    
    def toFile(self, file): # -> None:
        ...
    
    def setPos(self, pos, endPos): # -> None:
        ...
    


class GlobalSubrsCompiler(IndexCompiler):
    """Helper class for writing the `global subroutine INDEX <https://docs.microsoft.com/en-us/typography/opentype/spec/cff2#9-local-and-global-subr-indexes>`_
    to binary."""
    def getItems(self, items, strings): # -> list[Any]:
        ...
    


class SubrsCompiler(GlobalSubrsCompiler):
    """Helper class for writing the `local subroutine INDEX <https://docs.microsoft.com/en-us/typography/opentype/spec/cff2#9-local-and-global-subr-indexes>`_
    to binary."""
    def setPos(self, pos, endPos): # -> None:
        ...
    


class CharStringsCompiler(GlobalSubrsCompiler):
    """Helper class for writing the `CharStrings INDEX <https://docs.microsoft.com/en-us/typography/opentype/spec/cff2#9-local-and-global-subr-indexes>`_
    to binary."""
    def getItems(self, items, strings): # -> list[Any]:
        ...
    
    def setPos(self, pos, endPos): # -> None:
        ...
    


class Index:
    """This class represents what the CFF spec calls an INDEX (an array of
    variable-sized objects). `Index` items can be addressed and set using
    Python list indexing."""
    compilerClass = IndexCompiler
    def __init__(self, file=..., isCFF2=...) -> None:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __getitem__(self, index): # -> Any:
        ...
    
    def __setitem__(self, index, item): # -> None:
        ...
    
    def produceItem(self, index, data, file, offset):
        ...
    
    def append(self, item): # -> None:
        """Add an item to an INDEX."""
        ...
    
    def getCompiler(self, strings, parent, isCFF2=...): # -> compilerClass:
        ...
    
    def clear(self): # -> None:
        """Empty the INDEX."""
        ...
    


class GlobalSubrsIndex(Index):
    """This index contains all the global subroutines in the font. A global
    subroutine is a set of ``CharString`` data which is accessible to any
    glyph in the font, and are used to store repeated instructions - for
    example, components may be encoded as global subroutines, but so could
    hinting instructions.

    Remember that when interpreting a ``callgsubr`` instruction (or indeed
    a ``callsubr`` instruction) that you will need to add the "subroutine
    number bias" to number given:

    .. code:: python

            tt = ttLib.TTFont("Almendra-Bold.otf")
            u = tt["CFF "].cff[0].CharStrings["udieresis"]
            u.decompile()

            u.toXML(XMLWriter(sys.stdout))
            # <some stuff>
            # -64 callgsubr <-- Subroutine which implements the dieresis mark
            # <other stuff>

            tt["CFF "].cff[0].GlobalSubrs[-64] # <-- WRONG
            # <T2CharString (bytecode) at 103451d10>

            tt["CFF "].cff[0].GlobalSubrs[-64 + 107] # <-- RIGHT
            # <T2CharString (source) at 103451390>

    ("The bias applied depends on the number of subrs (gsubrs). If the number of
    subrs (gsubrs) is less than 1240, the bias is 107. Otherwise if it is less
    than 33900, it is 1131; otherwise it is 32768.",
    `Subroutine Operators <https://docs.microsoft.com/en-us/typography/opentype/otspec180/cff2charstr#section4.4>`)
    """
    compilerClass = GlobalSubrsCompiler
    subrClass = psCharStrings.T2CharString
    charStringClass = psCharStrings.T2CharString
    def __init__(self, file=..., globalSubrs=..., private=..., fdSelect=..., fdArray=..., isCFF2=...) -> None:
        ...
    
    def produceItem(self, index, data, file, offset): # -> subrClass:
        ...
    
    def toXML(self, xmlWriter): # -> None:
        """Write the subroutines index into XML representation onto the given
        :class:`fontTools.misc.xmlWriter.XMLWriter`.

        .. code:: python

                writer = xmlWriter.XMLWriter(sys.stdout)
                tt["CFF "].cff[0].GlobalSubrs.toXML(writer)

        """
        ...
    
    def fromXML(self, name, attrs, content): # -> None:
        ...
    
    def getItemAndSelector(self, index): # -> tuple[Any, Any | None]:
        ...
    


class SubrsIndex(GlobalSubrsIndex):
    """This index contains a glyph's local subroutines. A local subroutine is a
    private set of ``CharString`` data which is accessible only to the glyph to
    which the index is attached."""
    compilerClass = SubrsCompiler


class TopDictIndex(Index):
    """This index represents the array of ``TopDict`` structures in the font
    (again, usually only one entry is present). Hence the following calls are
    equivalent:

    .. code:: python

            tt["CFF "].cff[0]
            # <fontTools.cffLib.TopDict object at 0x102ed6e50>
            tt["CFF "].cff.topDictIndex[0]
            # <fontTools.cffLib.TopDict object at 0x102ed6e50>

    """
    compilerClass = TopDictIndexCompiler
    def __init__(self, file=..., cff2GetGlyphOrder=..., topSize=..., isCFF2=...) -> None:
        ...
    
    def produceItem(self, index, data, file, offset): # -> TopDict:
        ...
    
    def toXML(self, xmlWriter): # -> None:
        ...
    


class FDArrayIndex(Index):
    compilerClass = FDArrayIndexCompiler
    def toXML(self, xmlWriter): # -> None:
        ...
    
    def produceItem(self, index, data, file, offset): # -> FontDict:
        ...
    
    def fromXML(self, name, attrs, content): # -> None:
        ...
    


class VarStoreData:
    def __init__(self, file=..., otVarStore=...) -> None:
        ...
    
    def decompile(self): # -> Self:
        ...
    
    def compile(self): # -> None:
        ...
    
    def writeXML(self, xmlWriter, name): # -> None:
        ...
    
    def xmlRead(self, name, attrs, content, parent): # -> None:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def getNumRegions(self, vsIndex):
        ...
    


class FDSelect:
    def __init__(self, file=..., numGlyphs=..., format=...) -> None:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __getitem__(self, index):
        ...
    
    def __setitem__(self, index, fdSelectValue): # -> None:
        ...
    
    def append(self, fdSelectValue): # -> None:
        ...
    


class CharStrings:
    """The ``CharStrings`` in the font represent the instructions for drawing
    each glyph. This object presents a dictionary interface to the font's
    CharStrings, indexed by glyph name:

    .. code:: python

            tt["CFF "].cff[0].CharStrings["a"]
            # <T2CharString (bytecode) at 103451e90>

    See :class:`fontTools.misc.psCharStrings.T1CharString` and
    :class:`fontTools.misc.psCharStrings.T2CharString` for how to decompile,
    compile and interpret the glyph drawing instructions in the returned objects.

    """
    def __init__(self, file, charset, globalSubrs, private, fdSelect, fdArray, isCFF2=..., varStore=...) -> None:
        ...
    
    def keys(self): # -> list[Any]:
        ...
    
    def values(self): # -> SubrsIndex | list[Any]:
        ...
    
    def has_key(self, name): # -> bool:
        ...
    
    __contains__ = ...
    def __len__(self): # -> int:
        ...
    
    def __getitem__(self, name): # -> Any:
        ...
    
    def __setitem__(self, name, charString): # -> None:
        ...
    
    def getItemAndSelector(self, name): # -> tuple[Any, Any | None] | tuple[Any, Any | Literal[0] | None]:
        ...
    
    def toXML(self, xmlWriter): # -> None:
        ...
    
    def fromXML(self, name, attrs, content): # -> None:
        ...
    


def readCard8(file): # -> int:
    ...

def readCard16(file): # -> Any:
    ...

def readCard32(file): # -> Any:
    ...

def writeCard8(file, value): # -> None:
    ...

def writeCard16(file, value): # -> None:
    ...

def writeCard32(file, value): # -> None:
    ...

def packCard8(value): # -> bytes:
    ...

def packCard16(value): # -> bytes:
    ...

def packCard32(value): # -> bytes:
    ...

def buildOperatorDict(table): # -> dict[Any, Any]:
    ...

def buildOpcodeDict(table): # -> dict[Any, Any]:
    ...

def buildOrder(table): # -> list[Any]:
    ...

def buildDefaults(table): # -> dict[Any, Any]:
    ...

def buildConverters(table): # -> dict[Any, Any]:
    ...

class SimpleConverter:
    def read(self, parent, value):
        ...
    
    def write(self, parent, value):
        ...
    
    def xmlWrite(self, xmlWriter, name, value): # -> None:
        ...
    
    def xmlRead(self, name, attrs, content, parent):
        ...
    


class ASCIIConverter(SimpleConverter):
    def write(self, parent, value): # -> bytes:
        ...
    
    def xmlWrite(self, xmlWriter, name, value): # -> None:
        ...
    
    def xmlRead(self, name, attrs, content, parent): # -> bytes:
        ...
    


class Latin1Converter(SimpleConverter):
    def write(self, parent, value): # -> bytes:
        ...
    
    def xmlWrite(self, xmlWriter, name, value): # -> None:
        ...
    
    def xmlRead(self, name, attrs, content, parent): # -> bytes:
        ...
    


def parseNum(s): # -> int | float:
    ...

def parseBlendList(s): # -> list[Any]:
    ...

class NumberConverter(SimpleConverter):
    def xmlWrite(self, xmlWriter, name, value): # -> None:
        ...
    
    def xmlRead(self, name, attrs, content, parent): # -> list[Any] | int | float:
        ...
    


class ArrayConverter(SimpleConverter):
    def xmlWrite(self, xmlWriter, name, value): # -> None:
        ...
    
    def xmlRead(self, name, attrs, content, parent): # -> list[Any] | list[int | float]:
        ...
    


class TableConverter(SimpleConverter):
    def xmlWrite(self, xmlWriter, name, value): # -> None:
        ...
    
    def xmlRead(self, name, attrs, content, parent):
        ...
    


class PrivateDictConverter(TableConverter):
    def getClass(self): # -> type[PrivateDict]:
        ...
    
    def write(self, parent, value): # -> tuple[Literal[0], Literal[0]]:
        ...
    


class SubrsConverter(TableConverter):
    def getClass(self): # -> type[SubrsIndex]:
        ...
    
    def write(self, parent, value): # -> Literal[0]:
        ...
    


class CharStringsConverter(TableConverter):
    def write(self, parent, value): # -> Literal[0]:
        ...
    
    def xmlRead(self, name, attrs, content, parent): # -> CharStrings:
        ...
    


class CharsetConverter(SimpleConverter):
    def write(self, parent, value): # -> Literal[0]:
        ...
    
    def xmlWrite(self, xmlWriter, name, value): # -> None:
        ...
    
    def xmlRead(self, name, attrs, content, parent): # -> None:
        ...
    


class CharsetCompiler:
    def __init__(self, strings, charset, parent) -> None:
        ...
    
    def setPos(self, pos, endPos): # -> None:
        ...
    
    def getDataLength(self): # -> int:
        ...
    
    def toFile(self, file): # -> None:
        ...
    


def getStdCharSet(charset): # -> int | None:
    ...

def getCIDfromName(name, strings): # -> int:
    ...

def getSIDfromName(name, strings):
    ...

def packCharset0(charset, isCID, strings): # -> bytes:
    ...

def packCharset(charset, isCID, strings): # -> bytes:
    ...

def parseCharset0(numGlyphs, file, strings, isCID): # -> list[str]:
    ...

def parseCharset(numGlyphs, file, strings, isCID, fmt): # -> list[str]:
    ...

class EncodingCompiler:
    def __init__(self, strings, encoding, parent) -> None:
        ...
    
    def setPos(self, pos, endPos): # -> None:
        ...
    
    def getDataLength(self): # -> int:
        ...
    
    def toFile(self, file): # -> None:
        ...
    


class EncodingConverter(SimpleConverter):
    def write(self, parent, value): # -> Literal[0, 1]:
        ...
    
    def xmlWrite(self, xmlWriter, name, value): # -> None:
        ...
    
    def xmlRead(self, name, attrs, content, parent): # -> list[str]:
        ...
    


def readSID(file): # -> Any:
    """Read a String ID (SID) — 2-byte unsigned integer."""
    ...

def parseEncodingSupplement(file, encoding, strings): # -> None:
    """
    Parse the CFF Encoding supplement data:
      - nSups: number of supplementary mappings
      - each mapping: (code, SID) pair
    and apply them to the `encoding` list in place.
    """
    ...

def parseEncoding0(charset, file): # -> list[str]:
    """
    Format 0: simple list of codes.
    After reading the base table, optionally parse the supplement.
    """
    ...

def parseEncoding1(charset, file): # -> list[str]:
    """
    Format 1: range-based encoding.
    After reading the base ranges, optionally parse the supplement.
    """
    ...

def packEncoding0(charset, encoding, strings): # -> bytes:
    ...

def packEncoding1(charset, encoding, strings): # -> bytes:
    ...

class FDArrayConverter(TableConverter):
    def write(self, parent, value): # -> Literal[0]:
        ...
    
    def xmlRead(self, name, attrs, content, parent): # -> FDArrayIndex:
        ...
    


class FDSelectConverter(SimpleConverter):
    def write(self, parent, value): # -> Literal[0]:
        ...
    
    def xmlWrite(self, xmlWriter, name, value): # -> None:
        ...
    
    def xmlRead(self, name, attrs, content, parent): # -> FDSelect:
        ...
    


class VarStoreConverter(SimpleConverter):
    def write(self, parent, value): # -> Literal[0]:
        ...
    
    def xmlWrite(self, xmlWriter, name, value): # -> None:
        ...
    
    def xmlRead(self, name, attrs, content, parent): # -> VarStoreData:
        ...
    


def packFDSelect0(fdSelectArray): # -> bytes:
    ...

def packFDSelect3(fdSelectArray): # -> bytes:
    ...

def packFDSelect4(fdSelectArray): # -> bytes:
    ...

class FDSelectCompiler:
    def __init__(self, fdSelect, parent) -> None:
        ...
    
    def setPos(self, pos, endPos): # -> None:
        ...
    
    def getDataLength(self): # -> int:
        ...
    
    def toFile(self, file): # -> None:
        ...
    


class VarStoreCompiler:
    def __init__(self, varStoreData, parent) -> None:
        ...
    
    def setPos(self, pos, endPos): # -> None:
        ...
    
    def getDataLength(self): # -> int:
        ...
    
    def toFile(self, file): # -> None:
        ...
    


class ROSConverter(SimpleConverter):
    def xmlWrite(self, xmlWriter, name, value): # -> None:
        ...
    
    def xmlRead(self, name, attrs, content, parent): # -> tuple[Any, Any, Any]:
        ...
    


topDictOperators = ...
topDictOperators2 = ...
kBlendDictOpName = ...
blendOp = ...
privateDictOperators = ...
privateDictOperators2 = ...
def addConverters(table): # -> None:
    ...

class TopDictDecompiler(psCharStrings.DictDecompiler):
    operators = ...


class PrivateDictDecompiler(psCharStrings.DictDecompiler):
    operators = ...


class DictCompiler:
    maxBlendStack = ...
    def __init__(self, dictObj, strings, parent, isCFF2=...) -> None:
        ...
    
    def setPos(self, pos, endPos): # -> None:
        ...
    
    def getDataLength(self): # -> int:
        ...
    
    def compile(self, reason): # -> bytes:
        ...
    
    def toFile(self, file): # -> None:
        ...
    
    def arg_number(self, num): # -> bytes:
        ...
    
    def arg_SID(self, s): # -> bytes:
        ...
    
    def arg_array(self, value): # -> bytes:
        ...
    
    def arg_delta(self, value): # -> bytes:
        ...
    
    def arg_delta_blend(self, value): # -> list[bytes]:
        """A delta list with blend lists has to be *all* blend lists.

        The value is a list is arranged as follows::

                [
                        [V0, d0..dn]
                        [V1, d0..dn]
                        ...
                        [Vm, d0..dn]
                ]

        ``V`` is the absolute coordinate value from the default font, and ``d0-dn``
        are the delta values from the *n* regions. Each ``V`` is an absolute
        coordinate from the default font.

        We want to return a list::

                [
                        [v0, v1..vm]
                        [d0..dn]
                        ...
                        [d0..dn]
                        numBlends
                        blendOp
                ]

        where each ``v`` is relative to the previous default font value.
        """
        ...
    


def encodeNumber(num): # -> bytes:
    ...

class TopDictCompiler(DictCompiler):
    opcodes = ...
    def getChildren(self, strings): # -> list[Any]:
        ...
    


class FontDictCompiler(DictCompiler):
    opcodes = ...
    def __init__(self, dictObj, strings, parent, isCFF2=...) -> None:
        ...
    
    def getChildren(self, strings): # -> list[Any]:
        ...
    


class PrivateDictCompiler(DictCompiler):
    maxBlendStack = ...
    opcodes = ...
    def setPos(self, pos, endPos): # -> None:
        ...
    
    def getChildren(self, strings): # -> list[Any]:
        ...
    


class BaseDict:
    def __init__(self, strings=..., file=..., offset=..., isCFF2=...) -> None:
        ...
    
    def decompile(self, data): # -> None:
        ...
    
    def postDecompile(self): # -> None:
        ...
    
    def getCompiler(self, strings, parent, isCFF2=...):
        ...
    
    def __getattr__(self, name):
        ...
    
    def toXML(self, xmlWriter): # -> None:
        ...
    
    def fromXML(self, name, attrs, content): # -> None:
        ...
    


class TopDict(BaseDict):
    """The ``TopDict`` represents the top-level dictionary holding font
    information. CFF2 tables contain a restricted set of top-level entries
    as described `here <https://docs.microsoft.com/en-us/typography/opentype/spec/cff2#7-top-dict-data>`_,
    but CFF tables may contain a wider range of information. This information
    can be accessed through attributes or through the dictionary returned
    through the ``rawDict`` property:

    .. code:: python

            font = tt["CFF "].cff[0]
            font.FamilyName
            # 'Linux Libertine O'
            font.rawDict["FamilyName"]
            # 'Linux Libertine O'

    More information is available in the CFF file's private dictionary, accessed
    via the ``Private`` property:

    .. code:: python

            tt["CFF "].cff[0].Private.BlueValues
            # [-15, 0, 515, 515, 666, 666]

    """
    defaults = ...
    converters = ...
    compilerClass = TopDictCompiler
    order = ...
    decompilerClass = TopDictDecompiler
    def __init__(self, strings=..., file=..., offset=..., GlobalSubrs=..., cff2GetGlyphOrder=..., isCFF2=...) -> None:
        ...
    
    def getGlyphOrder(self):
        """Returns a list of glyph names in the CFF font."""
        ...
    
    def postDecompile(self): # -> None:
        ...
    
    def toXML(self, xmlWriter): # -> None:
        ...
    
    def decompileAllCharStrings(self): # -> None:
        ...
    
    def recalcFontBBox(self): # -> None:
        ...
    


class FontDict(BaseDict):
    defaults = ...
    converters = ...
    compilerClass = FontDictCompiler
    orderCFF = ...
    orderCFF2 = ...
    decompilerClass = TopDictDecompiler
    def __init__(self, strings=..., file=..., offset=..., GlobalSubrs=..., isCFF2=..., vstore=...) -> None:
        ...
    
    def setCFF2(self, isCFF2): # -> None:
        ...
    


class PrivateDict(BaseDict):
    defaults = ...
    converters = ...
    order = ...
    decompilerClass = PrivateDictDecompiler
    compilerClass = PrivateDictCompiler
    def __init__(self, strings=..., file=..., offset=..., isCFF2=..., vstore=...) -> None:
        ...
    
    @property
    def in_cff2(self): # -> bool:
        ...
    
    def getNumRegions(self, vi=...):
        ...
    


class IndexedStrings:
    """SID -> string mapping."""
    def __init__(self, file=...) -> None:
        ...
    
    def getCompiler(self): # -> IndexedStringsCompiler:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __getitem__(self, SID):
        ...
    
    def getSID(self, s): # -> int:
        ...
    
    def getStrings(self): # -> list[str]:
        ...
    
    def buildStringMapping(self): # -> None:
        ...
    


cffStandardStrings = ...
cffStandardStringCount = ...
cffStandardStringMapping = ...
cffISOAdobeStrings = ...
cffISOAdobeStringCount = ...
cffIExpertStrings = ...
cffExpertStringCount = ...
cffExpertSubsetStrings = ...
cffExpertSubsetStringCount = ...
