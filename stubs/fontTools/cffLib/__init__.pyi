from _typeshed import Incomplete
from fontTools.misc import psCharStrings as psCharStrings, sstruct as sstruct
from fontTools.misc.arrayTools import intRect as intRect, unionRect as unionRect
from fontTools.misc.textTools import bytechr as bytechr, byteord as byteord, bytesjoin as bytesjoin, safeEval as safeEval, tobytes as tobytes, tostr as tostr
from fontTools.ttLib import TTFont as TTFont
from fontTools.ttLib.tables.otBase import OTTableReader as OTTableReader, OTTableWriter as OTTableWriter
from io import BytesIO as BytesIO

DEBUG: Incomplete
log: Incomplete
cffHeaderFormat: str
maxStackLimit: int

class CFFFontSet:
    '''A CFF font "file" can contain more than one font, although this is
    extremely rare (and not allowed within OpenType fonts).

    This class is the entry point for parsing a CFF table. To actually
    manipulate the data inside the CFF font, you will want to access the
    ``CFFFontSet``\'s :class:`TopDict` object. To do this, a ``CFFFontSet``
    object can either be treated as a dictionary (with appropriate
    ``keys()`` and ``values()`` methods) mapping font names to :class:`TopDict`
    objects, or as a list.

    .. code:: python

            from fontTools import ttLib
            tt = ttLib.TTFont("Tests/cffLib/data/LinLibertine_RBI.otf")
            tt["CFF "].cff
            # <fontTools.cffLib.CFFFontSet object at 0x101e24c90>
            tt["CFF "].cff[0] # Here\'s your actual font data
            # <fontTools.cffLib.TopDict object at 0x1020f1fd0>

    '''
    otFont: Incomplete
    offSize: Incomplete
    fontNames: Incomplete
    topDictIndex: Incomplete
    strings: Incomplete
    topDictSize: Incomplete
    GlobalSubrs: Incomplete
    def decompile(self, file, otFont, isCFF2=None) -> None:
        """Parse a binary CFF file into an internal representation. ``file``
        should be a file handle object. ``otFont`` is the top-level
        :py:class:`fontTools.ttLib.ttFont.TTFont` object containing this CFF file.

        If ``isCFF2`` is passed and set to ``True`` or ``False``, then the
        library makes an assertion that the CFF header is of the appropriate
        version.
        """
    def __len__(self) -> int: ...
    def keys(self): ...
    def values(self): ...
    def __getitem__(self, nameOrIndex):
        """Return TopDict instance identified by name (str) or index (int
        or any object that implements `__index__`).
        """
    hdrSize: int
    def compile(self, file, otFont, isCFF2=None) -> None:
        """Write the object back into binary representation onto the given file.
        ``file`` should be a file handle object. ``otFont`` is the top-level
        :py:class:`fontTools.ttLib.ttFont.TTFont` object containing this CFF file.

        If ``isCFF2`` is passed and set to ``True`` or ``False``, then the
        library makes an assertion that the CFF header is of the appropriate
        version.
        """
    def toXML(self, xmlWriter) -> None:
        '''Write the object into XML representation onto the given
        :class:`fontTools.misc.xmlWriter.XMLWriter`.

        .. code:: python

                writer = xmlWriter.XMLWriter(sys.stdout)
                tt["CFF "].cff.toXML(writer)

        '''
    major: int
    minor: int
    def fromXML(self, name, attrs, content, otFont=None) -> None:
        """Reads data from the XML element into the ``CFFFontSet`` object."""
    def convertCFFToCFF2(self, otFont) -> None: ...
    def convertCFF2ToCFF(self, otFont) -> None: ...
    def desubroutinize(self) -> None: ...
    def remove_hints(self) -> None: ...
    def remove_unused_subroutines(self) -> None: ...

class CFFWriter:
    """Helper class for serializing CFF data to binary. Used by
    :meth:`CFFFontSet.compile`."""
    data: Incomplete
    isCFF2: Incomplete
    def __init__(self, isCFF2) -> None: ...
    def add(self, table) -> None: ...
    topDictSize: Incomplete
    offSize: Incomplete
    def toFile(self, file) -> None: ...

def calcOffSize(largestOffset): ...

class IndexCompiler:
    """Base class for writing CFF `INDEX data <https://docs.microsoft.com/en-us/typography/opentype/spec/cff2#5-index-data>`_
    to binary."""
    isCFF2: Incomplete
    items: Incomplete
    parent: Incomplete
    def __init__(self, items, strings, parent, isCFF2=None) -> None: ...
    def getItems(self, items, strings): ...
    def getOffsets(self): ...
    def getDataLength(self): ...
    def toFile(self, file) -> None: ...

class IndexedStringsCompiler(IndexCompiler):
    def getItems(self, items, strings): ...

class TopDictIndexCompiler(IndexCompiler):
    """Helper class for writing the TopDict to binary."""
    def getItems(self, items, strings): ...
    def getChildren(self, strings): ...
    def getOffsets(self): ...
    def getDataLength(self): ...
    def toFile(self, file) -> None: ...

class FDArrayIndexCompiler(IndexCompiler):
    """Helper class for writing the
    `Font DICT INDEX <https://docs.microsoft.com/en-us/typography/opentype/spec/cff2#10-font-dict-index-font-dicts-and-fdselect>`_
    to binary."""
    def getItems(self, items, strings): ...
    def getChildren(self, strings): ...
    def toFile(self, file) -> None: ...
    def setPos(self, pos, endPos) -> None: ...

class GlobalSubrsCompiler(IndexCompiler):
    """Helper class for writing the `global subroutine INDEX <https://docs.microsoft.com/en-us/typography/opentype/spec/cff2#9-local-and-global-subr-indexes>`_
    to binary."""
    def getItems(self, items, strings): ...

class SubrsCompiler(GlobalSubrsCompiler):
    """Helper class for writing the `local subroutine INDEX <https://docs.microsoft.com/en-us/typography/opentype/spec/cff2#9-local-and-global-subr-indexes>`_
    to binary."""
    def setPos(self, pos, endPos) -> None: ...

class CharStringsCompiler(GlobalSubrsCompiler):
    """Helper class for writing the `CharStrings INDEX <https://docs.microsoft.com/en-us/typography/opentype/spec/cff2#9-local-and-global-subr-indexes>`_
    to binary."""
    def getItems(self, items, strings): ...
    def setPos(self, pos, endPos) -> None: ...

class Index:
    """This class represents what the CFF spec calls an INDEX (an array of
    variable-sized objects). `Index` items can be addressed and set using
    Python list indexing."""
    compilerClass = IndexCompiler
    items: Incomplete
    offsets: Incomplete
    _isCFF2: Incomplete
    file: Incomplete
    offsetBase: Incomplete
    def __init__(self, file=None, isCFF2=None) -> None: ...
    def __len__(self) -> int: ...
    def __getitem__(self, index): ...
    def __setitem__(self, index, item) -> None: ...
    def produceItem(self, index, data, file, offset): ...
    def append(self, item) -> None:
        """Add an item to an INDEX."""
    def getCompiler(self, strings, parent, isCFF2=None): ...
    def clear(self) -> None:
        """Empty the INDEX."""

class GlobalSubrsIndex(Index):
    '''This index contains all the global subroutines in the font. A global
    subroutine is a set of ``CharString`` data which is accessible to any
    glyph in the font, and are used to store repeated instructions - for
    example, components may be encoded as global subroutines, but so could
    hinting instructions.

    Remember that when interpreting a ``callgsubr`` instruction (or indeed
    a ``callsubr`` instruction) that you will need to add the "subroutine
    number bias" to number given:

    .. code:: python

            tt = ttLib.TTFont("Almendra-Bold.otf")
            u = tt["CFF "].cff[0].CharStrings["udieresis"]
            u.decompile()

            u.toXML(XMLWriter(sys.stdout))
            # <some stuff>
            # -64 callgsubr <-- Subroutine which implements the dieresis mark
            # <other stuff>

            tt["CFF "].cff[0].GlobalSubrs[-64] # <-- WRONG
            # <T2CharString (bytecode) at 103451d10>

            tt["CFF "].cff[0].GlobalSubrs[-64 + 107] # <-- RIGHT
            # <T2CharString (source) at 103451390>

    ("The bias applied depends on the number of subrs (gsubrs). If the number of
    subrs (gsubrs) is less than 1240, the bias is 107. Otherwise if it is less
    than 33900, it is 1131; otherwise it is 32768.",
    `Subroutine Operators <https://docs.microsoft.com/en-us/typography/opentype/otspec180/cff2charstr#section4.4>`)
    '''
    compilerClass = GlobalSubrsCompiler
    subrClass = psCharStrings.T2CharString
    charStringClass = psCharStrings.T2CharString
    globalSubrs: Incomplete
    private: Incomplete
    fdSelect: Incomplete
    fdArray: Incomplete
    def __init__(self, file=None, globalSubrs=None, private=None, fdSelect=None, fdArray=None, isCFF2=None) -> None: ...
    def produceItem(self, index, data, file, offset): ...
    def toXML(self, xmlWriter) -> None:
        '''Write the subroutines index into XML representation onto the given
        :class:`fontTools.misc.xmlWriter.XMLWriter`.

        .. code:: python

                writer = xmlWriter.XMLWriter(sys.stdout)
                tt["CFF "].cff[0].GlobalSubrs.toXML(writer)

        '''
    def fromXML(self, name, attrs, content) -> None: ...
    def getItemAndSelector(self, index): ...

class SubrsIndex(GlobalSubrsIndex):
    """This index contains a glyph's local subroutines. A local subroutine is a
    private set of ``CharString`` data which is accessible only to the glyph to
    which the index is attached."""
    compilerClass = SubrsCompiler

class TopDictIndex(Index):
    '''This index represents the array of ``TopDict`` structures in the font
    (again, usually only one entry is present). Hence the following calls are
    equivalent:

    .. code:: python

            tt["CFF "].cff[0]
            # <fontTools.cffLib.TopDict object at 0x102ed6e50>
            tt["CFF "].cff.topDictIndex[0]
            # <fontTools.cffLib.TopDict object at 0x102ed6e50>

    '''
    compilerClass = TopDictIndexCompiler
    cff2GetGlyphOrder: Incomplete
    _isCFF2: Incomplete
    items: Incomplete
    file: Incomplete
    offsets: Incomplete
    offsetBase: Incomplete
    def __init__(self, file=None, cff2GetGlyphOrder=None, topSize: int = 0, isCFF2=None) -> None: ...
    def produceItem(self, index, data, file, offset): ...
    def toXML(self, xmlWriter) -> None: ...

class FDArrayIndex(Index):
    compilerClass = FDArrayIndexCompiler
    def toXML(self, xmlWriter) -> None: ...
    def produceItem(self, index, data, file, offset): ...
    def fromXML(self, name, attrs, content) -> None: ...

class VarStoreData:
    file: Incomplete
    data: Incomplete
    otVarStore: Incomplete
    font: Incomplete
    def __init__(self, file=None, otVarStore=None) -> None: ...
    def decompile(self): ...
    def compile(self) -> None: ...
    def writeXML(self, xmlWriter, name) -> None: ...
    def xmlRead(self, name, attrs, content, parent) -> None: ...
    def __len__(self) -> int: ...
    def getNumRegions(self, vsIndex): ...

class FDSelect:
    format: Incomplete
    gidArray: Incomplete
    def __init__(self, file=None, numGlyphs=None, format=None) -> None: ...
    def __len__(self) -> int: ...
    def __getitem__(self, index): ...
    def __setitem__(self, index, fdSelectValue) -> None: ...
    def append(self, fdSelectValue) -> None: ...

class CharStrings:
    '''The ``CharStrings`` in the font represent the instructions for drawing
    each glyph. This object presents a dictionary interface to the font\'s
    CharStrings, indexed by glyph name:

    .. code:: python

            tt["CFF "].cff[0].CharStrings["a"]
            # <T2CharString (bytecode) at 103451e90>

    See :class:`fontTools.misc.psCharStrings.T1CharString` and
    :class:`fontTools.misc.psCharStrings.T2CharString` for how to decompile,
    compile and interpret the glyph drawing instructions in the returned objects.

    '''
    globalSubrs: Incomplete
    varStore: Incomplete
    charStringsIndex: Incomplete
    charStrings: Incomplete
    charStringsAreIndexed: int
    private: Incomplete
    fdSelect: Incomplete
    fdArray: Incomplete
    def __init__(self, file, charset, globalSubrs, private, fdSelect, fdArray, isCFF2=None, varStore=None) -> None: ...
    def keys(self): ...
    def values(self): ...
    def has_key(self, name): ...
    __contains__ = has_key
    def __len__(self) -> int: ...
    def __getitem__(self, name): ...
    def __setitem__(self, name, charString) -> None: ...
    def getItemAndSelector(self, name): ...
    def toXML(self, xmlWriter) -> None: ...
    def fromXML(self, name, attrs, content) -> None: ...

def readCard8(file): ...
def readCard16(file): ...
def readCard32(file): ...
def writeCard8(file, value) -> None: ...
def writeCard16(file, value) -> None: ...
def writeCard32(file, value) -> None: ...
def packCard8(value): ...
def packCard16(value): ...
def packCard32(value): ...
def buildOperatorDict(table): ...
def buildOpcodeDict(table): ...
def buildOrder(table): ...
def buildDefaults(table): ...
def buildConverters(table): ...

class SimpleConverter:
    def read(self, parent, value): ...
    def _read(self, parent, value): ...
    def write(self, parent, value): ...
    def xmlWrite(self, xmlWriter, name, value) -> None: ...
    def xmlRead(self, name, attrs, content, parent): ...

class ASCIIConverter(SimpleConverter):
    def _read(self, parent, value): ...
    def write(self, parent, value): ...
    def xmlWrite(self, xmlWriter, name, value) -> None: ...
    def xmlRead(self, name, attrs, content, parent): ...

class Latin1Converter(SimpleConverter):
    def _read(self, parent, value): ...
    def write(self, parent, value): ...
    def xmlWrite(self, xmlWriter, name, value) -> None: ...
    def xmlRead(self, name, attrs, content, parent): ...

def parseNum(s): ...
def parseBlendList(s): ...

class NumberConverter(SimpleConverter):
    def xmlWrite(self, xmlWriter, name, value) -> None: ...
    def xmlRead(self, name, attrs, content, parent): ...

class ArrayConverter(SimpleConverter):
    def xmlWrite(self, xmlWriter, name, value) -> None: ...
    def xmlRead(self, name, attrs, content, parent): ...

class TableConverter(SimpleConverter):
    def xmlWrite(self, xmlWriter, name, value) -> None: ...
    def xmlRead(self, name, attrs, content, parent): ...

class PrivateDictConverter(TableConverter):
    def getClass(self): ...
    def _read(self, parent, value): ...
    def write(self, parent, value): ...

class SubrsConverter(TableConverter):
    def getClass(self): ...
    def _read(self, parent, value): ...
    def write(self, parent, value): ...

class CharStringsConverter(TableConverter):
    def _read(self, parent, value): ...
    def write(self, parent, value): ...
    def xmlRead(self, name, attrs, content, parent): ...

class CharsetConverter(SimpleConverter):
    def _read(self, parent, value): ...
    def write(self, parent, value): ...
    def xmlWrite(self, xmlWriter, name, value) -> None: ...
    def xmlRead(self, name, attrs, content, parent) -> None: ...

class CharsetCompiler:
    data: Incomplete
    parent: Incomplete
    def __init__(self, strings, charset, parent) -> None: ...
    def setPos(self, pos, endPos) -> None: ...
    def getDataLength(self): ...
    def toFile(self, file) -> None: ...

def getStdCharSet(charset): ...
def getCIDfromName(name, strings): ...
def getSIDfromName(name, strings): ...
def packCharset0(charset, isCID, strings): ...
def packCharset(charset, isCID, strings): ...
def parseCharset0(numGlyphs, file, strings, isCID): ...
def parseCharset(numGlyphs, file, strings, isCID, fmt): ...

class EncodingCompiler:
    data: Incomplete
    parent: Incomplete
    def __init__(self, strings, encoding, parent) -> None: ...
    def setPos(self, pos, endPos) -> None: ...
    def getDataLength(self): ...
    def toFile(self, file) -> None: ...

class EncodingConverter(SimpleConverter):
    def _read(self, parent, value): ...
    def write(self, parent, value): ...
    def xmlWrite(self, xmlWriter, name, value) -> None: ...
    def xmlRead(self, name, attrs, content, parent): ...

def readSID(file):
    """Read a String ID (SID) â€” 2-byte unsigned integer."""
def parseEncodingSupplement(file, encoding, strings) -> None:
    """
    Parse the CFF Encoding supplement data:
      - nSups: number of supplementary mappings
      - each mapping: (code, SID) pair
    and apply them to the `encoding` list in place.
    """
def parseEncoding0(charset, file):
    """
    Format 0: simple list of codes.
    After reading the base table, optionally parse the supplement.
    """
def parseEncoding1(charset, file):
    """
    Format\xa01: range-based encoding.
    After reading the base ranges, optionally parse the supplement.
    """
def packEncoding0(charset, encoding, strings): ...
def packEncoding1(charset, encoding, strings): ...

class FDArrayConverter(TableConverter):
    def _read(self, parent, value): ...
    def write(self, parent, value): ...
    def xmlRead(self, name, attrs, content, parent): ...

class FDSelectConverter(SimpleConverter):
    def _read(self, parent, value): ...
    def write(self, parent, value): ...
    def xmlWrite(self, xmlWriter, name, value) -> None: ...
    def xmlRead(self, name, attrs, content, parent): ...

class VarStoreConverter(SimpleConverter):
    def _read(self, parent, value): ...
    def write(self, parent, value): ...
    def xmlWrite(self, xmlWriter, name, value) -> None: ...
    def xmlRead(self, name, attrs, content, parent): ...

def packFDSelect0(fdSelectArray): ...
def packFDSelect3(fdSelectArray): ...
def packFDSelect4(fdSelectArray): ...

class FDSelectCompiler:
    data: Incomplete
    parent: Incomplete
    def __init__(self, fdSelect, parent) -> None: ...
    def setPos(self, pos, endPos) -> None: ...
    def getDataLength(self): ...
    def toFile(self, file) -> None: ...

class VarStoreCompiler:
    parent: Incomplete
    data: Incomplete
    def __init__(self, varStoreData, parent) -> None: ...
    def setPos(self, pos, endPos) -> None: ...
    def getDataLength(self): ...
    def toFile(self, file) -> None: ...

class ROSConverter(SimpleConverter):
    def xmlWrite(self, xmlWriter, name, value) -> None: ...
    def xmlRead(self, name, attrs, content, parent): ...

topDictOperators: Incomplete
topDictOperators2: Incomplete
kBlendDictOpName: str
blendOp: int
privateDictOperators: Incomplete
privateDictOperators2: Incomplete

def addConverters(table) -> None: ...

class TopDictDecompiler(psCharStrings.DictDecompiler):
    operators: Incomplete

class PrivateDictDecompiler(psCharStrings.DictDecompiler):
    operators: Incomplete

class DictCompiler:
    maxBlendStack: int
    isCFF2: Incomplete
    dictObj: Incomplete
    strings: Incomplete
    parent: Incomplete
    rawDict: Incomplete
    def __init__(self, dictObj, strings, parent, isCFF2=None) -> None: ...
    def setPos(self, pos, endPos) -> None: ...
    def getDataLength(self): ...
    def compile(self, reason): ...
    def toFile(self, file) -> None: ...
    def arg_number(self, num): ...
    def arg_SID(self, s): ...
    def arg_array(self, value): ...
    def arg_delta(self, value): ...
    def arg_delta_blend(self, value):
        """A delta list with blend lists has to be *all* blend lists.

        The value is a list is arranged as follows::

                [
                        [V0, d0..dn]
                        [V1, d0..dn]
                        ...
                        [Vm, d0..dn]
                ]

        ``V`` is the absolute coordinate value from the default font, and ``d0-dn``
        are the delta values from the *n* regions. Each ``V`` is an absolute
        coordinate from the default font.

        We want to return a list::

                [
                        [v0, v1..vm]
                        [d0..dn]
                        ...
                        [d0..dn]
                        numBlends
                        blendOp
                ]

        where each ``v`` is relative to the previous default font value.
        """

def encodeNumber(num): ...

class TopDictCompiler(DictCompiler):
    opcodes: Incomplete
    def getChildren(self, strings): ...

class FontDictCompiler(DictCompiler):
    opcodes: Incomplete
    def __init__(self, dictObj, strings, parent, isCFF2=None) -> None: ...
    def getChildren(self, strings): ...

class PrivateDictCompiler(DictCompiler):
    maxBlendStack = maxStackLimit
    opcodes: Incomplete
    pos: Incomplete
    def setPos(self, pos, endPos) -> None: ...
    def getChildren(self, strings): ...

class BaseDict:
    rawDict: Incomplete
    skipNames: Incomplete
    strings: Incomplete
    _isCFF2: Incomplete
    file: Incomplete
    offset: Incomplete
    def __init__(self, strings=None, file=None, offset=None, isCFF2=None) -> None: ...
    def decompile(self, data) -> None: ...
    def postDecompile(self) -> None: ...
    def getCompiler(self, strings, parent, isCFF2=None): ...
    def __getattr__(self, name): ...
    def toXML(self, xmlWriter) -> None: ...
    def fromXML(self, name, attrs, content) -> None: ...

class TopDict(BaseDict):
    '''The ``TopDict`` represents the top-level dictionary holding font
    information. CFF2 tables contain a restricted set of top-level entries
    as described `here <https://docs.microsoft.com/en-us/typography/opentype/spec/cff2#7-top-dict-data>`_,
    but CFF tables may contain a wider range of information. This information
    can be accessed through attributes or through the dictionary returned
    through the ``rawDict`` property:

    .. code:: python

            font = tt["CFF "].cff[0]
            font.FamilyName
            # \'Linux Libertine O\'
            font.rawDict["FamilyName"]
            # \'Linux Libertine O\'

    More information is available in the CFF file\'s private dictionary, accessed
    via the ``Private`` property:

    .. code:: python

            tt["CFF "].cff[0].Private.BlueValues
            # [-15, 0, 515, 515, 666, 666]

    '''
    defaults: Incomplete
    converters: Incomplete
    compilerClass = TopDictCompiler
    order: Incomplete
    decompilerClass = TopDictDecompiler
    cff2GetGlyphOrder: Incomplete
    GlobalSubrs: Incomplete
    charset: Incomplete
    def __init__(self, strings=None, file=None, offset=None, GlobalSubrs=None, cff2GetGlyphOrder=None, isCFF2=None) -> None: ...
    def getGlyphOrder(self):
        """Returns a list of glyph names in the CFF font."""
    numGlyphs: Incomplete
    def postDecompile(self) -> None: ...
    skipNames: Incomplete
    def toXML(self, xmlWriter) -> None: ...
    def decompileAllCharStrings(self) -> None: ...
    FontBBox: Incomplete
    def recalcFontBBox(self) -> None: ...

class FontDict(BaseDict):
    defaults: Incomplete
    converters: Incomplete
    compilerClass = FontDictCompiler
    orderCFF: Incomplete
    orderCFF2: Incomplete
    decompilerClass = TopDictDecompiler
    vstore: Incomplete
    def __init__(self, strings=None, file=None, offset=None, GlobalSubrs=None, isCFF2=None, vstore=None) -> None: ...
    order: Incomplete
    _isCFF2: bool
    def setCFF2(self, isCFF2) -> None: ...

class PrivateDict(BaseDict):
    defaults: Incomplete
    converters: Incomplete
    order: Incomplete
    decompilerClass = PrivateDictDecompiler
    compilerClass = PrivateDictCompiler
    vstore: Incomplete
    nominalWidthX: Incomplete
    _isCFF2: bool
    def __init__(self, strings=None, file=None, offset=None, isCFF2=None, vstore=None) -> None: ...
    @property
    def in_cff2(self): ...
    def getNumRegions(self, vi=None): ...

class IndexedStrings:
    """SID -> string mapping."""
    strings: Incomplete
    def __init__(self, file=None) -> None: ...
    def getCompiler(self): ...
    def __len__(self) -> int: ...
    def __getitem__(self, SID): ...
    def getSID(self, s): ...
    def getStrings(self): ...
    stringMapping: Incomplete
    def buildStringMapping(self) -> None: ...

cffStandardStrings: Incomplete
cffStandardStringCount: int
cffStandardStringMapping: Incomplete
cffISOAdobeStrings: Incomplete
cffISOAdobeStringCount: int
cffIExpertStrings: Incomplete
cffExpertStringCount: int
cffExpertSubsetStrings: Incomplete
cffExpertSubsetStringCount: int
