from _typeshed import Incomplete
from fontTools.feaLib import ast
from fontTools.feaLib.error import FeatureLibError as FeatureLibError
from fontTools.feaLib.lexer import (
	IncludingLexer as IncludingLexer, Lexer as Lexer, NonIncludingLexer as NonIncludingLexer)
from fontTools.feaLib.variableScalar import VariableScalar as VariableScalar
from fontTools.misc.encodingTools import getEncoding as getEncoding
from fontTools.misc.textTools import bytechr as bytechr, tobytes as tobytes, tostr as tostr

log: Incomplete

class Parser:
    """Initializes a Parser object.

    Example:

        .. code:: python

            from fontTools.feaLib.parser import Parser
            parser = Parser(file, font.getReverseGlyphMap())
            parsetree = parser.parse()

    Note: the ``glyphNames`` iterable serves a double role to help distinguish
    glyph names from ranges in the presence of hyphens and to ensure that glyph
    names referenced in a feature file are actually part of a font's glyph set.
    If the iterable is left empty, no glyph name in glyph set checking takes
    place, and all glyph tokens containing hyphens are treated as literal glyph
    names, not as ranges. (Adding a space around the hyphen can, in any case,
    help to disambiguate ranges from glyph names containing hyphens.)

    By default, the parser will follow ``include()`` statements in the feature
    file. To turn this off, pass ``followIncludes=False``. Pass a directory string as
    ``includeDir`` to explicitly declare a directory to search included feature files
    in.
    """

    extensions: Incomplete
    ast = ast
    SS_FEATURE_TAGS: Incomplete
    CV_FEATURE_TAGS: Incomplete
    glyphNames_: Incomplete
    doc_: Incomplete
    anchors_: Incomplete
    glyphclasses_: Incomplete
    lookups_: Incomplete
    valuerecords_: Incomplete
    symbol_tables_: Incomplete
    cur_comments_: Incomplete
    next_token_location_: Incomplete
    lexer_: Incomplete
    missing: Incomplete
    def __init__(self, featurefile, glyphNames=(), followIncludes: bool = True, includeDir=None, **kwargs) -> None: ...
    def parse(self):
        """Parse the file, and return a :class:`fontTools.feaLib.ast.FeatureFile`
        object representing the root of the abstract syntax tree containing the
        parsed contents of the file.
        """
    def parse_anchor_(self): ...
    def parse_anchor_marks_(self): ...
    def parse_anchordef_(self): ...
    def parse_anonymous_(self): ...
    def parse_attach_(self): ...
    def parse_enumerate_(self, vertical): ...
    def parse_GlyphClassDef_(self): ...
    def parse_glyphclass_definition_(self): ...
    def split_glyph_range_(self, name, location): ...
    def parse_glyphclass_(self, accept_glyphname, accept_null: bool = False): ...
    def parse_glyph_pattern_(self, vertical): ...
    def parse_ignore_glyph_pattern_(self, sub): ...
    def parse_ignore_context_(self, sub): ...
    def parse_ignore_(self): ...
    def parse_include_(self): ...
    def parse_language_(self): ...
    def parse_ligatureCaretByIndex_(self): ...
    def parse_ligatureCaretByPos_(self): ...
    def parse_lookup_(self, vertical): ...
    def parse_lookupflag_(self): ...
    def parse_markClass_(self): ...
    def parse_position_(self, enumerated, vertical): ...
    def parse_position_cursive_(self, enumerated, vertical): ...
    def parse_position_base_(self, enumerated, vertical): ...
    def parse_position_ligature_(self, enumerated, vertical): ...
    def parse_position_mark_(self, enumerated, vertical): ...
    def parse_script_(self): ...
    def parse_substitute_(self): ...
    def parse_subtable_(self): ...
    def parse_size_parameters_(self): ...
    def parse_size_menuname_(self): ...
    def parse_table_(self): ...
    def parse_table_GDEF_(self, table) -> None: ...
    def parse_table_head_(self, table) -> None: ...
    def parse_table_hhea_(self, table) -> None: ...
    def parse_table_vhea_(self, table) -> None: ...
    def parse_table_name_(self, table) -> None: ...
    def parse_name_(self):
        """Parses a name record. See `section 9.e <https://adobe-type-tools.github.io/afdko/OpenTypeFeatureFileSpecification.html#9.e>`_."""
    def parse_stat_name_(self): ...
    def parse_nameid_(self): ...
    def unescape_string_(self, string, encoding): ...
    @staticmethod
    def unescape_unichr_(match): ...
    @staticmethod
    def unescape_byte_(match, encoding): ...
    def find_previous(self, statements, class_): ...
    def parse_table_BASE_(self, table) -> None: ...
    def parse_table_OS_2_(self, table) -> None: ...
    def parse_STAT_ElidedFallbackName(self): ...
    def parse_STAT_design_axis(self): ...
    def parse_STAT_axis_value_(self): ...
    def parse_STAT_location(self): ...
    def parse_table_STAT_(self, table) -> None: ...
    def parse_base_tag_list_(self): ...
    def parse_base_script_list_(self, count): ...
    def parse_base_script_record_(self, count): ...
    def parse_base_minmax_(self): ...
    def parse_device_(self): ...
    def is_next_value_(self): ...
    def parse_valuerecord_(self, vertical): ...
    def parse_valuerecord_definition_(self, vertical): ...
    def parse_languagesystem_(self): ...
    def parse_feature_block_(self, variation: bool = False): ...
    def parse_feature_reference_(self): ...
    def parse_featureNames_(self, tag):
        """Parses a ``featureNames`` statement found in stylistic set features.
        See section `8.c <https://adobe-type-tools.github.io/afdko/OpenTypeFeatureFileSpecification.html#8.c>`_.
        """
    def parse_cvParameters_(self, tag): ...
    def parse_cvNameIDs_(self, tag, block_name): ...
    def parse_cvCharacter_(self, tag): ...
    def parse_FontRevision_(self): ...
    def parse_conditionset_(self): ...
    def parse_block_(self, block, vertical, stylisticset=None, size_feature: bool = False, cv_feature=None) -> None: ...
    def is_cur_keyword_(self, k): ...
    def expect_class_name_(self): ...
    def expect_cid_(self): ...
    def expect_filename_(self): ...
    def expect_glyph_(self): ...
    def check_glyph_name_in_glyph_set(self, *names) -> None:
        """Adds a glyph name (just `start`) or glyph names of a
        range (`start` and `end`) which are not in the glyph set
        to the "missing list" for future error reporting.

        If no glyph set is present, does nothing.
        """
    def expect_markClass_reference_(self): ...
    def expect_tag_(self): ...
    def expect_script_tag_(self): ...
    def expect_language_tag_(self): ...
    def expect_symbol_(self, symbol): ...
    def expect_keyword_(self, keyword): ...
    def expect_name_(self): ...
    def expect_number_(self, variable: bool = False): ...
    def expect_variable_scalar_(self): ...
    def expect_master_(self): ...
    def expect_any_number_(self): ...
    def expect_float_(self): ...
    def expect_integer_or_float_(self): ...
    def expect_decipoint_(self): ...
    def expect_stat_flags(self): ...
    def expect_stat_values_(self): ...
    def expect_string_(self): ...
    cur_token_type_: Incomplete
    def advance_lexer_(self, comments: bool = False) -> None: ...
    @staticmethod
    def reverse_string_(s):
        """'abc' --> 'cba'"""
    def make_cid_range_(self, location, start, limit):
        """(location, 999, 1001) --> ["cid00999", "cid01000", "cid01001"]"""
    def make_glyph_range_(self, location, start, limit):
        """(location, "a.sc", "d.sc") --> ["a.sc", "b.sc", "c.sc", "d.sc"]"""

class SymbolTable:
    scopes_: Incomplete
    def __init__(self) -> None: ...
    def enter_scope(self) -> None: ...
    def exit_scope(self) -> None: ...
    def define(self, name, item) -> None: ...
    def resolve(self, name): ...
