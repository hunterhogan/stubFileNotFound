"""
This type stub file was generated by pyright.
"""

from enum import IntEnum, IntFlag
from fontTools.misc.transform import Transform
from .otBase import BaseTable, FormatSwitchingBaseTable, getFormatSwitchingBaseTableClass
from typing import Iterator, List, Optional, TYPE_CHECKING
from fontTools.ttLib.ttGlyphSet import _TTGlyphSet

"""fontTools.ttLib.tables.otTables -- A collection of classes representing the various
OpenType subtables.

Most are constructed upon import from data in otData.py, all are populated with
converter objects from otConverters.py.
"""
if TYPE_CHECKING:
    ...
log = ...
class VarComponentFlags(IntFlag):
    RESET_UNSPECIFIED_AXES = ...
    HAVE_AXES = ...
    AXIS_VALUES_HAVE_VARIATION = ...
    TRANSFORM_HAS_VARIATION = ...
    HAVE_TRANSLATE_X = ...
    HAVE_TRANSLATE_Y = ...
    HAVE_ROTATION = ...
    HAVE_CONDITION = ...
    HAVE_SCALE_X = ...
    HAVE_SCALE_Y = ...
    HAVE_TCENTER_X = ...
    HAVE_TCENTER_Y = ...
    GID_IS_24BIT = ...
    HAVE_SKEW_X = ...
    HAVE_SKEW_Y = ...
    RESERVED_MASK = ...


VarTransformMappingValues = ...
VAR_TRANSFORM_MAPPING = ...
_packer = ...
_unpacker = ...
class VarComponent:
    def __init__(self) -> None:
        ...
    
    def populateDefaults(self, propagator=...): # -> None:
        ...
    
    def decompile(self, data, font, localState):
        ...
    
    def compile(self, font): # -> bytes:
        ...
    
    def toXML(self, writer, ttFont, attrs): # -> None:
        ...
    
    def fromXML(self, name, attrs, content, ttFont): # -> None:
        ...
    
    def applyTransformDeltas(self, deltas): # -> None:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    


class VarCompositeGlyph:
    def __init__(self, components=...) -> None:
        ...
    
    def decompile(self, data, font, localState): # -> None:
        ...
    
    def compile(self, font): # -> bytes:
        ...
    
    def toXML(self, xmlWriter, font, attrs, name): # -> None:
        ...
    
    def fromXML(self, name, attrs, content, font): # -> None:
        ...
    


class AATStateTable:
    def __init__(self) -> None:
        ...
    


class AATState:
    def __init__(self) -> None:
        ...
    


class AATAction:
    _FLAGS = ...
    @staticmethod
    def compileActions(font, states): # -> tuple[None, None]:
        ...
    


class RearrangementMorphAction(AATAction):
    staticSize = ...
    actionHeaderSize = ...
    _FLAGS = ...
    _VERBS = ...
    def __init__(self) -> None:
        ...
    
    def compile(self, writer, font, actionIndex): # -> None:
        ...
    
    def decompile(self, reader, font, actionReader): # -> None:
        ...
    
    def toXML(self, xmlWriter, font, attrs, name): # -> None:
        ...
    
    def fromXML(self, name, attrs, content, font): # -> None:
        ...
    


class ContextualMorphAction(AATAction):
    staticSize = ...
    actionHeaderSize = ...
    _FLAGS = ...
    def __init__(self) -> None:
        ...
    
    def compile(self, writer, font, actionIndex): # -> None:
        ...
    
    def decompile(self, reader, font, actionReader): # -> None:
        ...
    
    def toXML(self, xmlWriter, font, attrs, name): # -> None:
        ...
    
    def fromXML(self, name, attrs, content, font): # -> None:
        ...
    


class LigAction:
    def __init__(self) -> None:
        ...
    


class LigatureMorphAction(AATAction):
    staticSize = ...
    actionHeaderSize = ...
    _FLAGS = ...
    def __init__(self) -> None:
        ...
    
    def compile(self, writer, font, actionIndex): # -> None:
        ...
    
    def decompile(self, reader, font, actionReader): # -> None:
        ...
    
    @staticmethod
    def compileActions(font, states): # -> tuple[bytes, dict[Any, Any]]:
        ...
    
    def compileLigActions(self): # -> bytes:
        ...
    
    def fromXML(self, name, attrs, content, font): # -> None:
        ...
    
    def toXML(self, xmlWriter, font, attrs, name): # -> None:
        ...
    


class InsertionMorphAction(AATAction):
    staticSize = ...
    actionHeaderSize = ...
    _FLAGS = ...
    def __init__(self) -> None:
        ...
    
    def compile(self, writer, font, actionIndex): # -> None:
        ...
    
    def decompile(self, reader, font, actionReader): # -> None:
        ...
    
    def toXML(self, xmlWriter, font, attrs, name): # -> None:
        ...
    
    def fromXML(self, name, attrs, content, font): # -> None:
        ...
    
    @staticmethod
    def compileActions(font, states): # -> tuple[bytes, dict[Any, Any]]:
        ...
    


class FeatureParams(BaseTable):
    def compile(self, writer, font): # -> None:
        ...
    
    def toXML(self, xmlWriter, font, attrs=..., name=...): # -> None:
        ...
    


class FeatureParamsSize(FeatureParams):
    ...


class FeatureParamsStylisticSet(FeatureParams):
    ...


class FeatureParamsCharacterVariants(FeatureParams):
    ...


class Coverage(FormatSwitchingBaseTable):
    def populateDefaults(self, propagator=...): # -> None:
        ...
    
    def postRead(self, rawTable, font): # -> None:
        ...
    
    def preWrite(self, font): # -> dict[str, list[list[Any]]] | dict[str, Any | list[Any]]:
        ...
    
    def toXML2(self, xmlWriter, font): # -> None:
        ...
    
    def fromXML(self, name, attrs, content, font): # -> None:
        ...
    


NO_VARIATION_INDEX = ...
class DeltaSetIndexMap(getFormatSwitchingBaseTableClass("uint8")):
    def populateDefaults(self, propagator=...): # -> None:
        ...
    
    def postRead(self, rawTable, font): # -> None:
        ...
    
    @staticmethod
    def getEntryFormat(mapping): # -> int:
        ...
    
    def preWrite(self, font): # -> dict[str, Any]:
        ...
    
    def toXML2(self, xmlWriter, font): # -> None:
        ...
    
    def fromXML(self, name, attrs, content, font): # -> None:
        ...
    
    def __getitem__(self, i): # -> Literal[4294967295]:
        ...
    


class VarIdxMap(BaseTable):
    def populateDefaults(self, propagator=...): # -> None:
        ...
    
    def postRead(self, rawTable, font): # -> None:
        ...
    
    def preWrite(self, font): # -> dict[str, list[Any]]:
        ...
    
    def toXML2(self, xmlWriter, font): # -> None:
        ...
    
    def fromXML(self, name, attrs, content, font): # -> None:
        ...
    
    def __getitem__(self, glyphName):
        ...
    


class VarRegionList(BaseTable):
    def preWrite(self, font): # -> dict[str, Any | CountReference]:
        ...
    


class SingleSubst(FormatSwitchingBaseTable):
    def populateDefaults(self, propagator=...): # -> None:
        ...
    
    def postRead(self, rawTable, font): # -> None:
        ...
    
    def preWrite(self, font): # -> dict[Any, Any]:
        ...
    
    def toXML2(self, xmlWriter, font): # -> None:
        ...
    
    def fromXML(self, name, attrs, content, font): # -> None:
        ...
    


class MultipleSubst(FormatSwitchingBaseTable):
    def populateDefaults(self, propagator=...): # -> None:
        ...
    
    def postRead(self, rawTable, font): # -> None:
        ...
    
    def preWrite(self, font): # -> dict[str, Coverage | list[Any]]:
        ...
    
    def toXML2(self, xmlWriter, font): # -> None:
        ...
    
    def fromXML(self, name, attrs, content, font): # -> None:
        ...
    
    @staticmethod
    def makeSequence_(g):
        ...
    


class ClassDef(FormatSwitchingBaseTable):
    def populateDefaults(self, propagator=...): # -> None:
        ...
    
    def postRead(self, rawTable, font): # -> None:
        ...
    
    def preWrite(self, font): # -> dict[str, list[list[Any]]] | dict[str, Any] | dict[str, list[Any]]:
        ...
    
    def toXML2(self, xmlWriter, font): # -> None:
        ...
    
    def fromXML(self, name, attrs, content, font): # -> None:
        ...
    


class AlternateSubst(FormatSwitchingBaseTable):
    def populateDefaults(self, propagator=...): # -> None:
        ...
    
    def postRead(self, rawTable, font): # -> None:
        ...
    
    def preWrite(self, font): # -> dict[str, Coverage | list[Any]]:
        ...
    
    def toXML2(self, xmlWriter, font): # -> None:
        ...
    
    def fromXML(self, name, attrs, content, font): # -> None:
        ...
    


class LigatureSubst(FormatSwitchingBaseTable):
    def populateDefaults(self, propagator=...): # -> None:
        ...
    
    def postRead(self, rawTable, font): # -> None:
        ...
    
    def preWrite(self, font): # -> dict[str, Coverage | list[Any]]:
        ...
    
    def toXML2(self, xmlWriter, font): # -> None:
        ...
    
    def fromXML(self, name, attrs, content, font): # -> None:
        ...
    


class COLR(BaseTable):
    def decompile(self, reader, font): # -> None:
        ...
    
    def preWrite(self, font): # -> dict[str, Any | CountReference]:
        ...
    
    def computeClipBoxes(self, glyphSet: _TTGlyphSet, quantization: int = ...): # -> None:
        ...
    


class LookupList(BaseTable):
    @property
    def table(self): # -> Literal['GSUB', 'GPOS']:
        ...
    
    def toXML2(self, xmlWriter, font): # -> None:
        ...
    


class BaseGlyphRecordArray(BaseTable):
    def preWrite(self, font): # -> dict[str, Any]:
        ...
    


class BaseGlyphList(BaseTable):
    def preWrite(self, font): # -> dict[str, Any]:
        ...
    


class ClipBoxFormat(IntEnum):
    Static = ...
    Variable = ...
    def is_variable(self): # -> bool:
        ...
    
    def as_variable(self): # -> Literal[ClipBoxFormat.Variable]:
        ...
    


class ClipBox(getFormatSwitchingBaseTableClass("uint8")):
    formatEnum = ClipBoxFormat
    def as_tuple(self): # -> tuple[Any, ...]:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class ClipList(getFormatSwitchingBaseTableClass("uint8")):
    def populateDefaults(self, propagator=...): # -> None:
        ...
    
    def postRead(self, rawTable, font): # -> None:
        ...
    
    def groups(self): # -> dict[frozenset[Any], Any]:
        ...
    
    def preWrite(self, font): # -> dict[str, int | list[Any]]:
        ...
    
    def toXML(self, xmlWriter, font, attrs=..., name=...): # -> None:
        ...
    
    def fromXML(self, name, attrs, content, font): # -> None:
        ...
    


class ExtendMode(IntEnum):
    PAD = ...
    REPEAT = ...
    REFLECT = ...


class CompositeMode(IntEnum):
    CLEAR = ...
    SRC = ...
    DEST = ...
    SRC_OVER = ...
    DEST_OVER = ...
    SRC_IN = ...
    DEST_IN = ...
    SRC_OUT = ...
    DEST_OUT = ...
    SRC_ATOP = ...
    DEST_ATOP = ...
    XOR = ...
    PLUS = ...
    SCREEN = ...
    OVERLAY = ...
    DARKEN = ...
    LIGHTEN = ...
    COLOR_DODGE = ...
    COLOR_BURN = ...
    HARD_LIGHT = ...
    SOFT_LIGHT = ...
    DIFFERENCE = ...
    EXCLUSION = ...
    MULTIPLY = ...
    HSL_HUE = ...
    HSL_SATURATION = ...
    HSL_COLOR = ...
    HSL_LUMINOSITY = ...


class PaintFormat(IntEnum):
    PaintColrLayers = ...
    PaintSolid = ...
    PaintVarSolid = ...
    PaintLinearGradient = ...
    PaintVarLinearGradient = ...
    PaintRadialGradient = ...
    PaintVarRadialGradient = ...
    PaintSweepGradient = ...
    PaintVarSweepGradient = ...
    PaintGlyph = ...
    PaintColrGlyph = ...
    PaintTransform = ...
    PaintVarTransform = ...
    PaintTranslate = ...
    PaintVarTranslate = ...
    PaintScale = ...
    PaintVarScale = ...
    PaintScaleAroundCenter = ...
    PaintVarScaleAroundCenter = ...
    PaintScaleUniform = ...
    PaintVarScaleUniform = ...
    PaintScaleUniformAroundCenter = ...
    PaintVarScaleUniformAroundCenter = ...
    PaintRotate = ...
    PaintVarRotate = ...
    PaintRotateAroundCenter = ...
    PaintVarRotateAroundCenter = ...
    PaintSkew = ...
    PaintVarSkew = ...
    PaintSkewAroundCenter = ...
    PaintVarSkewAroundCenter = ...
    PaintComposite = ...
    def is_variable(self): # -> bool:
        ...
    
    def as_variable(self): # -> Self | PaintFormat | None:
        ...
    


class Paint(getFormatSwitchingBaseTableClass("uint8")):
    formatEnum = PaintFormat
    def getFormatName(self): # -> Literal['PaintColrLayers', 'PaintSolid', 'PaintVarSolid', 'PaintLinearGradient', 'PaintVarLinearGradient', 'PaintRadialGradient', 'PaintVarRadialGradient', 'PaintSweepGradient', 'PaintVarSweepGradient', 'PaintGlyph', 'PaintColrGlyph', 'PaintTransform', 'PaintVarTransform', 'PaintTranslate', 'PaintVarTranslate', 'PaintScale', 'PaintVarScale', 'PaintScaleAroundCenter', 'PaintVarScaleAroundCenter', 'PaintScaleUniform', 'PaintVarScaleUniform', 'PaintScaleUniformAroundCenter', 'PaintVarScaleUniformAroundCenter', 'PaintRotate', 'PaintVarRotate', 'PaintRotateAroundCenter', 'PaintVarRotateAroundCenter', 'PaintSkew', 'PaintVarSkew', 'PaintSkewAroundCenter', 'PaintVarSkewAroundCenter', 'PaintComposite']:
        ...
    
    def toXML(self, xmlWriter, font, attrs=..., name=...): # -> None:
        ...
    
    def iterPaintSubTables(self, colr: COLR) -> Iterator[BaseTable.SubTableEntry]:
        ...
    
    def getChildren(self, colr) -> List[Paint]:
        ...
    
    def traverse(self, colr: COLR, callback): # -> None:
        """Depth-first traversal of graph rooted at self, callback on each node."""
        ...
    
    def getTransform(self) -> Transform:
        ...
    
    def computeClipBox(self, colr: COLR, glyphSet: _TTGlyphSet, quantization: int = ...) -> Optional[ClipBox]:
        ...
    


_equivalents = ...
def fixLookupOverFlows(ttf, overflowRecord): # -> Literal[0, 1]:
    """Either the offset from the LookupList to a lookup overflowed, or
    an offset from a lookup to a subtable overflowed.

    The table layout is::

      GPSO/GUSB
              Script List
              Feature List
              LookUpList
                      Lookup[0] and contents
                              SubTable offset list
                                      SubTable[0] and contents
                                      ...
                                      SubTable[n] and contents
                      ...
                      Lookup[n] and contents
                              SubTable offset list
                                      SubTable[0] and contents
                                      ...
                                      SubTable[n] and contents

    If the offset to a lookup overflowed (SubTableIndex is None)
            we must promote the *previous* lookup to an Extension type.

    If the offset from a lookup to subtable overflowed, then we must promote it
            to an Extension Lookup type.
    """
    ...

def splitMultipleSubst(oldSubTable, newSubTable, overflowRecord): # -> Literal[1]:
    ...

def splitAlternateSubst(oldSubTable, newSubTable, overflowRecord): # -> Literal[1]:
    ...

def splitLigatureSubst(oldSubTable, newSubTable, overflowRecord): # -> Literal[1]:
    ...

def splitPairPos(oldSubTable, newSubTable, overflowRecord): # -> bool:
    ...

def splitMarkBasePos(oldSubTable, newSubTable, overflowRecord): # -> bool:
    ...

splitTable = ...
def fixSubTableOverFlows(ttf, overflowRecord): # -> bool | Literal[1]:
    """
    An offset has overflowed within a sub-table. We need to divide this subtable into smaller parts.
    """
    ...

