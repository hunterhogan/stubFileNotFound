"""
This type stub file was generated by pyright.
"""

import fontTools.ttLib.tables.otTables as otTables
from fontTools.ttLib.ttVisitor import TTVisitor
from fontTools import ttLib
from . import DefaultTable

log = ...
nameRecordFormat = ...
nameRecordSize = ...
class table__n_a_m_e(DefaultTable.DefaultTable):
    """Naming table

    The ``name`` table is used to store a variety of strings that can be
    associated with user-facing font information. Records in the ``name``
    table can be tagged with language tags to support multilingual naming
    and can support platform-specific character-encoding variants.

    See also https://learn.microsoft.com/en-us/typography/opentype/spec/name
    """
    dependencies = ...
    def __init__(self, tag=...) -> None:
        ...
    
    def decompile(self, data, ttFont): # -> None:
        ...
    
    def compile(self, ttFont): # -> bytes:
        ...
    
    def toXML(self, writer, ttFont): # -> None:
        ...
    
    def fromXML(self, name, attrs, content, ttFont): # -> None:
        ...
    
    def getName(self, nameID: int, platformID: int, platEncID: int, langID: int | None = ...) -> NameRecord | None:
        ...
    
    def getDebugName(self, nameID: int) -> str | None:
        ...
    
    def getFirstDebugName(self, nameIDs): # -> str | None:
        ...
    
    def getBestFamilyName(self): # -> str | None:
        ...
    
    def getBestSubFamilyName(self): # -> str | None:
        ...
    
    def getBestFullName(self): # -> str | None:
        ...
    
    def setName(self, string, nameID, platformID, platEncID, langID): # -> None:
        """Set the 'string' for the name record identified by 'nameID', 'platformID',
        'platEncID' and 'langID'. If a record with that nameID doesn't exist, create it
        and append to the name table.

        'string' can be of type `str` (`unicode` in PY2) or `bytes`. In the latter case,
        it is assumed to be already encoded with the correct plaform-specific encoding
        identified by the (platformID, platEncID, langID) triplet. A warning is issued
        to prevent unexpected results.
        """
        ...
    
    def removeNames(self, nameID=..., platformID=..., platEncID=..., langID=...): # -> None:
        """Remove any name records identified by the given combination of 'nameID',
        'platformID', 'platEncID' and 'langID'.
        """
        ...
    
    @staticmethod
    def removeUnusedNames(ttFont): # -> set[Any]:
        """Remove any name records which are not in NameID range 0-255 and not utilized
        within the font itself."""
        ...
    
    def findMultilingualName(self, names, windows=..., mac=..., minNameID=..., ttFont=...): # -> None:
        """Return the name ID of an existing multilingual name that
        matches the 'names' dictionary, or None if not found.

        'names' is a dictionary with the name in multiple languages,
        such as {'en': 'Pale', 'de': 'Blaß', 'de-CH': 'Blass'}.
        The keys can be arbitrary IETF BCP 47 language codes;
        the values are Unicode strings.

        If 'windows' is True, the returned name ID is guaranteed
        exist for all requested languages for platformID=3 and
        platEncID=1.
        If 'mac' is True, the returned name ID is guaranteed to exist
        for all requested languages for platformID=1 and platEncID=0.

        The returned name ID will not be less than the 'minNameID'
        argument.
        """
        ...
    
    def addMultilingualName(self, names, ttFont=..., nameID=..., windows=..., mac=..., minNameID=...): # -> Any:
        """Add a multilingual name, returning its name ID

        'names' is a dictionary with the name in multiple languages,
        such as {'en': 'Pale', 'de': 'Blaß', 'de-CH': 'Blass'}.
        The keys can be arbitrary IETF BCP 47 language codes;
        the values are Unicode strings.

        'ttFont' is the TTFont to which the names are added, or None.
        If present, the font's 'ltag' table can get populated
        to store exotic language codes, which allows encoding
        names that otherwise cannot get encoded at all.

        'nameID' is the name ID to be used, or None to let the library
        find an existing set of name records that match, or pick an
        unused name ID.

        If 'windows' is True, a platformID=3 name record will be added.
        If 'mac' is True, a platformID=1 name record will be added.

        If the 'nameID' argument is None, the created nameID will not
        be less than the 'minNameID' argument.
        """
        ...
    
    def addName(self, string, platforms=..., minNameID=...): # -> Any:
        """Add a new name record containing 'string' for each (platformID, platEncID,
        langID) tuple specified in the 'platforms' list.

        The nameID is assigned in the range between 'minNameID'+1 and 32767 (inclusive),
        following the last nameID in the name table.
        If no 'platforms' are specified, two English name records are added, one for the
        Macintosh (platformID=0), and one for the Windows platform (3).

        The 'string' must be a Unicode string, so it can be encoded with different,
        platform-specific encodings.

        Return the new nameID.
        """
        ...
    


def makeName(string, nameID, platformID, platEncID, langID): # -> NameRecord:
    ...

class NameRecord:
    def getEncoding(self, default=...): # -> str | None:
        """Returns the Python encoding name for this name entry based on its platformID,
        platEncID, and langID.  If encoding for these values is not known, by default
        'ascii' is returned.  That can be overriden by passing a value to the default
        argument.
        """
        ...
    
    def encodingIsUnicodeCompatible(self): # -> bool:
        ...
    
    def __str__(self) -> str:
        ...
    
    def isUnicode(self): # -> Any | bool:
        ...
    
    def toUnicode(self, errors: str = ...) -> str:
        """
        If self.string is a Unicode string, return it; otherwise try decoding the
        bytes in self.string to a Unicode string using the encoding of this
        entry as returned by self.getEncoding(); Note that  self.getEncoding()
        returns 'ascii' if the encoding is unknown to the library.

        Certain heuristics are performed to recover data from bytes that are
        ill-formed in the chosen encoding, or that otherwise look misencoded
        (mostly around bad UTF-16BE encoded bytes, or bytes that look like UTF-16BE
        but marked otherwise).  If the bytes are ill-formed and the heuristics fail,
        the error is handled according to the errors parameter to this function, which is
        passed to the underlying decode() function; by default it throws a
        UnicodeDecodeError exception.

        Note: The mentioned heuristics mean that roundtripping a font to XML and back
        to binary might recover some misencoded data whereas just loading the font
        and saving it back will not change them.
        """
        ...
    
    def toBytes(self, errors=...): # -> bytes:
        """If self.string is a bytes object, return it; otherwise try encoding
        the Unicode string in self.string to bytes using the encoding of this
        entry as returned by self.getEncoding(); Note that self.getEncoding()
        returns 'ascii' if the encoding is unknown to the library.

        If the Unicode string cannot be encoded to bytes in the chosen encoding,
        the error is handled according to the errors parameter to this function,
        which is passed to the underlying encode() function; by default it throws a
        UnicodeEncodeError exception.
        """
        ...
    
    toStr = ...
    def toXML(self, writer, ttFont): # -> None:
        ...
    
    def fromXML(self, name, attrs, content, ttFont): # -> None:
        ...
    
    def __lt__(self, other) -> bool:
        ...
    
    def __repr__(self): # -> LiteralString:
        ...
    


_WINDOWS_LANGUAGES = ...
_MAC_LANGUAGES = ...
_WINDOWS_LANGUAGE_CODES = ...
_MAC_LANGUAGE_CODES = ...
_MAC_LANGUAGE_TO_SCRIPT = ...
class NameRecordVisitor(TTVisitor):
    TABLES = ...
    def __init__(self) -> None:
        ...
    


@NameRecordVisitor.register_attrs(((otTables.FeatureParamsSize, ("SubfamilyNameID", )), (otTables.FeatureParamsStylisticSet, ("UINameID", )), (otTables.STAT, ("ElidedFallbackNameID", )), (otTables.AxisRecord, ("AxisNameID", )), (otTables.AxisValue, ("ValueNameID", )), (otTables.FeatureName, ("FeatureNameID", )), (otTables.Setting, ("SettingNameID", ))))
def visit(visitor, obj, attr, value): # -> None:
    ...

@NameRecordVisitor.register(otTables.FeatureParamsCharacterVariants)
def visit(visitor, obj): # -> None:
    ...

@NameRecordVisitor.register(ttLib.getTableClass("fvar"))
def visit(visitor, obj): # -> None:
    ...

@NameRecordVisitor.register(ttLib.getTableClass("CPAL"))
def visit(visitor, obj): # -> None:
    ...

@NameRecordVisitor.register(ttLib.TTFont)
def visit(visitor, font, *args, **kwargs): # -> Literal[False]:
    ...

