"""
This type stub file was generated by pyright.
"""

from fontTools import version
from . import DefaultTable
from fontTools.misc.loggingTools import deprecateFunction
from typing import Set

"""_g_l_y_f.py -- Converter classes for the 'glyf' table."""
log = ...
version = ...
SCALE_COMPONENT_OFFSET_DEFAULT = ...
class table__g_l_y_f(DefaultTable.DefaultTable):
    """Glyph Data table

    This class represents the `glyf <https://docs.microsoft.com/en-us/typography/opentype/spec/glyf>`_
    table, which contains outlines for glyphs in TrueType format. In many cases,
    it is easier to access and manipulate glyph outlines through the ``GlyphSet``
    object returned from :py:meth:`fontTools.ttLib.ttFont.getGlyphSet`::

                    >> from fontTools.pens.boundsPen import BoundsPen
                    >> glyphset = font.getGlyphSet()
                    >> bp = BoundsPen(glyphset)
                    >> glyphset["A"].draw(bp)
                    >> bp.bounds
                    (19, 0, 633, 716)

    However, this class can be used for low-level access to the ``glyf`` table data.
    Objects of this class support dictionary-like access, mapping glyph names to
    :py:class:`Glyph` objects::

                    >> glyf = font["glyf"]
                    >> len(glyf["Aacute"].components)
                    2

    Note that when adding glyphs to the font via low-level access to the ``glyf``
    table, the new glyphs must also be added to the ``hmtx``/``vmtx`` table::

                    >> font["glyf"]["divisionslash"] = Glyph()
                    >> font["hmtx"]["divisionslash"] = (640, 0)

    """
    dependencies = ...
    padding = ...
    def decompile(self, data, ttFont): # -> None:
        ...
    
    def ensureDecompiled(self, recurse=...): # -> None:
        ...
    
    def compile(self, ttFont): # -> bytes:
        ...
    
    def toXML(self, writer, ttFont, splitGlyphs=...): # -> None:
        ...
    
    def fromXML(self, name, attrs, content, ttFont): # -> None:
        ...
    
    def setGlyphOrder(self, glyphOrder): # -> None:
        """Sets the glyph order

        Args:
                glyphOrder ([str]): List of glyph names in order.
        """
        ...
    
    def getGlyphName(self, glyphID):
        """Returns the name for the glyph with the given ID.

        Raises a ``KeyError`` if the glyph name is not found in the font.
        """
        ...
    
    def getGlyphID(self, glyphName): # -> Any:
        """Returns the ID of the glyph with the given name.

        Raises a ``ValueError`` if the glyph is not found in the font.
        """
        ...
    
    def removeHinting(self): # -> None:
        """Removes TrueType hints from all glyphs in the glyphset.

        See :py:meth:`Glyph.removeHinting`.
        """
        ...
    
    def keys(self): # -> dict_keys[Any, Any]:
        ...
    
    def has_key(self, glyphName): # -> bool:
        ...
    
    __contains__ = ...
    def get(self, glyphName, default=...): # -> None:
        ...
    
    def __getitem__(self, glyphName):
        ...
    
    def __setitem__(self, glyphName, glyph): # -> None:
        ...
    
    def __delitem__(self, glyphName): # -> None:
        ...
    
    def __len__(self): # -> int:
        ...
    
    @deprecateFunction("use '_getPhantomPoints' instead", category=DeprecationWarning)
    def getPhantomPoints(self, glyphName, ttFont, defaultVerticalOrigin=...): # -> list[tuple[Any, int] | tuple[int, Any | int]]:
        """Old public name for self._getPhantomPoints().
        See: https://github.com/fonttools/fonttools/pull/2266"""
        ...
    
    @deprecateFunction("use '_getCoordinatesAndControls' instead", category=DeprecationWarning)
    def getCoordinatesAndControls(self, glyphName, ttFont, defaultVerticalOrigin=...): # -> tuple[GlyphCoordinates | Any, _GlyphControls] | None:
        """Old public name for self._getCoordinatesAndControls().
        See: https://github.com/fonttools/fonttools/pull/2266"""
        ...
    
    @deprecateFunction("use '_setCoordinates' instead", category=DeprecationWarning)
    def setCoordinates(self, glyphName, ttFont): # -> None:
        """Old public name for self._setCoordinates().
        See: https://github.com/fonttools/fonttools/pull/2266"""
        ...
    


_GlyphControls = ...
glyphHeaderFormat = ...
flagOnCurve = ...
flagXShort = ...
flagYShort = ...
flagRepeat = ...
flagXsame = ...
flagYsame = ...
flagOverlapSimple = ...
flagCubic = ...
keepFlags = ...
_flagSignBytes = ...
def flagBest(x, y, onCurve): # -> tuple[int, Literal[0, 1, 2, 3, 4]]:
    """For a given x,y delta pair, returns the flag that packs this pair
    most efficiently, as well as the number of byte cost of such flag."""
    ...

def flagFits(newFlag, oldFlag, mask): # -> bool:
    ...

def flagSupports(newFlag, oldFlag): # -> bool:
    ...

def flagEncodeCoord(flag, mask, coord, coordBytes): # -> None:
    ...

def flagEncodeCoords(flag, x, y, xBytes, yBytes): # -> None:
    ...

ARG_1_AND_2_ARE_WORDS = ...
ARGS_ARE_XY_VALUES = ...
ROUND_XY_TO_GRID = ...
WE_HAVE_A_SCALE = ...
NON_OVERLAPPING = ...
MORE_COMPONENTS = ...
WE_HAVE_AN_X_AND_Y_SCALE = ...
WE_HAVE_A_TWO_BY_TWO = ...
WE_HAVE_INSTRUCTIONS = ...
USE_MY_METRICS = ...
OVERLAP_COMPOUND = ...
SCALED_COMPONENT_OFFSET = ...
UNSCALED_COMPONENT_OFFSET = ...
CompositeMaxpValues = ...
class Glyph:
    """This class represents an individual TrueType glyph.

    TrueType glyph objects come in two flavours: simple and composite. Simple
    glyph objects contain contours, represented via the ``.coordinates``,
    ``.flags``, ``.numberOfContours``, and ``.endPtsOfContours`` attributes;
    composite glyphs contain components, available through the ``.components``
    attributes.

    Because the ``.coordinates`` attribute (and other simple glyph attributes mentioned
    above) is only set on simple glyphs and the ``.components`` attribute is only
    set on composite glyphs, it is necessary to use the :py:meth:`isComposite`
    method to test whether a glyph is simple or composite before attempting to
    access its data.

    For a composite glyph, the components can also be accessed via array-like access::

            >> assert(font["glyf"]["Aacute"].isComposite())
            >> font["glyf"]["Aacute"][0]
            <fontTools.ttLib.tables._g_l_y_f.GlyphComponent at 0x1027b2ee0>

    """
    def __init__(self, data=...) -> None:
        ...
    
    def compact(self, glyfTable, recalcBBoxes=...): # -> None:
        ...
    
    def expand(self, glyfTable): # -> None:
        ...
    
    def compile(self, glyfTable, recalcBBoxes=..., *, boundsDone=..., optimizeSize=...): # -> bytes | bytearray:
        ...
    
    def toXML(self, writer, ttFont): # -> None:
        ...
    
    def fromXML(self, name, attrs, content, ttFont): # -> None:
        ...
    
    def getCompositeMaxpValues(self, glyfTable, maxComponentDepth=...): # -> CompositeMaxpValues:
        ...
    
    def getMaxpValues(self): # -> tuple[int, int]:
        ...
    
    def decompileComponents(self, data, glyfTable): # -> None:
        ...
    
    def decompileCoordinates(self, data): # -> None:
        ...
    
    def decompileCoordinatesRaw(self, nCoordinates, data, pos=...): # -> tuple[bytearray, tuple[Any, ...], tuple[Any, ...]]:
        ...
    
    def compileComponents(self, glyfTable): # -> bytes:
        ...
    
    def compileCoordinates(self, *, optimizeSize=...): # -> bytes:
        ...
    
    def compileDeltasGreedy(self, flags, deltas): # -> tuple[bytearray, bytearray, bytearray]:
        ...
    
    def compileDeltasOptimal(self, flags, deltas): # -> tuple[bytearray, bytearray, bytearray]:
        ...
    
    def compileDeltasForSpeed(self, flags, deltas): # -> tuple[bytearray, bytearray, bytearray]:
        ...
    
    def recalcBounds(self, glyfTable, *, boundsDone=...): # -> None:
        """Recalculates the bounds of the glyph.

        Each glyph object stores its bounding box in the
        ``xMin``/``yMin``/``xMax``/``yMax`` attributes. These bounds must be
        recomputed when the ``coordinates`` change. The ``table__g_l_y_f`` bounds
        must be provided to resolve component bounds.
        """
        ...
    
    def tryRecalcBoundsComposite(self, glyfTable, *, boundsDone=...): # -> bool:
        """Try recalculating the bounds of a composite glyph that has
        certain constrained properties. Namely, none of the components
        have a transform other than an integer translate, and none
        uses the anchor points.

        Each glyph object stores its bounding box in the
        ``xMin``/``yMin``/``xMax``/``yMax`` attributes. These bounds must be
        recomputed when the ``coordinates`` change. The ``table__g_l_y_f`` bounds
        must be provided to resolve component bounds.

        Return True if bounds were calculated, False otherwise.
        """
        ...
    
    def isComposite(self): # -> Any | bool:
        """Test whether a glyph has components"""
        ...
    
    def getCoordinates(self, glyfTable, *, round=...): # -> tuple[GlyphCoordinates, list[int], bytearray] | tuple[GlyphCoordinates, list[Any], bytearray]:
        """Return the coordinates, end points and flags

        This method returns three values: A :py:class:`GlyphCoordinates` object,
        a list of the indexes of the final points of each contour (allowing you
        to split up the coordinates list into contours) and a list of flags.

        On simple glyphs, this method returns information from the glyph's own
        contours; on composite glyphs, it "flattens" all components recursively
        to return a list of coordinates representing all the components involved
        in the glyph.

        To interpret the flags for each point, see the "Simple Glyph Flags"
        section of the `glyf table specification <https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#simple-glyph-description>`.
        """
        ...
    
    def getComponentNames(self, glyfTable): # -> list[Any]:
        """Returns a list of names of component glyphs used in this glyph

        This method can be used on simple glyphs (in which case it returns an
        empty list) or composite glyphs.
        """
        ...
    
    def trim(self, remove_hinting=...): # -> None:
        """Remove padding and, if requested, hinting, from a glyph.
        This works on both expanded and compacted glyphs, without
        expanding it."""
        ...
    
    def removeHinting(self): # -> None:
        """Removes TrueType hinting instructions from the glyph."""
        ...
    
    def draw(self, pen, glyfTable, offset=...): # -> None:
        """Draws the glyph using the supplied pen object.

        Arguments:
                pen: An object conforming to the pen protocol.
                glyfTable: A :py:class:`table__g_l_y_f` object, to resolve components.
                offset (int): A horizontal offset. If provided, all coordinates are
                        translated by this offset.
        """
        ...
    
    def drawPoints(self, pen, glyfTable, offset=...): # -> None:
        """Draw the glyph using the supplied pointPen. As opposed to Glyph.draw(),
        this will not change the point indices.
        """
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    


_roundv = ...
def dropImpliedOnCurvePoints(*interpolatable_glyphs: Glyph) -> Set[int]:
    """Drop impliable on-curve points from the (simple) glyph or glyphs.

    In TrueType glyf outlines, on-curve points can be implied when they are located at
    the midpoint of the line connecting two consecutive off-curve points.

    If more than one glyphs are passed, these are assumed to be interpolatable masters
    of the same glyph impliable, and thus only the on-curve points that are impliable
    for all of them will actually be implied.
    Composite glyphs or empty glyphs are skipped, only simple glyphs with 1 or more
    contours are considered.
    The input glyph(s) is/are modified in-place.

    Args:
        interpolatable_glyphs: The glyph or glyphs to modify in-place.

    Returns:
        The set of point indices that were dropped if any.

    Raises:
        ValueError if simple glyphs are not in fact interpolatable because they have
        different point flags or number of contours.

    Reference:
    https://developer.apple.com/fonts/TrueType-Reference-Manual/RM01/Chap1.html
    """
    ...

class GlyphComponent:
    """Represents a component within a composite glyph.

    The component is represented internally with four attributes: ``glyphName``,
    ``x``, ``y`` and ``transform``. If there is no "two-by-two" matrix (i.e
    no scaling, reflection, or rotation; only translation), the ``transform``
    attribute is not present.
    """
    def __init__(self) -> None:
        ...
    
    def getComponentInfo(self): # -> tuple[Any, tuple[float | int, float | int, float | int, float | int, Any, Any] | tuple[Literal[1], Literal[0], Literal[0], Literal[1], Any, Any]]:
        """Return information about the component

        This method returns a tuple of two values: the glyph name of the component's
        base glyph, and a transformation matrix. As opposed to accessing the attributes
        directly, ``getComponentInfo`` always returns a six-element tuple of the
        component's transformation matrix, even when the two-by-two ``.transform``
        matrix is not present.
        """
        ...
    
    def decompile(self, data, glyfTable): # -> tuple[int, int, Any]:
        ...
    
    def compile(self, more, haveInstructions, glyfTable): # -> bytes:
        ...
    
    def toXML(self, writer, ttFont): # -> None:
        ...
    
    def fromXML(self, name, attrs, content, ttFont): # -> None:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    


class GlyphCoordinates:
    """A list of glyph coordinates.

    Unlike an ordinary list, this is a numpy-like matrix object which supports
    matrix addition, scalar multiplication and other operations described below.
    """
    def __init__(self, iterable=...) -> None:
        ...
    
    @property
    def array(self): # -> array[float]:
        """Returns the underlying array of coordinates"""
        ...
    
    @staticmethod
    def zeros(count): # -> GlyphCoordinates:
        """Creates a new ``GlyphCoordinates`` object with all coordinates set to (0,0)"""
        ...
    
    def copy(self): # -> GlyphCoordinates:
        """Creates a new ``GlyphCoordinates`` object which is a copy of the current one."""
        ...
    
    def __len__(self): # -> int:
        """Returns the number of coordinates in the array."""
        ...
    
    def __getitem__(self, k): # -> list[Any] | tuple[int | Any, int | Any]:
        """Returns a two element tuple (x,y)"""
        ...
    
    def __setitem__(self, k, v): # -> None:
        """Sets a point's coordinates to a two element tuple (x,y)"""
        ...
    
    def __delitem__(self, i): # -> None:
        """Removes a point from the list"""
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def append(self, p): # -> None:
        ...
    
    def extend(self, iterable): # -> None:
        ...
    
    def toInt(self, *, round=...): # -> None:
        ...
    
    def calcBounds(self): # -> tuple[Literal[0], Literal[0], Literal[0], Literal[0]] | tuple[float, float, float, float]:
        ...
    
    def calcIntBounds(self, round=...): # -> tuple[Any, ...]:
        ...
    
    def relativeToAbsolute(self): # -> None:
        ...
    
    def absoluteToRelative(self): # -> None:
        ...
    
    def translate(self, p): # -> None:
        """
        >>> GlyphCoordinates([(1,2)]).translate((.5,0))
        """
        ...
    
    def scale(self, p): # -> None:
        """
        >>> GlyphCoordinates([(1,2)]).scale((.5,0))
        """
        ...
    
    def transform(self, t): # -> None:
        """
        >>> GlyphCoordinates([(1,2)]).transform(((.5,0),(.2,.5)))
        """
        ...
    
    def __eq__(self, other) -> bool:
        """
        >>> g = GlyphCoordinates([(1,2)])
        >>> g2 = GlyphCoordinates([(1.0,2)])
        >>> g3 = GlyphCoordinates([(1.5,2)])
        >>> g == g2
        True
        >>> g == g3
        False
        >>> g2 == g3
        False
        """
        ...
    
    def __ne__(self, other) -> bool:
        """
        >>> g = GlyphCoordinates([(1,2)])
        >>> g2 = GlyphCoordinates([(1.0,2)])
        >>> g3 = GlyphCoordinates([(1.5,2)])
        >>> g != g2
        False
        >>> g != g3
        True
        >>> g2 != g3
        True
        """
        ...
    
    def __pos__(self): # -> GlyphCoordinates:
        """
        >>> g = GlyphCoordinates([(1,2)])
        >>> g
        GlyphCoordinates([(1, 2)])
        >>> g2 = +g
        >>> g2
        GlyphCoordinates([(1, 2)])
        >>> g2.translate((1,0))
        >>> g2
        GlyphCoordinates([(2, 2)])
        >>> g
        GlyphCoordinates([(1, 2)])
        """
        ...
    
    def __neg__(self): # -> GlyphCoordinates:
        """
        >>> g = GlyphCoordinates([(1,2)])
        >>> g
        GlyphCoordinates([(1, 2)])
        >>> g2 = -g
        >>> g2
        GlyphCoordinates([(-1, -2)])
        >>> g
        GlyphCoordinates([(1, 2)])
        """
        ...
    
    def __round__(self, *, round=...): # -> GlyphCoordinates:
        ...
    
    def __add__(self, other): # -> GlyphCoordinates | NotImplementedType:
        ...
    
    def __sub__(self, other): # -> GlyphCoordinates | NotImplementedType:
        ...
    
    def __mul__(self, other): # -> GlyphCoordinates | NotImplementedType:
        ...
    
    def __truediv__(self, other): # -> GlyphCoordinates | NotImplementedType:
        ...
    
    __radd__ = ...
    __rmul__ = ...
    def __rsub__(self, other):
        ...
    
    def __iadd__(self, other): # -> Self | NotImplementedType:
        """
        >>> g = GlyphCoordinates([(1,2)])
        >>> g += (.5,0)
        >>> g
        GlyphCoordinates([(1.5, 2)])
        >>> g2 = GlyphCoordinates([(3,4)])
        >>> g += g2
        >>> g
        GlyphCoordinates([(4.5, 6)])
        """
        ...
    
    def __isub__(self, other): # -> Self | NotImplementedType:
        """
        >>> g = GlyphCoordinates([(1,2)])
        >>> g -= (.5,0)
        >>> g
        GlyphCoordinates([(0.5, 2)])
        >>> g2 = GlyphCoordinates([(3,4)])
        >>> g -= g2
        >>> g
        GlyphCoordinates([(-2.5, -2)])
        """
        ...
    
    def __imul__(self, other): # -> Self | NotImplementedType:
        """
        >>> g = GlyphCoordinates([(1,2)])
        >>> g *= (2,.5)
        >>> g *= 2
        >>> g
        GlyphCoordinates([(4, 2)])
        >>> g = GlyphCoordinates([(1,2)])
        >>> g *= 2
        >>> g
        GlyphCoordinates([(2, 4)])
        """
        ...
    
    def __itruediv__(self, other): # -> Self | NotImplementedType:
        """
        >>> g = GlyphCoordinates([(1,3)])
        >>> g /= (.5,1.5)
        >>> g /= 2
        >>> g
        GlyphCoordinates([(1, 1)])
        """
        ...
    
    def __bool__(self): # -> bool:
        """
        >>> g = GlyphCoordinates([])
        >>> bool(g)
        False
        >>> g = GlyphCoordinates([(0,0), (0.,0)])
        >>> bool(g)
        True
        >>> g = GlyphCoordinates([(0,0), (1,0)])
        >>> bool(g)
        True
        >>> g = GlyphCoordinates([(0,.5), (0,0)])
        >>> bool(g)
        True
        """
        ...
    
    __nonzero__ = ...


if __name__ == "__main__":
    ...
