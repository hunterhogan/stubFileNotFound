from .DefaultTable import DefaultTable as DefaultTable
from _typeshed import Incomplete
from enum import IntEnum
from fontTools.config import OPTIONS as OPTIONS
from fontTools.misc.textTools import Tag as Tag, bytesjoin as bytesjoin
from typing import Iterator, NamedTuple

log: Incomplete
have_uharfbuzz: bool
USE_HARFBUZZ_REPACKER: Incomplete

class OverflowErrorRecord:
    tableType: Incomplete
    LookupListIndex: Incomplete
    SubTableIndex: Incomplete
    itemName: Incomplete
    itemIndex: Incomplete
    def __init__(self, overflowTuple) -> None: ...
    def __repr__(self) -> str: ...

class OTLOffsetOverflowError(Exception):
    value: Incomplete
    def __init__(self, overflowErrorRecord) -> None: ...
    def __str__(self) -> str: ...

class RepackerState(IntEnum):
    PURE_FT = 1
    HB_FT = 2
    FT_FALLBACK = 3

class BaseTTXConverter(DefaultTable):
    """Generic base class for TTX table converters. It functions as an
    adapter between the TTX (ttLib actually) table model and the model
    we use for OpenType tables, which is necessarily subtly different.
    """
    table: Incomplete
    def decompile(self, data, font) -> None:
        """Create an object from the binary data. Called automatically on access."""
    def compile(self, font):
        """Compiles the table into binary. Called automatically on save."""
    def tryPackingHarfbuzz(self, writer, hb_first_error_logged): ...
    def tryPackingFontTools(self, writer): ...
    def tryResolveOverflow(self, font, e, lastOverflowRecord): ...
    def toXML(self, writer, font) -> None: ...
    def fromXML(self, name, attrs, content, font) -> None: ...
    def ensureDecompiled(self, recurse: bool = True) -> None: ...

class OTTableReader:
    """Helper class to retrieve data from an OpenType table."""
    __slots__: Incomplete
    data: Incomplete
    offset: Incomplete
    pos: Incomplete
    localState: Incomplete
    tableTag: Incomplete
    def __init__(self, data, localState=None, offset: int = 0, tableTag=None) -> None: ...
    def advance(self, count) -> None: ...
    def seek(self, pos) -> None: ...
    def copy(self): ...
    def getSubReader(self, offset): ...
    def readValue(self, typecode, staticSize): ...
    def readArray(self, typecode, staticSize, count): ...
    def readInt8(self): ...
    def readInt8Array(self, count): ...
    def readShort(self): ...
    def readShortArray(self, count): ...
    def readLong(self): ...
    def readLongArray(self, count): ...
    def readUInt8(self): ...
    def readUInt8Array(self, count): ...
    def readUShort(self): ...
    def readUShortArray(self, count): ...
    def readULong(self): ...
    def readULongArray(self, count): ...
    def readUInt24(self): ...
    def readUInt24Array(self, count): ...
    def readTag(self): ...
    def readData(self, count): ...
    def __setitem__(self, name, value) -> None: ...
    def __getitem__(self, name): ...
    def __contains__(self, name) -> bool: ...

class OffsetToWriter:
    subWriter: Incomplete
    offsetSize: Incomplete
    def __init__(self, subWriter, offsetSize) -> None: ...
    def __eq__(self, other): ...
    def __hash__(self): ...

class OTTableWriter:
    """Helper class to gather and assemble data for OpenType tables."""
    items: Incomplete
    pos: Incomplete
    localState: Incomplete
    tableTag: Incomplete
    parent: Incomplete
    name: str
    def __init__(self, localState=None, tableTag=None) -> None: ...
    def __setitem__(self, name, value) -> None: ...
    def __getitem__(self, name): ...
    def __delitem__(self, name) -> None: ...
    def getDataLength(self):
        """Return the length of this table in bytes, without subtables."""
    def getData(self):
        """Assemble the data for this writer/table, without subtables."""
    def getDataForHarfbuzz(self):
        """Assemble the data for this writer/table with all offset field set to 0"""
    def __hash__(self): ...
    def __ne__(self, other): ...
    def __eq__(self, other): ...
    def _doneWriting(self, internedTables, shareExtension: bool = False) -> None: ...
    def _gatherTables(self, tables, extTables, done) -> None: ...
    def _gatherGraphForHarfbuzz(self, tables, obj_list, done, objidx, virtual_edges): ...
    def getAllDataUsingHarfbuzz(self, tableTag):
        """The Whole table is represented as a Graph.
        Assemble graph data and call Harfbuzz repacker to pack the table.
        Harfbuzz repacker is faster and retain as much sub-table sharing as possible, see also:
        https://github.com/harfbuzz/harfbuzz/blob/main/docs/repacker.md
        The input format for hb.repack() method is explained here:
        https://github.com/harfbuzz/uharfbuzz/blob/main/src/uharfbuzz/_harfbuzz.pyx#L1149
        """
    def getAllData(self, remove_duplicate: bool = True):
        """Assemble all data, including all subtables."""
    def getSubWriter(self): ...
    def writeValue(self, typecode, value) -> None: ...
    def writeArray(self, typecode, values) -> None: ...
    def writeInt8(self, value) -> None: ...
    def writeInt8Array(self, values) -> None: ...
    def writeShort(self, value) -> None: ...
    def writeShortArray(self, values) -> None: ...
    def writeLong(self, value) -> None: ...
    def writeLongArray(self, values) -> None: ...
    def writeUInt8(self, value) -> None: ...
    def writeUInt8Array(self, values) -> None: ...
    def writeUShort(self, value) -> None: ...
    def writeUShortArray(self, values) -> None: ...
    def writeULong(self, value) -> None: ...
    def writeULongArray(self, values) -> None: ...
    def writeUInt24(self, value) -> None: ...
    def writeUInt24Array(self, values) -> None: ...
    def writeTag(self, tag) -> None: ...
    def writeSubTable(self, subWriter, offsetSize) -> None: ...
    def writeCountReference(self, table, name, size: int = 2, value=None): ...
    def writeStruct(self, format, values) -> None: ...
    def writeData(self, data) -> None: ...
    def getOverflowErrorRecord(self, item): ...

class CountReference:
    """A reference to a Count value, not a count of references."""
    table: Incomplete
    name: Incomplete
    size: Incomplete
    def __init__(self, table, name, size=None, value=None) -> None: ...
    def setValue(self, value) -> None: ...
    def getValue(self): ...
    def getCountData(self): ...

def packUInt8(value): ...
def packUShort(value): ...
def packULong(value): ...
def packUInt24(value): ...

class BaseTable:
    """Generic base class for all OpenType (sub)tables."""
    def __getattr__(self, attr): ...
    def ensureDecompiled(self, recurse: bool = False) -> None: ...
    def __getstate__(self): ...
    @classmethod
    def getRecordSize(cls, reader): ...
    def getConverters(self): ...
    def getConverterByName(self, name): ...
    def populateDefaults(self, propagator=None) -> None: ...
    __rawTable: Incomplete
    def decompile(self, reader, font) -> None: ...
    def compile(self, writer, font) -> None: ...
    def readFormat(self, reader) -> None: ...
    def writeFormat(self, writer) -> None: ...
    def toXML(self, xmlWriter, font, attrs=None, name=None) -> None: ...
    def toXML2(self, xmlWriter, font) -> None: ...
    def fromXML(self, name, attrs, content, font) -> None: ...
    def __ne__(self, other): ...
    def __eq__(self, other): ...
    class SubTableEntry(NamedTuple):
        """See BaseTable.iterSubTables()"""
        name: str
        value: BaseTable
        index: int | None = ...
    def iterSubTables(self) -> Iterator[SubTableEntry]:
        """Yield (name, value, index) namedtuples for all subtables of current table.

        A sub-table is an instance of BaseTable (or subclass thereof) that is a child
        of self, the current parent table.
        The tuples also contain the attribute name (str) of the of parent table to get
        a subtable, and optionally, for lists of subtables (i.e. attributes associated
        with a converter that has a 'repeat'), an index into the list containing the
        given subtable value.
        This method can be useful to traverse trees of otTables.
        """
    def getVariableAttrs(self): ...

class FormatSwitchingBaseTable(BaseTable):
    """Minor specialization of BaseTable, for tables that have multiple
    formats, eg. CoverageFormat1 vs. CoverageFormat2."""
    @classmethod
    def getRecordSize(cls, reader): ...
    def getConverters(self): ...
    def getConverterByName(self, name): ...
    Format: Incomplete
    def readFormat(self, reader) -> None: ...
    def writeFormat(self, writer) -> None: ...
    def toXML(self, xmlWriter, font, attrs=None, name=None) -> None: ...
    def getVariableAttrs(self): ...

class UInt8FormatSwitchingBaseTable(FormatSwitchingBaseTable):
    Format: Incomplete
    def readFormat(self, reader) -> None: ...
    def writeFormat(self, writer) -> None: ...

formatSwitchingBaseTables: Incomplete

def getFormatSwitchingBaseTableClass(formatType): ...
def getVariableAttrs(cls, fmt: int | None = None) -> tuple[str]:
    '''Return sequence of variable table field names (can be empty).

    Attributes are deemed "variable" when their otData.py\'s description contain
    \'VarIndexBase + {offset}\', e.g. COLRv1 PaintVar* tables.
    '''

valueRecordFormat: Incomplete

def _buildDict(): ...

valueRecordFormatDict: Incomplete

class ValueRecordFactory:
    """Given a format code, this object convert ValueRecords."""
    format: Incomplete
    def __init__(self, valueFormat) -> None: ...
    def __len__(self) -> int: ...
    def readValueRecord(self, reader, font): ...
    def writeValueRecord(self, writer, font, valueRecord) -> None: ...

class ValueRecord:
    __dict__: Incomplete
    def __init__(self, valueFormat=None, src=None) -> None: ...
    def getFormat(self): ...
    def getEffectiveFormat(self): ...
    def toXML(self, xmlWriter, font, valueName, attrs=None) -> None: ...
    def fromXML(self, name, attrs, content, font) -> None: ...
    def __ne__(self, other): ...
    def __eq__(self, other): ...
