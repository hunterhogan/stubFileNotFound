"""
This type stub file was generated by pyright.
"""

from fontTools.misc.loggingTools import deprecateFunction
from fontTools.misc.psCharStrings import T2OutlineExtractor
from fontTools.pens.t2CharStringPen import T2CharStringPen
from .errors import VarLibCFFDictMergeError, VarLibCFFPointTypeMergeError

MergeDictError = VarLibCFFDictMergeError
MergeTypeError = VarLibCFFPointTypeMergeError
def addCFFVarStore(varFont, varModel, varDataList, masterSupports): # -> None:
    ...

@deprecateFunction("Use fontTools.cffLib.CFFToCFF2.convertCFFToCFF2 instead.")
def convertCFFtoCFF2(varFont): # -> None:
    ...

def conv_to_int(num): # -> int | float:
    ...

pd_blend_fields = ...
def get_private(regionFDArrays, fd_index, ri, fd_map): # -> None:
    ...

def merge_PrivateDicts(top_dicts, vsindex_dict, var_model, fd_map): # -> None:
    """
    I step through the FontDicts in the FDArray of the varfont TopDict.
    For each varfont FontDict:

    * step through each key in FontDict.Private.
    * For each key, step through each relevant source font Private dict, and
      build a list of values to blend.

    The 'relevant' source fonts are selected by first getting the right
    submodel using ``vsindex_dict[vsindex]``. The indices of the
    ``subModel.locations`` are mapped to source font list indices by
    assuming the latter order is the same as the order of the
    ``var_model.locations``. I can then get the index of each subModel
    location in the list of ``var_model.locations``.
    """
    ...

def getfd_map(varFont, fonts_list): # -> dict[Any, Any]:
    """Since a subset source font may have fewer FontDicts in their
    FDArray than the default font, we have to match up the FontDicts in
    the different fonts . We do this with the FDSelect array, and by
    assuming that the same glyph will reference  matching FontDicts in
    each source font. We return a mapping from fdIndex in the default
    font to a dictionary which maps each master list index of each
    region font to the equivalent fdIndex in the region font."""
    ...

CVarData = ...
def merge_region_fonts(varFont, model, ordered_fonts_list, glyphOrder): # -> None:
    ...

def merge_charstrings(glyphOrder, num_masters, top_dicts, masterModel): # -> CVarData:
    ...

class CFFToCFF2OutlineExtractor(T2OutlineExtractor):
    """This class is used to remove the initial width from the CFF
    charstring without trying to add the width to self.nominalWidthX,
    which is None."""
    def popallWidth(self, evenOdd=...): # -> list[Any]:
        ...
    


class MergeOutlineExtractor(CFFToCFF2OutlineExtractor):
    """Used to extract the charstring commands - including hints - from a
    CFF charstring in order to merge it as another set of region data
    into a CFF2 variable font charstring."""
    def __init__(self, pen, localSubrs, globalSubrs, nominalWidthX, defaultWidthX, private=..., blender=...) -> None:
        ...
    
    def countHints(self): # -> list[Any]:
        ...
    
    def op_hstem(self, index): # -> None:
        ...
    
    def op_vstem(self, index): # -> None:
        ...
    
    def op_hstemhm(self, index): # -> None:
        ...
    
    def op_vstemhm(self, index): # -> None:
        ...
    
    def op_hintmask(self, index): # -> tuple[Any, Any]:
        ...
    
    def op_cntrmask(self, index): # -> tuple[Any, Any]:
        ...
    


class CFF2CharStringMergePen(T2CharStringPen):
    """Pen to merge Type 2 CharStrings."""
    def __init__(self, default_commands, glyphName, num_masters, master_idx, roundTolerance=...) -> None:
        ...
    
    def add_point(self, point_type, pt_coords): # -> None:
        ...
    
    def add_hint(self, hint_type, args): # -> None:
        ...
    
    def add_hintmask(self, hint_type, abs_args): # -> None:
        ...
    
    def restart(self, region_idx): # -> None:
        ...
    
    def getCommands(self): # -> List[Tuple[str | bytes, List[float]]]:
        ...
    
    def reorder_blend_args(self, commands, get_delta_func):
        """
        We first re-order the master coordinate values.
        For a moveto to lineto, the args are now arranged as::

                [ [master_0 x,y], [master_1 x,y], [master_2 x,y] ]

        We re-arrange this to::

                [	[master_0 x, master_1 x, master_2 x],
                        [master_0 y, master_1 y, master_2 y]
                ]

        If the master values are all the same, we collapse the list to
        as single value instead of a list.

        We then convert this to::

                [ [master_0 x] + [x delta tuple] + [numBlends=1]
                  [master_0 y] + [y delta tuple] + [numBlends=1]
                ]
        """
        ...
    
    def getCharString(self, private=..., globalSubrs=..., var_model=..., optimize=...): # -> T2CharString:
        ...
    


