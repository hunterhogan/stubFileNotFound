from _typeshed import Incomplete
from enum import Enum as Enum
from fontTools.misc.transform import Transform as Transform
from fontTools.pens.basePen import AbstractPen as AbstractPen, BasePen as BasePen, DecomposingPen as DecomposingPen
from fontTools.pens.pointPen import AbstractPointPen as AbstractPointPen, SegmentToPointPen as SegmentToPointPen
from fontTools.pens.recordingPen import DecomposingRecordingPen as DecomposingRecordingPen, RecordingPen as RecordingPen
from fontTools.ttLib.ttGlyphSet import LerpGlyphSet as LerpGlyphSet

log: Incomplete

class InterpolatableProblem:
    NOTHING: str
    MISSING: str
    OPEN_PATH: str
    PATH_COUNT: str
    NODE_COUNT: str
    NODE_INCOMPATIBILITY: str
    CONTOUR_ORDER: str
    WRONG_START_POINT: str
    KINK: str
    UNDERWEIGHT: str
    OVERWEIGHT: str
    severity: Incomplete

def sort_problems(problems):
    """Sort problems by severity, then by glyph name, then by problem message."""
def rot_list(l, k):
    """Rotate list by k items forward.  Ie. item at position 0 will be
    at position k in returned list.  Negative k is allowed."""

class PerContourPen(BasePen):
    _glyphset: Incomplete
    _Pen: Incomplete
    _pen: Incomplete
    value: Incomplete
    def __init__(self, Pen, glyphset=None) -> None: ...
    def _moveTo(self, p0) -> None: ...
    def _lineTo(self, p1) -> None: ...
    def _qCurveToOne(self, p1, p2) -> None: ...
    def _curveToOne(self, p1, p2, p3) -> None: ...
    def _closePath(self) -> None: ...
    def _endPath(self) -> None: ...
    def _newItem(self) -> None: ...

class PerContourOrComponentPen(PerContourPen):
    def addComponent(self, glyphName, transformation) -> None: ...

class SimpleRecordingPointPen(AbstractPointPen):
    value: Incomplete
    def __init__(self) -> None: ...
    def beginPath(self, identifier=None, **kwargs) -> None: ...
    def endPath(self) -> None: ...
    def addPoint(self, pt, segmentType=None) -> None: ...

def vdiff_hypot2(v0, v1): ...
def vdiff_hypot2_complex(v0, v1): ...
def matching_cost(G, matching): ...
def min_cost_perfect_bipartite_matching_scipy(G): ...
def min_cost_perfect_bipartite_matching_munkres(G): ...
def min_cost_perfect_bipartite_matching_bruteforce(G): ...
min_cost_perfect_bipartite_matching = min_cost_perfect_bipartite_matching_scipy
min_cost_perfect_bipartite_matching = min_cost_perfect_bipartite_matching_munkres
min_cost_perfect_bipartite_matching = min_cost_perfect_bipartite_matching_bruteforce

def contour_vector_from_stats(stats): ...
def matching_for_vectors(m0, m1): ...
def points_characteristic_bits(points): ...

_NUM_ITEMS_PER_POINTS_COMPLEX_VECTOR: int

def points_complex_vector(points): ...
def add_isomorphisms(points, isomorphisms, reverse) -> None: ...
def find_parents_and_order(glyphsets, locations, *, discrete_axes=...): ...
def transform_from_stats(stats, inverse: bool = False): ...
